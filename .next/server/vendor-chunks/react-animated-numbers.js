"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-animated-numbers";
exports.ids = ["vendor-chunks/react-animated-numbers"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-animated-numbers/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-animated-numbers/dist/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n!function(t1, e) {\n    if (true) module.exports = e(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n    else { var s, n; }\n}(self, function(t1) {\n    return (()=>{\n        \"use strict\";\n        var e = {\n            297: (e)=>{\n                e.exports = t1;\n            }\n        }, n = {};\n        function s(t1) {\n            var i = n[t1];\n            if (void 0 !== i) return i.exports;\n            var o = n[t1] = {\n                exports: {}\n            };\n            return e[t1](o, o.exports, s), o.exports;\n        }\n        s.n = (t1)=>{\n            var e = t1 && t1.__esModule ? ()=>t1.default : ()=>t1;\n            return s.d(e, {\n                a: e\n            }), e;\n        }, s.d = (t1, e)=>{\n            for(var n in e)s.o(e, n) && !s.o(t1, n) && Object.defineProperty(t1, n, {\n                enumerable: !0,\n                get: e[n]\n            });\n        }, s.o = (t1, e)=>Object.prototype.hasOwnProperty.call(t1, e), s.r = (t1)=>{\n            \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t1, Symbol.toStringTag, {\n                value: \"Module\"\n            }), Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            });\n        };\n        var i = {};\n        return (()=>{\n            s.r(i), s.d(i, {\n                default: ()=>jo\n            });\n            var t1 = s(297), e = s.n(t1);\n            const n = (t1)=>t1;\n            let o = n, r = n;\n            const a = {\n                some: 0,\n                all: 1\n            };\n            const l = (t1)=>/^\\-?\\d*\\.?\\d+$/.test(t1), u = (t1)=>/^0[^.\\s]+$/.test(t1), c = (t1)=>Array.isArray(t1);\n            function h(t1, e) {\n                -1 === t1.indexOf(e) && t1.push(e);\n            }\n            function d(t1, e) {\n                const n = t1.indexOf(e);\n                n > -1 && t1.splice(n, 1);\n            }\n            class m {\n                constructor(){\n                    this.subscriptions = [];\n                }\n                add(t1) {\n                    return h(this.subscriptions, t1), ()=>d(this.subscriptions, t1);\n                }\n                notify(t1, e, n) {\n                    const s = this.subscriptions.length;\n                    if (s) if (1 === s) this.subscriptions[0](t1, e, n);\n                    else for(let i = 0; i < s; i++){\n                        const s = this.subscriptions[i];\n                        s && s(t1, e, n);\n                    }\n                }\n                getSize() {\n                    return this.subscriptions.length;\n                }\n                clear() {\n                    this.subscriptions.length = 0;\n                }\n            }\n            function p(t1, e) {\n                return e ? t1 * (1e3 / e) : 0;\n            }\n            class f {\n                constructor(){\n                    this.order = [], this.scheduled = new Set;\n                }\n                add(t1) {\n                    if (!this.scheduled.has(t1)) return this.scheduled.add(t1), this.order.push(t1), !0;\n                }\n                remove(t1) {\n                    const e = this.order.indexOf(t1);\n                    -1 !== e && (this.order.splice(e, 1), this.scheduled.delete(t1));\n                }\n                clear() {\n                    this.order.length = 0, this.scheduled.clear();\n                }\n            }\n            const g = [\n                \"prepare\",\n                \"read\",\n                \"update\",\n                \"preRender\",\n                \"render\",\n                \"postRender\"\n            ], { schedule: y, cancel: v, state: x, steps: P } = function(t1, e) {\n                let n = !1, s = !0;\n                const i = {\n                    delta: 0,\n                    timestamp: 0,\n                    isProcessing: !1\n                }, o = g.reduce((t1, e)=>(t1[e] = function(t1) {\n                        let e = new f, n = new f, s = 0, i = !1, o = !1;\n                        const r = new WeakSet, a = {\n                            schedule: (t1, o = !1, a = !1)=>{\n                                const l = a && i, u = l ? e : n;\n                                return o && r.add(t1), u.add(t1) && l && i && (s = e.order.length), t1;\n                            },\n                            cancel: (t1)=>{\n                                n.remove(t1), r.delete(t1);\n                            },\n                            process: (l)=>{\n                                if (i) o = !0;\n                                else {\n                                    if (i = !0, [e, n] = [\n                                        n,\n                                        e\n                                    ], n.clear(), s = e.order.length, s) for(let n = 0; n < s; n++){\n                                        const s = e.order[n];\n                                        s(l), r.has(s) && (a.schedule(s), t1());\n                                    }\n                                    i = !1, o && (o = !1, a.process(l));\n                                }\n                            }\n                        };\n                        return a;\n                    }(()=>n = !0), t1), {}), r = (t1)=>o[t1].process(i), a = ()=>{\n                    const e = performance.now();\n                    n = !1, i.delta = s ? 1e3 / 60 : Math.max(Math.min(e - i.timestamp, 40), 1), i.timestamp = e, i.isProcessing = !0, g.forEach(r), i.isProcessing = !1, n && (s = !1, t1(a));\n                };\n                return {\n                    schedule: g.reduce((e, r)=>{\n                        const l = o[r];\n                        return e[r] = (e, o = !1, r = !1)=>(n || (n = !0, s = !0, i.isProcessing || t1(a)), l.schedule(e, o, r)), e;\n                    }, {}),\n                    cancel: (t1)=>g.forEach((e)=>o[e].cancel(t1)),\n                    state: i,\n                    steps: o\n                };\n            }(\"undefined\" != typeof requestAnimationFrame ? requestAnimationFrame : n), b = {\n                current: void 0\n            };\n            class T {\n                constructor(t1, e = {}){\n                    var n;\n                    this.version = \"10.16.5\", this.timeDelta = 0, this.lastUpdated = 0, this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (t1, e = !0)=>{\n                        this.prev = this.current, this.current = t1;\n                        const { delta: n, timestamp: s } = x;\n                        this.lastUpdated !== s && (this.timeDelta = n, this.lastUpdated = s, y.postRender(this.scheduleVelocityCheck)), this.prev !== this.current && this.events.change && this.events.change.notify(this.current), this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()), e && this.events.renderRequest && this.events.renderRequest.notify(this.current);\n                    }, this.scheduleVelocityCheck = ()=>y.postRender(this.velocityCheck), this.velocityCheck = ({ timestamp: t1 })=>{\n                        t1 !== this.lastUpdated && (this.prev = this.current, this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()));\n                    }, this.hasAnimated = !1, this.prev = this.current = t1, this.canTrackVelocity = (n = this.current, !isNaN(parseFloat(n))), this.owner = e.owner;\n                }\n                onChange(t1) {\n                    return this.on(\"change\", t1);\n                }\n                on(t1, e) {\n                    this.events[t1] || (this.events[t1] = new m);\n                    const n = this.events[t1].add(e);\n                    return \"change\" === t1 ? ()=>{\n                        n(), y.read(()=>{\n                            this.events.change.getSize() || this.stop();\n                        });\n                    } : n;\n                }\n                clearListeners() {\n                    for(const t1 in this.events)this.events[t1].clear();\n                }\n                attach(t1, e) {\n                    this.passiveEffect = t1, this.stopPassiveEffect = e;\n                }\n                set(t1, e = !0) {\n                    e && this.passiveEffect ? this.passiveEffect(t1, this.updateAndNotify) : this.updateAndNotify(t1, e);\n                }\n                setWithVelocity(t1, e, n) {\n                    this.set(e), this.prev = t1, this.timeDelta = n;\n                }\n                jump(t1) {\n                    this.updateAndNotify(t1), this.prev = t1, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();\n                }\n                get() {\n                    return b.current && b.current.push(this), this.current;\n                }\n                getPrevious() {\n                    return this.prev;\n                }\n                getVelocity() {\n                    return this.canTrackVelocity ? p(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n                }\n                start(t1) {\n                    return this.stop(), new Promise((e)=>{\n                        this.hasAnimated = !0, this.animation = t1(e), this.events.animationStart && this.events.animationStart.notify();\n                    }).then(()=>{\n                        this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();\n                    });\n                }\n                stop() {\n                    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();\n                }\n                isAnimating() {\n                    return !!this.animation;\n                }\n                clearAnimation() {\n                    delete this.animation;\n                }\n                destroy() {\n                    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();\n                }\n            }\n            function S(t1, e) {\n                return new T(t1, e);\n            }\n            const w = (t1)=>(e)=>\"string\" == typeof e && e.startsWith(t1), E = w(\"--\"), A = w(\"var(--\"), V = (t1)=>Math.round(1e5 * t1) / 1e5, C = /(-)?([\\d]*\\.?[\\d])+/g, M = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))/gi, D = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))$/i;\n            function k(t1) {\n                return \"string\" == typeof t1;\n            }\n            const R = (t1, e, n)=>Math.min(Math.max(n, t1), e), L = {\n                test: (t1)=>\"number\" == typeof t1,\n                parse: parseFloat,\n                transform: (t1)=>t1\n            }, j = {\n                ...L,\n                transform: (t1)=>R(0, 1, t1)\n            }, B = {\n                ...L,\n                default: 1\n            }, F = (t1, e)=>(n)=>Boolean(k(n) && D.test(n) && n.startsWith(t1) || e && Object.prototype.hasOwnProperty.call(n, e)), O = (t1, e, n)=>(s)=>{\n                    if (!k(s)) return s;\n                    const [i, o, r, a] = s.match(C);\n                    return {\n                        [t1]: parseFloat(i),\n                        [e]: parseFloat(o),\n                        [n]: parseFloat(r),\n                        alpha: void 0 !== a ? parseFloat(a) : 1\n                    };\n                }, I = {\n                ...L,\n                transform: (t1)=>Math.round(((t1)=>R(0, 255, t1))(t1))\n            }, U = {\n                test: F(\"rgb\", \"red\"),\n                parse: O(\"red\", \"green\", \"blue\"),\n                transform: ({ red: t1, green: e, blue: n, alpha: s = 1 })=>\"rgba(\" + I.transform(t1) + \", \" + I.transform(e) + \", \" + I.transform(n) + \", \" + V(j.transform(s)) + \")\"\n            }, N = {\n                test: F(\"#\"),\n                parse: function(t1) {\n                    let e = \"\", n = \"\", s = \"\", i = \"\";\n                    return t1.length > 5 ? (e = t1.substring(1, 3), n = t1.substring(3, 5), s = t1.substring(5, 7), i = t1.substring(7, 9)) : (e = t1.substring(1, 2), n = t1.substring(2, 3), s = t1.substring(3, 4), i = t1.substring(4, 5), e += e, n += n, s += s, i += i), {\n                        red: parseInt(e, 16),\n                        green: parseInt(n, 16),\n                        blue: parseInt(s, 16),\n                        alpha: i ? parseInt(i, 16) / 255 : 1\n                    };\n                },\n                transform: U.transform\n            }, $ = (t1)=>({\n                    test: (e)=>k(e) && e.endsWith(t1) && 1 === e.split(\" \").length,\n                    parse: parseFloat,\n                    transform: (e)=>`${e}${t1}`\n                }), W = $(\"deg\"), H = $(\"%\"), z = $(\"px\"), Y = $(\"vh\"), X = $(\"vw\"), G = {\n                ...H,\n                parse: (t1)=>H.parse(t1) / 100,\n                transform: (t1)=>H.transform(100 * t1)\n            }, q = {\n                test: F(\"hsl\", \"hue\"),\n                parse: O(\"hue\", \"saturation\", \"lightness\"),\n                transform: ({ hue: t1, saturation: e, lightness: n, alpha: s = 1 })=>\"hsla(\" + Math.round(t1) + \", \" + H.transform(V(e)) + \", \" + H.transform(V(n)) + \", \" + V(j.transform(s)) + \")\"\n            }, Z = {\n                test: (t1)=>U.test(t1) || N.test(t1) || q.test(t1),\n                parse: (t1)=>U.test(t1) ? U.parse(t1) : q.test(t1) ? q.parse(t1) : N.parse(t1),\n                transform: (t1)=>k(t1) ? t1 : t1.hasOwnProperty(\"red\") ? U.transform(t1) : q.transform(t1)\n            }, K = {\n                regex: /var\\s*\\(\\s*--[\\w-]+(\\s*,\\s*(?:(?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)+)?\\s*\\)/g,\n                countKey: \"Vars\",\n                token: \"${v}\",\n                parse: n\n            }, _ = {\n                regex: M,\n                countKey: \"Colors\",\n                token: \"${c}\",\n                parse: Z.parse\n            }, J = {\n                regex: C,\n                countKey: \"Numbers\",\n                token: \"${n}\",\n                parse: L.parse\n            };\n            function Q(t1, { regex: e, countKey: n, token: s, parse: i }) {\n                const o = t1.tokenised.match(e);\n                o && (t1[\"num\" + n] = o.length, t1.tokenised = t1.tokenised.replace(e, s), t1.values.push(...o.map(i)));\n            }\n            function tt(t1) {\n                const e = t1.toString(), n = {\n                    value: e,\n                    tokenised: e,\n                    values: [],\n                    numVars: 0,\n                    numColors: 0,\n                    numNumbers: 0\n                };\n                return n.value.includes(\"var(--\") && Q(n, K), Q(n, _), Q(n, J), n;\n            }\n            function et(t1) {\n                return tt(t1).values;\n            }\n            function nt(t1) {\n                const { values: e, numColors: n, numVars: s, tokenised: i } = tt(t1), o = e.length;\n                return (t1)=>{\n                    let e = i;\n                    for(let i = 0; i < o; i++)e = i < s ? e.replace(K.token, t1[i]) : i < s + n ? e.replace(_.token, Z.transform(t1[i])) : e.replace(J.token, V(t1[i]));\n                    return e;\n                };\n            }\n            const st = (t1)=>\"number\" == typeof t1 ? 0 : t1, it = {\n                test: function(t1) {\n                    var e, n;\n                    return isNaN(t1) && k(t1) && ((null === (e = t1.match(C)) || void 0 === e ? void 0 : e.length) || 0) + ((null === (n = t1.match(M)) || void 0 === n ? void 0 : n.length) || 0) > 0;\n                },\n                parse: et,\n                createTransformer: nt,\n                getAnimatableNone: function(t1) {\n                    const e = et(t1);\n                    return nt(t1)(e.map(st));\n                }\n            }, ot = new Set([\n                \"brightness\",\n                \"contrast\",\n                \"saturate\",\n                \"opacity\"\n            ]);\n            function rt(t1) {\n                const [e, n] = t1.slice(0, -1).split(\"(\");\n                if (\"drop-shadow\" === e) return t1;\n                const [s] = n.match(C) || [];\n                if (!s) return t1;\n                const i = n.replace(s, \"\");\n                let o = ot.has(e) ? 1 : 0;\n                return s !== n && (o *= 100), e + \"(\" + o + i + \")\";\n            }\n            const at = /([a-z-]*)\\(.*?\\)/g, lt = {\n                ...it,\n                getAnimatableNone: (t1)=>{\n                    const e = t1.match(at);\n                    return e ? e.map(rt).join(\" \") : t1;\n                }\n            }, ut = {\n                ...L,\n                transform: Math.round\n            }, ct = {\n                borderWidth: z,\n                borderTopWidth: z,\n                borderRightWidth: z,\n                borderBottomWidth: z,\n                borderLeftWidth: z,\n                borderRadius: z,\n                radius: z,\n                borderTopLeftRadius: z,\n                borderTopRightRadius: z,\n                borderBottomRightRadius: z,\n                borderBottomLeftRadius: z,\n                width: z,\n                maxWidth: z,\n                height: z,\n                maxHeight: z,\n                size: z,\n                top: z,\n                right: z,\n                bottom: z,\n                left: z,\n                padding: z,\n                paddingTop: z,\n                paddingRight: z,\n                paddingBottom: z,\n                paddingLeft: z,\n                margin: z,\n                marginTop: z,\n                marginRight: z,\n                marginBottom: z,\n                marginLeft: z,\n                rotate: W,\n                rotateX: W,\n                rotateY: W,\n                rotateZ: W,\n                scale: B,\n                scaleX: B,\n                scaleY: B,\n                scaleZ: B,\n                skew: W,\n                skewX: W,\n                skewY: W,\n                distance: z,\n                translateX: z,\n                translateY: z,\n                translateZ: z,\n                x: z,\n                y: z,\n                z,\n                perspective: z,\n                transformPerspective: z,\n                opacity: j,\n                originX: G,\n                originY: G,\n                originZ: z,\n                zIndex: ut,\n                fillOpacity: j,\n                strokeOpacity: j,\n                numOctaves: ut\n            }, ht = {\n                ...ct,\n                color: Z,\n                backgroundColor: Z,\n                outlineColor: Z,\n                fill: Z,\n                stroke: Z,\n                borderColor: Z,\n                borderTopColor: Z,\n                borderRightColor: Z,\n                borderBottomColor: Z,\n                borderLeftColor: Z,\n                filter: lt,\n                WebkitFilter: lt\n            }, dt = (t1)=>ht[t1];\n            function mt(t1, e) {\n                let n = dt(t1);\n                return n !== lt && (n = it), n.getAnimatableNone ? n.getAnimatableNone(e) : void 0;\n            }\n            const pt = (t1)=>(e)=>e.test(t1), ft = [\n                L,\n                z,\n                H,\n                W,\n                X,\n                Y,\n                {\n                    test: (t1)=>\"auto\" === t1,\n                    parse: (t1)=>t1\n                }\n            ], gt = (t1)=>ft.find(pt(t1)), yt = [\n                ...ft,\n                Z,\n                it\n            ];\n            function vt(t1, e, n, s = {}, i = {}) {\n                return \"function\" == typeof e && (e = e(void 0 !== n ? n : t1.custom, s, i)), \"string\" == typeof e && (e = t1.variants && t1.variants[e]), \"function\" == typeof e && (e = e(void 0 !== n ? n : t1.custom, s, i)), e;\n            }\n            function xt(t1, e, n) {\n                const s = t1.getProps();\n                return vt(s, e, void 0 !== n ? n : s.custom, function(t1) {\n                    const e = {};\n                    return t1.values.forEach((t1, n)=>e[n] = t1.get()), e;\n                }(t1), function(t1) {\n                    const e = {};\n                    return t1.values.forEach((t1, n)=>e[n] = t1.getVelocity()), e;\n                }(t1));\n            }\n            function Pt(t1, e, n) {\n                t1.hasValue(e) ? t1.getValue(e).set(n) : t1.addValue(e, S(n));\n            }\n            function bt(t1, e) {\n                const n = xt(t1, e);\n                let { transitionEnd: s = {}, transition: i = {}, ...o } = n ? t1.makeTargetAnimatable(n, !1) : {};\n                o = {\n                    ...o,\n                    ...s\n                };\n                for(const e in o)Pt(t1, e, (r = o[e], c(r) ? r[r.length - 1] || 0 : r));\n                var r;\n            }\n            function Tt(t1, e) {\n                [\n                    ...e\n                ].reverse().forEach((n)=>{\n                    const s = t1.getVariant(n);\n                    s && bt(t1, s), t1.variantChildren && t1.variantChildren.forEach((t1)=>{\n                        Tt(t1, e);\n                    });\n                });\n            }\n            function St(t1, e) {\n                if (e) return (e[t1] || e.default || e).from;\n            }\n            const wt = [\n                \"transformPerspective\",\n                \"x\",\n                \"y\",\n                \"z\",\n                \"translateX\",\n                \"translateY\",\n                \"translateZ\",\n                \"scale\",\n                \"scaleX\",\n                \"scaleY\",\n                \"rotate\",\n                \"rotateX\",\n                \"rotateY\",\n                \"rotateZ\",\n                \"skew\",\n                \"skewX\",\n                \"skewY\"\n            ], Et = new Set(wt), At = (t1)=>t1.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase(), Vt = \"data-\" + At(\"framerAppearId\"), Ct = (t1)=>1e3 * t1, Mt = (t1)=>t1 / 1e3, Dt = (t1)=>Array.isArray(t1) && \"number\" == typeof t1[0];\n            function kt(t1) {\n                return Boolean(!t1 || \"string\" == typeof t1 && Lt[t1] || Dt(t1) || Array.isArray(t1) && t1.every(kt));\n            }\n            const Rt = ([t1, e, n, s])=>`cubic-bezier(${t1}, ${e}, ${n}, ${s})`, Lt = {\n                linear: \"linear\",\n                ease: \"ease\",\n                easeIn: \"ease-in\",\n                easeOut: \"ease-out\",\n                easeInOut: \"ease-in-out\",\n                circIn: Rt([\n                    0,\n                    .65,\n                    .55,\n                    1\n                ]),\n                circOut: Rt([\n                    .55,\n                    0,\n                    1,\n                    .45\n                ]),\n                backIn: Rt([\n                    .31,\n                    .01,\n                    .66,\n                    -.59\n                ]),\n                backOut: Rt([\n                    .33,\n                    1.53,\n                    .69,\n                    .99\n                ])\n            };\n            function jt(t1) {\n                if (t1) return Dt(t1) ? Rt(t1) : Array.isArray(t1) ? t1.map(jt) : Lt[t1];\n            }\n            const Bt = (t1, e, n)=>(((1 - 3 * n + 3 * e) * t1 + (3 * n - 6 * e)) * t1 + 3 * e) * t1;\n            function Ft(t1, e, s, i) {\n                if (t1 === e && s === i) return n;\n                return (n)=>0 === n || 1 === n ? n : Bt(function(t1, e, n, s, i) {\n                        let o, r, a = 0;\n                        do {\n                            r = e + (n - e) / 2, o = Bt(r, s, i) - t1, o > 0 ? n = r : e = r;\n                        }while (Math.abs(o) > 1e-7 && ++a < 12);\n                        return r;\n                    }(n, 0, 1, t1, s), e, i);\n            }\n            const Ot = Ft(.42, 0, 1, 1), It = Ft(0, 0, .58, 1), Ut = Ft(.42, 0, .58, 1), Nt = (t1)=>(e)=>e <= .5 ? t1(2 * e) / 2 : (2 - t1(2 * (1 - e))) / 2, $t = (t1)=>(e)=>1 - t1(1 - e), Wt = (t1)=>1 - Math.sin(Math.acos(t1)), Ht = $t(Wt), zt = Nt(Ht), Yt = Ft(.33, 1.53, .69, .99), Xt = $t(Yt), Gt = Nt(Xt), qt = {\n                linear: n,\n                easeIn: Ot,\n                easeInOut: Ut,\n                easeOut: It,\n                circIn: Wt,\n                circInOut: zt,\n                circOut: Ht,\n                backIn: Xt,\n                backInOut: Gt,\n                backOut: Yt,\n                anticipate: (t1)=>(t1 *= 2) < 1 ? .5 * Xt(t1) : .5 * (2 - Math.pow(2, -10 * (t1 - 1)))\n            }, Zt = (t1)=>{\n                if (Array.isArray(t1)) {\n                    r(4 === t1.length, \"Cubic bezier arrays must contain four numerical values.\");\n                    const [e, n, s, i] = t1;\n                    return Ft(e, n, s, i);\n                }\n                return \"string\" == typeof t1 ? (r(void 0 !== qt[t1], `Invalid easing type '${t1}'`), qt[t1]) : t1;\n            }, Kt = (t1, e, n)=>-n * t1 + n * e + t1;\n            function _t(t1, e, n) {\n                return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t1 + 6 * (e - t1) * n : n < .5 ? e : n < 2 / 3 ? t1 + (e - t1) * (2 / 3 - n) * 6 : t1;\n            }\n            const Jt = (t1, e, n)=>{\n                const s = t1 * t1;\n                return Math.sqrt(Math.max(0, n * (e * e - s) + s));\n            }, Qt = [\n                N,\n                U,\n                q\n            ];\n            function te(t1) {\n                const e = (n = t1, Qt.find((t1)=>t1.test(n)));\n                var n;\n                r(Boolean(e), `'${t1}' is not an animatable color. Use the equivalent color code instead.`);\n                let s = e.parse(t1);\n                return e === q && (s = function({ hue: t1, saturation: e, lightness: n, alpha: s }) {\n                    t1 /= 360, n /= 100;\n                    let i = 0, o = 0, r = 0;\n                    if (e /= 100) {\n                        const s = n < .5 ? n * (1 + e) : n + e - n * e, a = 2 * n - s;\n                        i = _t(a, s, t1 + 1 / 3), o = _t(a, s, t1), r = _t(a, s, t1 - 1 / 3);\n                    } else i = o = r = n;\n                    return {\n                        red: Math.round(255 * i),\n                        green: Math.round(255 * o),\n                        blue: Math.round(255 * r),\n                        alpha: s\n                    };\n                }(s)), s;\n            }\n            const ee = (t1, e)=>{\n                const n = te(t1), s = te(e), i = {\n                    ...n\n                };\n                return (t1)=>(i.red = Jt(n.red, s.red, t1), i.green = Jt(n.green, s.green, t1), i.blue = Jt(n.blue, s.blue, t1), i.alpha = Kt(n.alpha, s.alpha, t1), U.transform(i));\n            }, ne = (t1, e)=>(n)=>e(t1(n)), se = (...t1)=>t1.reduce(ne), ie = (t1, e)=>(n)=>`${n > 0 ? e : t1}`;\n            function oe(t1, e) {\n                return \"number\" == typeof t1 ? (n)=>Kt(t1, e, n) : Z.test(t1) ? ee(t1, e) : t1.startsWith(\"var(\") ? ie(t1, e) : le(t1, e);\n            }\n            const re = (t1, e)=>{\n                const n = [\n                    ...t1\n                ], s = n.length, i = t1.map((t1, n)=>oe(t1, e[n]));\n                return (t1)=>{\n                    for(let e = 0; e < s; e++)n[e] = i[e](t1);\n                    return n;\n                };\n            }, ae = (t1, e)=>{\n                const n = {\n                    ...t1,\n                    ...e\n                }, s = {};\n                for(const i in n)void 0 !== t1[i] && void 0 !== e[i] && (s[i] = oe(t1[i], e[i]));\n                return (t1)=>{\n                    for(const e in s)n[e] = s[e](t1);\n                    return n;\n                };\n            }, le = (t1, e)=>{\n                const n = it.createTransformer(e), s = tt(t1), i = tt(e);\n                return s.numVars === i.numVars && s.numColors === i.numColors && s.numNumbers >= i.numNumbers ? se(re(s.values, i.values), n) : (o(!0, `Complex values '${t1}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), ie(t1, e));\n            }, ue = (t1, e, n)=>{\n                const s = e - t1;\n                return 0 === s ? 1 : (n - t1) / s;\n            }, ce = (t1, e)=>(n)=>Kt(t1, e, n);\n            function he(t1, e, { clamp: s = !0, ease: i, mixer: o } = {}) {\n                const a = t1.length;\n                if (r(a === e.length, \"Both input and output ranges must be the same length\"), 1 === a) return ()=>e[0];\n                t1[0] > t1[a - 1] && (t1 = [\n                    ...t1\n                ].reverse(), e = [\n                    ...e\n                ].reverse());\n                const l = function(t1, e, s) {\n                    const i = [], o = s || (\"number\" == typeof (r = t1[0]) ? ce : \"string\" == typeof r ? Z.test(r) ? ee : le : Array.isArray(r) ? re : \"object\" == typeof r ? ae : ce);\n                    var r;\n                    const a = t1.length - 1;\n                    for(let s = 0; s < a; s++){\n                        let r = o(t1[s], t1[s + 1]);\n                        if (e) {\n                            const t1 = Array.isArray(e) ? e[s] || n : e;\n                            r = se(t1, r);\n                        }\n                        i.push(r);\n                    }\n                    return i;\n                }(e, i, o), u = l.length, c = (e)=>{\n                    let n = 0;\n                    if (u > 1) for(; n < t1.length - 2 && !(e < t1[n + 1]); n++);\n                    const s = ue(t1[n], t1[n + 1], e);\n                    return l[n](s);\n                };\n                return s ? (e)=>c(R(t1[0], t1[a - 1], e)) : c;\n            }\n            function de({ duration: t1 = 300, keyframes: e, times: n, ease: s = \"easeInOut\" }) {\n                const i = ((t1)=>Array.isArray(t1) && \"number\" != typeof t1[0])(s) ? s.map(Zt) : Zt(s), o = {\n                    done: !1,\n                    value: e[0]\n                }, r = he(function(t1, e) {\n                    return t1.map((t1)=>t1 * e);\n                }(n && n.length === e.length ? n : function(t1) {\n                    const e = [\n                        0\n                    ];\n                    return function(t1, e) {\n                        const n = t1[t1.length - 1];\n                        for(let s = 1; s <= e; s++){\n                            const i = ue(0, e, s);\n                            t1.push(Kt(n, 1, i));\n                        }\n                    }(e, t1.length - 1), e;\n                }(e), t1), e, {\n                    ease: Array.isArray(i) ? i : (a = e, l = i, a.map(()=>l || Ut).splice(0, a.length - 1))\n                });\n                var a, l;\n                return {\n                    calculatedDuration: t1,\n                    next: (e)=>(o.value = r(e), o.done = e >= t1, o)\n                };\n            }\n            function me(t1, e, n) {\n                const s = Math.max(e - 5, 0);\n                return p(n - t1(s), e - s);\n            }\n            function pe(t1, e) {\n                return t1 * Math.sqrt(1 - e * e);\n            }\n            const fe = [\n                \"duration\",\n                \"bounce\"\n            ], ge = [\n                \"stiffness\",\n                \"damping\",\n                \"mass\"\n            ];\n            function ye(t1, e) {\n                return e.some((e)=>void 0 !== t1[e]);\n            }\n            function ve({ keyframes: t1, restDelta: e, restSpeed: n, ...s }) {\n                const i = t1[0], r = t1[t1.length - 1], a = {\n                    done: !1,\n                    value: i\n                }, { stiffness: l, damping: u, mass: c, velocity: h, duration: d, isResolvedFromDuration: m } = function(t1) {\n                    let e = {\n                        velocity: 0,\n                        stiffness: 100,\n                        damping: 10,\n                        mass: 1,\n                        isResolvedFromDuration: !1,\n                        ...t1\n                    };\n                    if (!ye(t1, ge) && ye(t1, fe)) {\n                        const n = function({ duration: t1 = 800, bounce: e = .25, velocity: n = 0, mass: s = 1 }) {\n                            let i, r;\n                            o(t1 <= Ct(10), \"Spring duration must be 10 seconds or less\");\n                            let a = 1 - e;\n                            a = R(.05, 1, a), t1 = R(.01, 10, Mt(t1)), a < 1 ? (i = (e)=>{\n                                const s = e * a, i = s * t1;\n                                return .001 - (s - n) / pe(e, a) * Math.exp(-i);\n                            }, r = (e)=>{\n                                const s = e * a * t1, o = s * n + n, r = Math.pow(a, 2) * Math.pow(e, 2) * t1, l = Math.exp(-s), u = pe(Math.pow(e, 2), a);\n                                return (.001 - i(e) > 0 ? -1 : 1) * ((o - r) * l) / u;\n                            }) : (i = (e)=>Math.exp(-e * t1) * ((e - n) * t1 + 1) - .001, r = (e)=>Math.exp(-e * t1) * (t1 * t1 * (n - e)));\n                            const l = function(t1, e, n) {\n                                let s = n;\n                                for(let n = 1; n < 12; n++)s -= t1(s) / e(s);\n                                return s;\n                            }(i, r, 5 / t1);\n                            if (t1 = Ct(t1), isNaN(l)) return {\n                                stiffness: 100,\n                                damping: 10,\n                                duration: t1\n                            };\n                            {\n                                const e = Math.pow(l, 2) * s;\n                                return {\n                                    stiffness: e,\n                                    damping: 2 * a * Math.sqrt(s * e),\n                                    duration: t1\n                                };\n                            }\n                        }(t1);\n                        e = {\n                            ...e,\n                            ...n,\n                            velocity: 0,\n                            mass: 1\n                        }, e.isResolvedFromDuration = !0;\n                    }\n                    return e;\n                }(s), p = h ? -Mt(h) : 0, f = u / (2 * Math.sqrt(l * c)), g = r - i, y = Mt(Math.sqrt(l / c)), v = Math.abs(g) < 5;\n                let x;\n                if (n || (n = v ? .01 : 2), e || (e = v ? .005 : .5), f < 1) {\n                    const t1 = pe(y, f);\n                    x = (e)=>{\n                        const n = Math.exp(-f * y * e);\n                        return r - n * ((p + f * y * g) / t1 * Math.sin(t1 * e) + g * Math.cos(t1 * e));\n                    };\n                } else if (1 === f) x = (t1)=>r - Math.exp(-y * t1) * (g + (p + y * g) * t1);\n                else {\n                    const t1 = y * Math.sqrt(f * f - 1);\n                    x = (e)=>{\n                        const n = Math.exp(-f * y * e), s = Math.min(t1 * e, 300);\n                        return r - n * ((p + f * y * g) * Math.sinh(s) + t1 * g * Math.cosh(s)) / t1;\n                    };\n                }\n                return {\n                    calculatedDuration: m && d || null,\n                    next: (t1)=>{\n                        const s = x(t1);\n                        if (m) a.done = t1 >= d;\n                        else {\n                            let i = p;\n                            0 !== t1 && (i = f < 1 ? me(x, t1, s) : 0);\n                            const o = Math.abs(i) <= n, l = Math.abs(r - s) <= e;\n                            a.done = o && l;\n                        }\n                        return a.value = a.done ? r : s, a;\n                    }\n                };\n            }\n            function xe({ keyframes: t1, velocity: e = 0, power: n = .8, timeConstant: s = 325, bounceDamping: i = 10, bounceStiffness: o = 500, modifyTarget: r, min: a, max: l, restDelta: u = .5, restSpeed: c }) {\n                const h = t1[0], d = {\n                    done: !1,\n                    value: h\n                }, m = (t1)=>void 0 === a ? l : void 0 === l || Math.abs(a - t1) < Math.abs(l - t1) ? a : l;\n                let p = n * e;\n                const f = h + p, g = void 0 === r ? f : r(f);\n                g !== f && (p = g - h);\n                const y = (t1)=>-p * Math.exp(-t1 / s), v = (t1)=>g + y(t1), x = (t1)=>{\n                    const e = y(t1), n = v(t1);\n                    d.done = Math.abs(e) <= u, d.value = d.done ? g : n;\n                };\n                let P, b;\n                const T = (t1)=>{\n                    var e;\n                    e = d.value, (void 0 !== a && e < a || void 0 !== l && e > l) && (P = t1, b = ve({\n                        keyframes: [\n                            d.value,\n                            m(d.value)\n                        ],\n                        velocity: me(v, t1, d.value),\n                        damping: i,\n                        stiffness: o,\n                        restDelta: u,\n                        restSpeed: c\n                    }));\n                };\n                return T(0), {\n                    calculatedDuration: null,\n                    next: (t1)=>{\n                        let e = !1;\n                        return b || void 0 !== P || (e = !0, x(t1), T(t1)), void 0 !== P && t1 > P ? b.next(t1 - P) : (!e && x(t1), d);\n                    }\n                };\n            }\n            const Pe = (t1)=>{\n                const e = ({ timestamp: e })=>t1(e);\n                return {\n                    start: ()=>y.update(e, !0),\n                    stop: ()=>v(e),\n                    now: ()=>x.isProcessing ? x.timestamp : performance.now()\n                };\n            };\n            function be(t1) {\n                let e = 0, n = t1.next(e);\n                for(; !n.done && e < 2e4;)e += 50, n = t1.next(e);\n                return e >= 2e4 ? 1 / 0 : e;\n            }\n            const Te = {\n                decay: xe,\n                inertia: xe,\n                tween: de,\n                keyframes: de,\n                spring: ve\n            };\n            function Se({ autoplay: t1 = !0, delay: e = 0, driver: n = Pe, keyframes: s, type: i = \"keyframes\", repeat: o = 0, repeatDelay: r = 0, repeatType: a = \"loop\", onPlay: l, onStop: u, onComplete: c, onUpdate: h, ...d }) {\n                let m, p, f = 1, g = !1;\n                const y = ()=>{\n                    p = new Promise((t1)=>{\n                        m = t1;\n                    });\n                };\n                let v;\n                y();\n                const x = Te[i] || de;\n                let P;\n                x !== de && \"number\" != typeof s[0] && (P = he([\n                    0,\n                    100\n                ], s, {\n                    clamp: !1\n                }), s = [\n                    0,\n                    100\n                ]);\n                const b = x({\n                    ...d,\n                    keyframes: s\n                });\n                let T;\n                \"mirror\" === a && (T = x({\n                    ...d,\n                    keyframes: [\n                        ...s\n                    ].reverse(),\n                    velocity: -(d.velocity || 0)\n                }));\n                let S = \"idle\", w = null, E = null, A = null;\n                null === b.calculatedDuration && o && (b.calculatedDuration = be(b));\n                const { calculatedDuration: V } = b;\n                let C = 1 / 0, M = 1 / 0;\n                null !== V && (C = V + r, M = C * (o + 1) - r);\n                let D = 0;\n                const k = (t1)=>{\n                    if (null === E) return;\n                    f > 0 && (E = Math.min(E, t1)), f < 0 && (E = Math.min(t1 - M / f, E)), D = null !== w ? w : Math.round(t1 - E) * f;\n                    const n = D - e * (f >= 0 ? 1 : -1), i = f >= 0 ? n < 0 : n > M;\n                    D = Math.max(n, 0), \"finished\" === S && null === w && (D = M);\n                    let l = D, u = b;\n                    if (o) {\n                        const t1 = D / C;\n                        let e = Math.floor(t1), n = t1 % 1;\n                        !n && t1 >= 1 && (n = 1), 1 === n && e--, e = Math.min(e, o + 1);\n                        const s = Boolean(e % 2);\n                        s && (\"reverse\" === a ? (n = 1 - n, r && (n -= r / C)) : \"mirror\" === a && (u = T));\n                        let i = R(0, 1, n);\n                        D > M && (i = \"reverse\" === a && s ? 1 : 0), l = i * C;\n                    }\n                    const c = i ? {\n                        done: !1,\n                        value: s[0]\n                    } : u.next(l);\n                    P && (c.value = P(c.value));\n                    let { done: d } = c;\n                    i || null === V || (d = f >= 0 ? D >= M : D <= 0);\n                    const m = null === w && (\"finished\" === S || \"running\" === S && d);\n                    return h && h(c.value), m && B(), c;\n                }, L = ()=>{\n                    v && v.stop(), v = void 0;\n                }, j = ()=>{\n                    S = \"idle\", L(), m(), y(), E = A = null;\n                }, B = ()=>{\n                    S = \"finished\", c && c(), L(), m();\n                }, F = ()=>{\n                    if (g) return;\n                    v || (v = n(k));\n                    const t1 = v.now();\n                    l && l(), null !== w ? E = t1 - w : E && \"finished\" !== S || (E = t1), \"finished\" === S && y(), A = E, w = null, S = \"running\", v.start();\n                };\n                t1 && F();\n                const O = {\n                    then: (t1, e)=>p.then(t1, e),\n                    get time () {\n                        return Mt(D);\n                    },\n                    set time (t){\n                        t = Ct(t), D = t, null === w && v && 0 !== f ? E = v.now() - t / f : w = t;\n                    },\n                    get duration () {\n                        const t1 = null === b.calculatedDuration ? be(b) : b.calculatedDuration;\n                        return Mt(t1);\n                    },\n                    get speed () {\n                        return f;\n                    },\n                    set speed (t){\n                        t !== f && v && (f = t, O.time = Mt(D));\n                    },\n                    get state () {\n                        return S;\n                    },\n                    play: F,\n                    pause: ()=>{\n                        S = \"paused\", w = D;\n                    },\n                    stop: ()=>{\n                        g = !0, \"idle\" !== S && (S = \"idle\", u && u(), j());\n                    },\n                    cancel: ()=>{\n                        null !== A && k(A), j();\n                    },\n                    complete: ()=>{\n                        S = \"finished\";\n                    },\n                    sample: (t1)=>(E = 0, k(t1))\n                };\n                return O;\n            }\n            const we = function(t1) {\n                let e;\n                return ()=>(void 0 === e && (e = Object.hasOwnProperty.call(Element.prototype, \"animate\")), e);\n            }(), Ee = new Set([\n                \"opacity\",\n                \"clipPath\",\n                \"filter\",\n                \"transform\",\n                \"backgroundColor\"\n            ]);\n            const Ae = {\n                type: \"spring\",\n                stiffness: 500,\n                damping: 25,\n                restSpeed: 10\n            }, Ve = {\n                type: \"keyframes\",\n                duration: .8\n            }, Ce = {\n                type: \"keyframes\",\n                ease: [\n                    .25,\n                    .1,\n                    .35,\n                    1\n                ],\n                duration: .3\n            }, Me = (t1, { keyframes: e })=>e.length > 2 ? Ve : Et.has(t1) ? t1.startsWith(\"scale\") ? {\n                    type: \"spring\",\n                    stiffness: 550,\n                    damping: 0 === e[1] ? 2 * Math.sqrt(550) : 30,\n                    restSpeed: 10\n                } : Ae : Ce, De = (t1, e)=>!(\"zIndex\" === t1 || \"number\" != typeof e && !Array.isArray(e) && (\"string\" != typeof e || !it.test(e) && \"0\" !== e || e.startsWith(\"url(\")));\n            function ke(t1) {\n                return \"number\" == typeof t1 ? 0 === t1 : null !== t1 ? \"none\" === t1 || \"0\" === t1 || u(t1) : void 0;\n            }\n            function Re(t1, e) {\n                return t1[e] || t1.default || t1;\n            }\n            const Le = (t1, e, s, i = {})=>(r)=>{\n                    const a = Re(i, t1) || {}, l = a.delay || i.delay || 0;\n                    let { elapsed: u = 0 } = i;\n                    u -= Ct(l);\n                    const c = function(t1, e, n, s) {\n                        const i = De(e, n);\n                        let o;\n                        o = Array.isArray(n) ? [\n                            ...n\n                        ] : [\n                            null,\n                            n\n                        ];\n                        const r = void 0 !== s.from ? s.from : t1.get();\n                        let a;\n                        const l = [];\n                        for(let t1 = 0; t1 < o.length; t1++)null === o[t1] && (o[t1] = 0 === t1 ? r : o[t1 - 1]), ke(o[t1]) && l.push(t1), \"string\" == typeof o[t1] && \"none\" !== o[t1] && \"0\" !== o[t1] && (a = o[t1]);\n                        if (i && l.length && a) for(let t1 = 0; t1 < l.length; t1++)o[l[t1]] = mt(e, a);\n                        return o;\n                    }(e, t1, s, a), h = c[0], d = c[c.length - 1], m = De(t1, h), p = De(t1, d);\n                    o(m === p, `You are trying to animate ${t1} from \"${h}\" to \"${d}\". ${h} is not an animatable value - to enable this animation set ${h} to a value animatable to ${d} via the \\`style\\` property.`);\n                    let f = {\n                        keyframes: c,\n                        velocity: e.getVelocity(),\n                        ease: \"easeOut\",\n                        ...a,\n                        delay: -u,\n                        onUpdate: (t1)=>{\n                            e.set(t1), a.onUpdate && a.onUpdate(t1);\n                        },\n                        onComplete: ()=>{\n                            r(), a.onComplete && a.onComplete();\n                        }\n                    };\n                    if (function({ when: t1, delay: e, delayChildren: n, staggerChildren: s, staggerDirection: i, repeat: o, repeatType: r, repeatDelay: a, from: l, elapsed: u, ...c }) {\n                        return !!Object.keys(c).length;\n                    }(a) || (f = {\n                        ...f,\n                        ...Me(t1, f)\n                    }), f.duration && (f.duration = Ct(f.duration)), f.repeatDelay && (f.repeatDelay = Ct(f.repeatDelay)), !m || !p || !1 === a.type) return function({ keyframes: t1, delay: e, onUpdate: s, onComplete: i }) {\n                        const o = ()=>(s && s(t1[t1.length - 1]), i && i(), {\n                                time: 0,\n                                speed: 1,\n                                duration: 0,\n                                play: n,\n                                pause: n,\n                                stop: n,\n                                then: (t1)=>(t1(), Promise.resolve()),\n                                cancel: n,\n                                complete: n\n                            });\n                        return e ? Se({\n                            keyframes: [\n                                0,\n                                1\n                            ],\n                            duration: 0,\n                            delay: e,\n                            onComplete: o\n                        }) : o();\n                    }(f);\n                    if (e.owner && e.owner.current instanceof HTMLElement && !e.owner.getProps().onUpdate) {\n                        const s = function(t1, e, { onUpdate: s, onComplete: i, ...o }) {\n                            if (!we() || !Ee.has(e) || o.repeatDelay || \"mirror\" === o.repeatType || 0 === o.damping || \"inertia\" === o.type) return !1;\n                            let r, a, l = !1;\n                            const u = ()=>{\n                                a = new Promise((t1)=>{\n                                    r = t1;\n                                });\n                            };\n                            u();\n                            let { keyframes: c, duration: h = 300, ease: d, times: m } = o;\n                            if (((t1, e)=>\"spring\" === e.type || \"backgroundColor\" === t1 || !kt(e.ease))(e, o)) {\n                                const t1 = Se({\n                                    ...o,\n                                    repeat: 0,\n                                    delay: 0\n                                });\n                                let e = {\n                                    done: !1,\n                                    value: c[0]\n                                };\n                                const n = [];\n                                let s = 0;\n                                for(; !e.done && s < 2e4;)e = t1.sample(s), n.push(e.value), s += 10;\n                                m = void 0, c = n, h = s - 10, d = \"linear\";\n                            }\n                            const p = function(t1, e, n, { delay: s = 0, duration: i, repeat: o = 0, repeatType: r = \"loop\", ease: a, times: l } = {}) {\n                                const u = {\n                                    [e]: n\n                                };\n                                l && (u.offset = l);\n                                const c = jt(a);\n                                return Array.isArray(c) && (u.easing = c), t1.animate(u, {\n                                    delay: s,\n                                    duration: i,\n                                    easing: Array.isArray(c) ? \"linear\" : c,\n                                    fill: \"both\",\n                                    iterations: o + 1,\n                                    direction: \"reverse\" === r ? \"alternate\" : \"normal\"\n                                });\n                            }(t1.owner.current, e, c, {\n                                ...o,\n                                duration: h,\n                                ease: d,\n                                times: m\n                            });\n                            o.syncStart && (p.startTime = x.isProcessing ? x.timestamp : document.timeline ? document.timeline.currentTime : performance.now());\n                            const f = ()=>p.cancel(), g = ()=>{\n                                y.update(f), r(), u();\n                            };\n                            return p.onfinish = ()=>{\n                                t1.set(function(t1, { repeat: e, repeatType: n = \"loop\" }) {\n                                    return t1[e && \"loop\" !== n && e % 2 == 1 ? 0 : t1.length - 1];\n                                }(c, o)), i && i(), g();\n                            }, {\n                                then: (t1, e)=>a.then(t1, e),\n                                attachTimeline: (t1)=>(p.timeline = t1, p.onfinish = null, n),\n                                get time () {\n                                    return Mt(p.currentTime || 0);\n                                },\n                                set time (t){\n                                    p.currentTime = Ct(t);\n                                },\n                                get speed () {\n                                    return p.playbackRate;\n                                },\n                                set speed (t){\n                                    p.playbackRate = t;\n                                },\n                                get duration () {\n                                    return Mt(h);\n                                },\n                                play: ()=>{\n                                    l || (p.play(), v(f));\n                                },\n                                pause: ()=>p.pause(),\n                                stop: ()=>{\n                                    if (l = !0, \"idle\" === p.playState) return;\n                                    const { currentTime: e } = p;\n                                    if (e) {\n                                        const n = Se({\n                                            ...o,\n                                            autoplay: !1\n                                        });\n                                        t1.setWithVelocity(n.sample(e - 10).value, n.sample(e).value, 10);\n                                    }\n                                    g();\n                                },\n                                complete: ()=>p.finish(),\n                                cancel: g\n                            };\n                        }(e, t1, f);\n                        if (s) return s;\n                    }\n                    return Se(f);\n                }, je = (t1)=>Boolean(t1 && t1.getVelocity);\n            function Be(t1) {\n                return Boolean(je(t1) && t1.add);\n            }\n            function Fe({ protectedKeys: t1, needsAnimating: e }, n) {\n                const s = t1.hasOwnProperty(n) && !0 !== e[n];\n                return e[n] = !1, s;\n            }\n            function Oe(t1, e, { delay: n = 0, transitionOverride: s, type: i } = {}) {\n                let { transition: o = t1.getDefaultTransition(), transitionEnd: r, ...a } = t1.makeTargetAnimatable(e);\n                const l = t1.getValue(\"willChange\");\n                s && (o = s);\n                const u = [], c = i && t1.animationState && t1.animationState.getState()[i];\n                for(const e in a){\n                    const s = t1.getValue(e), i = a[e];\n                    if (!s || void 0 === i || c && Fe(c, e)) continue;\n                    const r = {\n                        delay: n,\n                        elapsed: 0,\n                        ...o\n                    };\n                    if (window.HandoffAppearAnimations && !s.hasAnimated) {\n                        const n = t1.getProps()[Vt];\n                        n && (r.elapsed = window.HandoffAppearAnimations(n, e, s, y), r.syncStart = !0);\n                    }\n                    s.start(Le(e, s, i, t1.shouldReduceMotion && Et.has(e) ? {\n                        type: !1\n                    } : r));\n                    const h = s.animation;\n                    Be(l) && (l.add(e), h.then(()=>l.remove(e))), u.push(h);\n                }\n                return r && Promise.all(u).then(()=>{\n                    r && bt(t1, r);\n                }), u;\n            }\n            function Ie(t1, e, n = {}) {\n                const s = xt(t1, e, n.custom);\n                let { transition: i = t1.getDefaultTransition() || {} } = s || {};\n                n.transitionOverride && (i = n.transitionOverride);\n                const o = s ? ()=>Promise.all(Oe(t1, s, n)) : ()=>Promise.resolve(), r = t1.variantChildren && t1.variantChildren.size ? (s = 0)=>{\n                    const { delayChildren: o = 0, staggerChildren: r, staggerDirection: a } = i;\n                    return function(t1, e, n = 0, s = 0, i = 1, o) {\n                        const r = [], a = (t1.variantChildren.size - 1) * s, l = 1 === i ? (t1 = 0)=>t1 * s : (t1 = 0)=>a - t1 * s;\n                        return Array.from(t1.variantChildren).sort(Ue).forEach((t1, s)=>{\n                            t1.notify(\"AnimationStart\", e), r.push(Ie(t1, e, {\n                                ...o,\n                                delay: n + l(s)\n                            }).then(()=>t1.notify(\"AnimationComplete\", e)));\n                        }), Promise.all(r);\n                    }(t1, e, o + s, r, a, n);\n                } : ()=>Promise.resolve(), { when: a } = i;\n                if (a) {\n                    const [t1, e] = \"beforeChildren\" === a ? [\n                        o,\n                        r\n                    ] : [\n                        r,\n                        o\n                    ];\n                    return t1().then(()=>e());\n                }\n                return Promise.all([\n                    o(),\n                    r(n.delay)\n                ]);\n            }\n            function Ue(t1, e) {\n                return t1.sortNodePosition(e);\n            }\n            function Ne(t1, e, n = {}) {\n                let s;\n                if (t1.notify(\"AnimationStart\", e), Array.isArray(e)) {\n                    const i = e.map((e)=>Ie(t1, e, n));\n                    s = Promise.all(i);\n                } else if (\"string\" == typeof e) s = Ie(t1, e, n);\n                else {\n                    const i = \"function\" == typeof e ? xt(t1, e, n.custom) : e;\n                    s = Promise.all(Oe(t1, i, n));\n                }\n                return s.then(()=>t1.notify(\"AnimationComplete\", e));\n            }\n            function $e() {\n                let t1 = !1;\n                const e = new Set, n = {\n                    subscribe: (t1)=>(e.add(t1), ()=>{\n                            e.delete(t1);\n                        }),\n                    start (n, s) {\n                        r(t1, \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n                        const i = [];\n                        return e.forEach((t1)=>{\n                            i.push(Ne(t1, n, {\n                                transitionOverride: s\n                            }));\n                        }), Promise.all(i);\n                    },\n                    set: (n)=>(r(t1, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\"), e.forEach((t1)=>{\n                            !function(t1, e) {\n                                Array.isArray(e) ? Tt(t1, e) : \"string\" == typeof e ? Tt(t1, [\n                                    e\n                                ]) : bt(t1, e);\n                            }(t1, n);\n                        })),\n                    stop () {\n                        e.forEach((t1)=>{\n                            !function(t1) {\n                                t1.values.forEach((t1)=>t1.stop());\n                            }(t1);\n                        });\n                    },\n                    mount: ()=>(t1 = !0, ()=>{\n                            t1 = !1, n.stop();\n                        })\n                };\n                return n;\n            }\n            function We(e) {\n                const n = (0, t1.useRef)(null);\n                return null === n.current && (n.current = e()), n.current;\n            }\n            const He = \"undefined\" != typeof document, ze = He ? t1.useLayoutEffect : t1.useEffect, Ye = (0, t1.createContext)({\n                transformPagePoint: (t1)=>t1,\n                isStatic: !1,\n                reducedMotion: \"never\"\n            }), Xe = (0, t1.createContext)({}), Ge = (0, t1.createContext)(null), qe = (0, t1.createContext)({\n                strict: !1\n            });\n            function Ze(t1) {\n                return \"object\" == typeof t1 && Object.prototype.hasOwnProperty.call(t1, \"current\");\n            }\n            function Ke(t1) {\n                return \"string\" == typeof t1 || Array.isArray(t1);\n            }\n            function _e(t1) {\n                return \"object\" == typeof t1 && \"function\" == typeof t1.start;\n            }\n            const Je = [\n                \"animate\",\n                \"whileInView\",\n                \"whileFocus\",\n                \"whileHover\",\n                \"whileTap\",\n                \"whileDrag\",\n                \"exit\"\n            ], Qe = [\n                \"initial\",\n                ...Je\n            ];\n            function tn(t1) {\n                return _e(t1.animate) || Qe.some((e)=>Ke(t1[e]));\n            }\n            function en(t1) {\n                return Boolean(tn(t1) || t1.variants);\n            }\n            function nn(t1) {\n                return Array.isArray(t1) ? t1.join(\" \") : t1;\n            }\n            const sn = {\n                animation: [\n                    \"animate\",\n                    \"variants\",\n                    \"whileHover\",\n                    \"whileTap\",\n                    \"exit\",\n                    \"whileInView\",\n                    \"whileFocus\",\n                    \"whileDrag\"\n                ],\n                exit: [\n                    \"exit\"\n                ],\n                drag: [\n                    \"drag\",\n                    \"dragControls\"\n                ],\n                focus: [\n                    \"whileFocus\"\n                ],\n                hover: [\n                    \"whileHover\",\n                    \"onHoverStart\",\n                    \"onHoverEnd\"\n                ],\n                tap: [\n                    \"whileTap\",\n                    \"onTap\",\n                    \"onTapStart\",\n                    \"onTapCancel\"\n                ],\n                pan: [\n                    \"onPan\",\n                    \"onPanStart\",\n                    \"onPanSessionStart\",\n                    \"onPanEnd\"\n                ],\n                inView: [\n                    \"whileInView\",\n                    \"onViewportEnter\",\n                    \"onViewportLeave\"\n                ],\n                layout: [\n                    \"layout\",\n                    \"layoutId\"\n                ]\n            }, on = {};\n            for(const t1 in sn)on[t1] = {\n                isEnabled: (e)=>sn[t1].some((t1)=>!!e[t1])\n            };\n            const rn = (0, t1.createContext)({}), an = (0, t1.createContext)({}), ln = Symbol.for(\"motionComponentSymbol\");\n            function un({ preloadedFeatures: e, createVisualElement: n, useRender: s, useVisualState: i, Component: o }) {\n                e && function(t1) {\n                    for(const e in t1)on[e] = {\n                        ...on[e],\n                        ...t1[e]\n                    };\n                }(e);\n                const r = (0, t1.forwardRef)(function(r, a) {\n                    let l;\n                    const u = {\n                        ...(0, t1.useContext)(Ye),\n                        ...r,\n                        layoutId: cn(r)\n                    }, { isStatic: c } = u, h = function(e) {\n                        const { initial: n, animate: s } = function(t1, e) {\n                            if (tn(t1)) {\n                                const { initial: e, animate: n } = t1;\n                                return {\n                                    initial: !1 === e || Ke(e) ? e : void 0,\n                                    animate: Ke(n) ? n : void 0\n                                };\n                            }\n                            return !1 !== t1.inherit ? e : {};\n                        }(e, (0, t1.useContext)(Xe));\n                        return (0, t1.useMemo)(()=>({\n                                initial: n,\n                                animate: s\n                            }), [\n                            nn(n),\n                            nn(s)\n                        ]);\n                    }(r), d = i(r, c);\n                    if (!c && He) {\n                        h.visualElement = function(e, n, s, i) {\n                            const { visualElement: o } = (0, t1.useContext)(Xe), r = (0, t1.useContext)(qe), a = (0, t1.useContext)(Ge), l = (0, t1.useContext)(Ye).reducedMotion, u = (0, t1.useRef)();\n                            i = i || r.renderer, !u.current && i && (u.current = i(e, {\n                                visualState: n,\n                                parent: o,\n                                props: s,\n                                presenceContext: a,\n                                blockInitialAnimation: !!a && !1 === a.initial,\n                                reducedMotionConfig: l\n                            }));\n                            const c = u.current;\n                            (0, t1.useInsertionEffect)(()=>{\n                                c && c.update(s, a);\n                            });\n                            const h = (0, t1.useRef)(Boolean(window.HandoffAppearAnimations));\n                            return ze(()=>{\n                                c && (c.render(), h.current && c.animationState && c.animationState.animateChanges());\n                            }), (0, t1.useEffect)(()=>{\n                                c && (c.updateFeatures(), !h.current && c.animationState && c.animationState.animateChanges(), window.HandoffAppearAnimations = void 0, h.current = !1);\n                            }), c;\n                        }(o, d, u, n);\n                        const s = (0, t1.useContext)(an), i = (0, t1.useContext)(qe).strict;\n                        h.visualElement && (l = h.visualElement.loadFeatures(u, i, e, s));\n                    }\n                    return t1.createElement(Xe.Provider, {\n                        value: h\n                    }, l && h.visualElement ? t1.createElement(l, {\n                        visualElement: h.visualElement,\n                        ...u\n                    }) : null, s(o, r, function(e, n, s) {\n                        return (0, t1.useCallback)((t1)=>{\n                            t1 && e.mount && e.mount(t1), n && (t1 ? n.mount(t1) : n.unmount()), s && (\"function\" == typeof s ? s(t1) : Ze(s) && (s.current = t1));\n                        }, [\n                            n\n                        ]);\n                    }(d, h.visualElement, a), d, c, h.visualElement));\n                });\n                return r[ln] = o, r;\n            }\n            function cn({ layoutId: e }) {\n                const n = (0, t1.useContext)(rn).id;\n                return n && void 0 !== e ? n + \"-\" + e : e;\n            }\n            function hn(t1) {\n                function e(e, n = {}) {\n                    return un(t1(e, n));\n                }\n                if (\"undefined\" == typeof Proxy) return e;\n                const n = new Map;\n                return new Proxy(e, {\n                    get: (t1, s)=>(n.has(s) || n.set(s, e(s)), n.get(s))\n                });\n            }\n            const dn = [\n                \"animate\",\n                \"circle\",\n                \"defs\",\n                \"desc\",\n                \"ellipse\",\n                \"g\",\n                \"image\",\n                \"line\",\n                \"filter\",\n                \"marker\",\n                \"mask\",\n                \"metadata\",\n                \"path\",\n                \"pattern\",\n                \"polygon\",\n                \"polyline\",\n                \"rect\",\n                \"stop\",\n                \"switch\",\n                \"symbol\",\n                \"svg\",\n                \"text\",\n                \"tspan\",\n                \"use\",\n                \"view\"\n            ];\n            function mn(t1) {\n                return \"string\" == typeof t1 && !t1.includes(\"-\") && !!(dn.indexOf(t1) > -1 || /[A-Z]/.test(t1));\n            }\n            const pn = {};\n            function fn(t1, { layout: e, layoutId: n }) {\n                return Et.has(t1) || t1.startsWith(\"origin\") || (e || void 0 !== n) && (!!pn[t1] || \"opacity\" === t1);\n            }\n            const gn = {\n                x: \"translateX\",\n                y: \"translateY\",\n                z: \"translateZ\",\n                transformPerspective: \"perspective\"\n            }, yn = wt.length, vn = (t1, e)=>e && \"number\" == typeof t1 ? e.transform(t1) : t1;\n            function xn(t1, e, n, s) {\n                const { style: i, vars: o, transform: r, transformOrigin: a } = t1;\n                let l = !1, u = !1, c = !0;\n                for(const t1 in e){\n                    const n = e[t1];\n                    if (E(t1)) {\n                        o[t1] = n;\n                        continue;\n                    }\n                    const s = ct[t1], h = vn(n, s);\n                    if (Et.has(t1)) {\n                        if (l = !0, r[t1] = h, !c) continue;\n                        n !== (s.default || 0) && (c = !1);\n                    } else t1.startsWith(\"origin\") ? (u = !0, a[t1] = h) : i[t1] = h;\n                }\n                if (e.transform || (l || s ? i.transform = function(t1, { enableHardwareAcceleration: e = !0, allowTransformNone: n = !0 }, s, i) {\n                    let o = \"\";\n                    for(let e = 0; e < yn; e++){\n                        const n = wt[e];\n                        void 0 !== t1[n] && (o += `${gn[n] || n}(${t1[n]}) `);\n                    }\n                    return e && !t1.z && (o += \"translateZ(0)\"), o = o.trim(), i ? o = i(t1, s ? \"\" : o) : n && s && (o = \"none\"), o;\n                }(t1.transform, n, c, s) : i.transform && (i.transform = \"none\")), u) {\n                    const { originX: t1 = \"50%\", originY: e = \"50%\", originZ: n = 0 } = a;\n                    i.transformOrigin = `${t1} ${e} ${n}`;\n                }\n            }\n            function Pn(t1, e, n) {\n                for(const s in e)je(e[s]) || fn(s, n) || (t1[s] = e[s]);\n            }\n            function bn(e, n, s) {\n                const i = {}, o = function(e, n, s) {\n                    const i = {};\n                    return Pn(i, e.style || {}, e), Object.assign(i, function({ transformTemplate: e }, n, s) {\n                        return (0, t1.useMemo)(()=>{\n                            const t1 = {\n                                style: {},\n                                transform: {},\n                                transformOrigin: {},\n                                vars: {}\n                            };\n                            return xn(t1, n, {\n                                enableHardwareAcceleration: !s\n                            }, e), Object.assign({}, t1.vars, t1.style);\n                        }, [\n                            n\n                        ]);\n                    }(e, n, s)), e.transformValues ? e.transformValues(i) : i;\n                }(e, n, s);\n                return e.drag && !1 !== e.dragListener && (i.draggable = !1, o.userSelect = o.WebkitUserSelect = o.WebkitTouchCallout = \"none\", o.touchAction = !0 === e.drag ? \"none\" : \"pan-\" + (\"x\" === e.drag ? \"y\" : \"x\")), void 0 === e.tabIndex && (e.onTap || e.onTapStart || e.whileTap) && (i.tabIndex = 0), i.style = o, i;\n            }\n            const Tn = new Set([\n                \"animate\",\n                \"exit\",\n                \"variants\",\n                \"initial\",\n                \"style\",\n                \"values\",\n                \"variants\",\n                \"transition\",\n                \"transformTemplate\",\n                \"transformValues\",\n                \"custom\",\n                \"inherit\",\n                \"onLayoutAnimationStart\",\n                \"onLayoutAnimationComplete\",\n                \"onLayoutMeasure\",\n                \"onBeforeLayoutMeasure\",\n                \"onAnimationStart\",\n                \"onAnimationComplete\",\n                \"onUpdate\",\n                \"onDragStart\",\n                \"onDrag\",\n                \"onDragEnd\",\n                \"onMeasureDragConstraints\",\n                \"onDirectionLock\",\n                \"onDragTransitionEnd\",\n                \"_dragX\",\n                \"_dragY\",\n                \"onHoverStart\",\n                \"onHoverEnd\",\n                \"onViewportEnter\",\n                \"onViewportLeave\",\n                \"ignoreStrict\",\n                \"viewport\"\n            ]);\n            function Sn(t1) {\n                return t1.startsWith(\"while\") || t1.startsWith(\"drag\") && \"draggable\" !== t1 || t1.startsWith(\"layout\") || t1.startsWith(\"onTap\") || t1.startsWith(\"onPan\") || Tn.has(t1);\n            }\n            let wn = (t1)=>!Sn(t1);\n            try {\n                (En = (__webpack_require__(/*! @emotion/is-prop-valid */ \"(ssr)/./node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js\")[\"default\"])) && (wn = (t1)=>t1.startsWith(\"on\") ? !Sn(t1) : En(t1));\n            } catch (t1) {}\n            var En;\n            function An(t1, e, n) {\n                return \"string\" == typeof t1 ? t1 : z.transform(e + n * t1);\n            }\n            const Vn = {\n                offset: \"stroke-dashoffset\",\n                array: \"stroke-dasharray\"\n            }, Cn = {\n                offset: \"strokeDashoffset\",\n                array: \"strokeDasharray\"\n            };\n            function Mn(t1, { attrX: e, attrY: n, attrScale: s, originX: i, originY: o, pathLength: r, pathSpacing: a = 1, pathOffset: l = 0, ...u }, c, h, d) {\n                if (xn(t1, u, c, d), h) return void (t1.style.viewBox && (t1.attrs.viewBox = t1.style.viewBox));\n                t1.attrs = t1.style, t1.style = {};\n                const { attrs: m, style: p, dimensions: f } = t1;\n                m.transform && (f && (p.transform = m.transform), delete m.transform), f && (void 0 !== i || void 0 !== o || p.transform) && (p.transformOrigin = function(t1, e, n) {\n                    return `${An(e, t1.x, t1.width)} ${An(n, t1.y, t1.height)}`;\n                }(f, void 0 !== i ? i : .5, void 0 !== o ? o : .5)), void 0 !== e && (m.x = e), void 0 !== n && (m.y = n), void 0 !== s && (m.scale = s), void 0 !== r && function(t1, e, n = 1, s = 0, i = !0) {\n                    t1.pathLength = 1;\n                    const o = i ? Vn : Cn;\n                    t1[o.offset] = z.transform(-s);\n                    const r = z.transform(e), a = z.transform(n);\n                    t1[o.array] = `${r} ${a}`;\n                }(m, r, a, l, !1);\n            }\n            const Dn = (t1)=>\"string\" == typeof t1 && \"svg\" === t1.toLowerCase();\n            function kn(e, n, s, i) {\n                const o = (0, t1.useMemo)(()=>{\n                    const t1 = {\n                        style: {},\n                        transform: {},\n                        transformOrigin: {},\n                        vars: {},\n                        attrs: {}\n                    };\n                    return Mn(t1, n, {\n                        enableHardwareAcceleration: !1\n                    }, Dn(i), e.transformTemplate), {\n                        ...t1.attrs,\n                        style: {\n                            ...t1.style\n                        }\n                    };\n                }, [\n                    n\n                ]);\n                if (e.style) {\n                    const t1 = {};\n                    Pn(t1, e.style, e), o.style = {\n                        ...t1,\n                        ...o.style\n                    };\n                }\n                return o;\n            }\n            function Rn(e = !1) {\n                return (n, s, i, { latestValues: o }, r)=>{\n                    const a = (mn(n) ? kn : bn)(s, o, r, n), l = {\n                        ...function(t1, e, n) {\n                            const s = {};\n                            for(const i in t1)\"values\" === i && \"object\" == typeof t1.values || (wn(i) || !0 === n && Sn(i) || !e && !Sn(i) || t1.draggable && i.startsWith(\"onDrag\")) && (s[i] = t1[i]);\n                            return s;\n                        }(s, \"string\" == typeof n, e),\n                        ...a,\n                        ref: i\n                    }, { children: u } = s, c = (0, t1.useMemo)(()=>je(u) ? u.get() : u, [\n                        u\n                    ]);\n                    return (0, t1.createElement)(n, {\n                        ...l,\n                        children: c\n                    });\n                };\n            }\n            function Ln(t1, { style: e, vars: n }, s, i) {\n                Object.assign(t1.style, e, i && i.getProjectionStyles(s));\n                for(const e in n)t1.style.setProperty(e, n[e]);\n            }\n            const jn = new Set([\n                \"baseFrequency\",\n                \"diffuseConstant\",\n                \"kernelMatrix\",\n                \"kernelUnitLength\",\n                \"keySplines\",\n                \"keyTimes\",\n                \"limitingConeAngle\",\n                \"markerHeight\",\n                \"markerWidth\",\n                \"numOctaves\",\n                \"targetX\",\n                \"targetY\",\n                \"surfaceScale\",\n                \"specularConstant\",\n                \"specularExponent\",\n                \"stdDeviation\",\n                \"tableValues\",\n                \"viewBox\",\n                \"gradientTransform\",\n                \"pathLength\",\n                \"startOffset\",\n                \"textLength\",\n                \"lengthAdjust\"\n            ]);\n            function Bn(t1, e, n, s) {\n                Ln(t1, e, void 0, s);\n                for(const n in e.attrs)t1.setAttribute(jn.has(n) ? n : At(n), e.attrs[n]);\n            }\n            function Fn(t1, e) {\n                const { style: n } = t1, s = {};\n                for(const i in n)(je(n[i]) || e.style && je(e.style[i]) || fn(i, t1)) && (s[i] = n[i]);\n                return s;\n            }\n            function On(t1, e) {\n                const n = Fn(t1, e);\n                for(const s in t1)(je(t1[s]) || je(e[s])) && (n[-1 !== wt.indexOf(s) ? \"attr\" + s.charAt(0).toUpperCase() + s.substring(1) : s] = t1[s]);\n                return n;\n            }\n            function In(t1) {\n                const e = je(t1) ? t1.get() : t1;\n                return n = e, Boolean(n && \"object\" == typeof n && n.mix && n.toValue) ? e.toValue() : e;\n                var n;\n            }\n            const Un = (e)=>(n, s)=>{\n                    const i = (0, t1.useContext)(Xe), o = (0, t1.useContext)(Ge), r = ()=>(function({ scrapeMotionValuesFromProps: t1, createRenderState: e, onMount: n }, s, i, o) {\n                            const r = {\n                                latestValues: Nn(s, i, o, t1),\n                                renderState: e()\n                            };\n                            return n && (r.mount = (t1)=>n(s, t1, r)), r;\n                        })(e, n, i, o);\n                    return s ? r() : We(r);\n                };\n            function Nn(t1, e, n, s) {\n                const i = {}, o = s(t1, {});\n                for(const t1 in o)i[t1] = In(o[t1]);\n                let { initial: r, animate: a } = t1;\n                const l = tn(t1), u = en(t1);\n                e && u && !l && !1 !== t1.inherit && (void 0 === r && (r = e.initial), void 0 === a && (a = e.animate));\n                let c = !!n && !1 === n.initial;\n                c = c || !1 === r;\n                const h = c ? a : r;\n                return h && \"boolean\" != typeof h && !_e(h) && (Array.isArray(h) ? h : [\n                    h\n                ]).forEach((e)=>{\n                    const n = vt(t1, e);\n                    if (!n) return;\n                    const { transitionEnd: s, transition: o, ...r } = n;\n                    for(const t1 in r){\n                        let e = r[t1];\n                        Array.isArray(e) && (e = e[c ? e.length - 1 : 0]), null !== e && (i[t1] = e);\n                    }\n                    for(const t1 in s)i[t1] = s[t1];\n                }), i;\n            }\n            const $n = {\n                useVisualState: Un({\n                    scrapeMotionValuesFromProps: On,\n                    createRenderState: ()=>({\n                            style: {},\n                            transform: {},\n                            transformOrigin: {},\n                            vars: {},\n                            attrs: {}\n                        }),\n                    onMount: (t1, e, { renderState: n, latestValues: s })=>{\n                        y.read(()=>{\n                            try {\n                                n.dimensions = \"function\" == typeof e.getBBox ? e.getBBox() : e.getBoundingClientRect();\n                            } catch (t1) {\n                                n.dimensions = {\n                                    x: 0,\n                                    y: 0,\n                                    width: 0,\n                                    height: 0\n                                };\n                            }\n                        }), y.render(()=>{\n                            Mn(n, s, {\n                                enableHardwareAcceleration: !1\n                            }, Dn(e.tagName), t1.transformTemplate), Bn(e, n);\n                        });\n                    }\n                })\n            }, Wn = {\n                useVisualState: Un({\n                    scrapeMotionValuesFromProps: Fn,\n                    createRenderState: ()=>({\n                            style: {},\n                            transform: {},\n                            transformOrigin: {},\n                            vars: {}\n                        })\n                })\n            };\n            function Hn(t1, e, n, s = {\n                passive: !0\n            }) {\n                return t1.addEventListener(e, n, s), ()=>t1.removeEventListener(e, n);\n            }\n            const zn = (t1)=>\"mouse\" === t1.pointerType ? \"number\" != typeof t1.button || t1.button <= 0 : !1 !== t1.isPrimary;\n            function Yn(t1, e = \"page\") {\n                return {\n                    point: {\n                        x: t1[e + \"X\"],\n                        y: t1[e + \"Y\"]\n                    }\n                };\n            }\n            function Xn(t1, e, n, s) {\n                return Hn(t1, e, ((t1)=>(e)=>zn(e) && t1(e, Yn(e)))(n), s);\n            }\n            function Gn(t1) {\n                let e = null;\n                return ()=>null === e && (e = t1, ()=>{\n                        e = null;\n                    });\n            }\n            const qn = Gn(\"dragHorizontal\"), Zn = Gn(\"dragVertical\");\n            function Kn(t1) {\n                let e = !1;\n                if (\"y\" === t1) e = Zn();\n                else if (\"x\" === t1) e = qn();\n                else {\n                    const t1 = qn(), n = Zn();\n                    t1 && n ? e = ()=>{\n                        t1(), n();\n                    } : (t1 && t1(), n && n());\n                }\n                return e;\n            }\n            function _n() {\n                const t1 = Kn(!0);\n                return !t1 || (t1(), !1);\n            }\n            class Jn {\n                constructor(t1){\n                    this.isMounted = !1, this.node = t1;\n                }\n                update() {}\n            }\n            function Qn(t1, e) {\n                const n = \"pointer\" + (e ? \"enter\" : \"leave\"), s = \"onHover\" + (e ? \"Start\" : \"End\");\n                return Xn(t1.current, n, (n, i)=>{\n                    if (\"touch\" === n.type || _n()) return;\n                    const o = t1.getProps();\n                    t1.animationState && o.whileHover && t1.animationState.setActive(\"whileHover\", e), o[s] && y.update(()=>o[s](n, i));\n                }, {\n                    passive: !t1.getProps()[s]\n                });\n            }\n            const ts = (t1, e)=>!!e && (t1 === e || ts(t1, e.parentElement));\n            function es(t1, e) {\n                if (!e) return;\n                const n = new PointerEvent(\"pointer\" + t1);\n                e(n, Yn(n));\n            }\n            const ns = new WeakMap, ss = new WeakMap, is = (t1)=>{\n                const e = ns.get(t1.target);\n                e && e(t1);\n            }, os = (t1)=>{\n                t1.forEach(is);\n            };\n            const rs = {\n                some: 0,\n                all: 1\n            }, as = {\n                inView: {\n                    Feature: class extends Jn {\n                        constructor(){\n                            super(...arguments), this.hasEnteredView = !1, this.isInView = !1;\n                        }\n                        startObserver() {\n                            this.unmount();\n                            const { viewport: t1 = {} } = this.node.getProps(), { root: e, margin: n, amount: s = \"some\", once: i } = t1, o = {\n                                root: e ? e.current : void 0,\n                                rootMargin: n,\n                                threshold: \"number\" == typeof s ? s : rs[s]\n                            };\n                            return function(t1, e, n) {\n                                const s = function({ root: t1, ...e }) {\n                                    const n = t1 || document;\n                                    ss.has(n) || ss.set(n, {});\n                                    const s = ss.get(n), i = JSON.stringify(e);\n                                    return s[i] || (s[i] = new IntersectionObserver(os, {\n                                        root: t1,\n                                        ...e\n                                    })), s[i];\n                                }(e);\n                                return ns.set(t1, n), s.observe(t1), ()=>{\n                                    ns.delete(t1), s.unobserve(t1);\n                                };\n                            }(this.node.current, o, (t1)=>{\n                                const { isIntersecting: e } = t1;\n                                if (this.isInView === e) return;\n                                if (this.isInView = e, i && !e && this.hasEnteredView) return;\n                                e && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive(\"whileInView\", e);\n                                const { onViewportEnter: n, onViewportLeave: s } = this.node.getProps(), o = e ? n : s;\n                                o && o(t1);\n                            });\n                        }\n                        mount() {\n                            this.startObserver();\n                        }\n                        update() {\n                            if (\"undefined\" == typeof IntersectionObserver) return;\n                            const { props: t1, prevProps: e } = this.node;\n                            [\n                                \"amount\",\n                                \"margin\",\n                                \"root\"\n                            ].some(function({ viewport: t1 = {} }, { viewport: e = {} } = {}) {\n                                return (n)=>t1[n] !== e[n];\n                            }(t1, e)) && this.startObserver();\n                        }\n                        unmount() {}\n                    }\n                },\n                tap: {\n                    Feature: class extends Jn {\n                        constructor(){\n                            super(...arguments), this.removeStartListeners = n, this.removeEndListeners = n, this.removeAccessibleListeners = n, this.startPointerPress = (t1, e)=>{\n                                if (this.removeEndListeners(), this.isPressing) return;\n                                const n = this.node.getProps(), s = Xn(window, \"pointerup\", (t1, e)=>{\n                                    if (!this.checkPressEnd()) return;\n                                    const { onTap: n, onTapCancel: s } = this.node.getProps();\n                                    y.update(()=>{\n                                        ts(this.node.current, t1.target) ? n && n(t1, e) : s && s(t1, e);\n                                    });\n                                }, {\n                                    passive: !(n.onTap || n.onPointerUp)\n                                }), i = Xn(window, \"pointercancel\", (t1, e)=>this.cancelPress(t1, e), {\n                                    passive: !(n.onTapCancel || n.onPointerCancel)\n                                });\n                                this.removeEndListeners = se(s, i), this.startPress(t1, e);\n                            }, this.startAccessiblePress = ()=>{\n                                const t1 = Hn(this.node.current, \"keydown\", (t1)=>{\n                                    \"Enter\" !== t1.key || this.isPressing || (this.removeEndListeners(), this.removeEndListeners = Hn(this.node.current, \"keyup\", (t1)=>{\n                                        \"Enter\" === t1.key && this.checkPressEnd() && es(\"up\", (t1, e)=>{\n                                            const { onTap: n } = this.node.getProps();\n                                            n && y.update(()=>n(t1, e));\n                                        });\n                                    }), es(\"down\", (t1, e)=>{\n                                        this.startPress(t1, e);\n                                    }));\n                                }), e = Hn(this.node.current, \"blur\", ()=>{\n                                    this.isPressing && es(\"cancel\", (t1, e)=>this.cancelPress(t1, e));\n                                });\n                                this.removeAccessibleListeners = se(t1, e);\n                            };\n                        }\n                        startPress(t1, e) {\n                            this.isPressing = !0;\n                            const { onTapStart: n, whileTap: s } = this.node.getProps();\n                            s && this.node.animationState && this.node.animationState.setActive(\"whileTap\", !0), n && y.update(()=>n(t1, e));\n                        }\n                        checkPressEnd() {\n                            return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive(\"whileTap\", !1), !_n();\n                        }\n                        cancelPress(t1, e) {\n                            if (!this.checkPressEnd()) return;\n                            const { onTapCancel: n } = this.node.getProps();\n                            n && y.update(()=>n(t1, e));\n                        }\n                        mount() {\n                            const t1 = this.node.getProps(), e = Xn(this.node.current, \"pointerdown\", this.startPointerPress, {\n                                passive: !(t1.onTapStart || t1.onPointerStart)\n                            }), n = Hn(this.node.current, \"focus\", this.startAccessiblePress);\n                            this.removeStartListeners = se(e, n);\n                        }\n                        unmount() {\n                            this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();\n                        }\n                    }\n                },\n                focus: {\n                    Feature: class extends Jn {\n                        constructor(){\n                            super(...arguments), this.isActive = !1;\n                        }\n                        onFocus() {\n                            let t1 = !1;\n                            try {\n                                t1 = this.node.current.matches(\":focus-visible\");\n                            } catch (e) {\n                                t1 = !0;\n                            }\n                            t1 && this.node.animationState && (this.node.animationState.setActive(\"whileFocus\", !0), this.isActive = !0);\n                        }\n                        onBlur() {\n                            this.isActive && this.node.animationState && (this.node.animationState.setActive(\"whileFocus\", !1), this.isActive = !1);\n                        }\n                        mount() {\n                            this.unmount = se(Hn(this.node.current, \"focus\", ()=>this.onFocus()), Hn(this.node.current, \"blur\", ()=>this.onBlur()));\n                        }\n                        unmount() {}\n                    }\n                },\n                hover: {\n                    Feature: class extends Jn {\n                        mount() {\n                            this.unmount = se(Qn(this.node, !0), Qn(this.node, !1));\n                        }\n                        unmount() {}\n                    }\n                }\n            };\n            function ls(t1, e) {\n                if (!Array.isArray(e)) return !1;\n                const n = e.length;\n                if (n !== t1.length) return !1;\n                for(let s = 0; s < n; s++)if (e[s] !== t1[s]) return !1;\n                return !0;\n            }\n            const us = [\n                ...Je\n            ].reverse(), cs = Je.length;\n            function hs(t1 = !1) {\n                return {\n                    isActive: t1,\n                    protectedKeys: {},\n                    needsAnimating: {},\n                    prevResolvedValues: {}\n                };\n            }\n            let ds = 0;\n            const ms = {\n                animation: {\n                    Feature: class extends Jn {\n                        constructor(t1){\n                            super(t1), t1.animationState || (t1.animationState = function(t1) {\n                                let e = function(t1) {\n                                    return (e)=>Promise.all(e.map(({ animation: e, options: n })=>Ne(t1, e, n)));\n                                }(t1);\n                                const n = {\n                                    animate: hs(!0),\n                                    whileInView: hs(),\n                                    whileHover: hs(),\n                                    whileTap: hs(),\n                                    whileDrag: hs(),\n                                    whileFocus: hs(),\n                                    exit: hs()\n                                };\n                                let s = !0;\n                                const i = (e, n)=>{\n                                    const s = xt(t1, n);\n                                    if (s) {\n                                        const { transition: t1, transitionEnd: n, ...i } = s;\n                                        e = {\n                                            ...e,\n                                            ...i,\n                                            ...n\n                                        };\n                                    }\n                                    return e;\n                                };\n                                function o(o, r) {\n                                    const a = t1.getProps(), l = t1.getVariantContext(!0) || {}, u = [], h = new Set;\n                                    let d = {}, m = 1 / 0;\n                                    for(let e = 0; e < cs; e++){\n                                        const g = us[e], y = n[g], v = void 0 !== a[g] ? a[g] : l[g], x = Ke(v), P = g === r ? y.isActive : null;\n                                        !1 === P && (m = e);\n                                        let b = v === l[g] && v !== a[g] && x;\n                                        if (b && s && t1.manuallyAnimateOnMount && (b = !1), y.protectedKeys = {\n                                            ...d\n                                        }, !y.isActive && null === P || !v && !y.prevProp || _e(v) || \"boolean\" == typeof v) continue;\n                                        const T = (p = y.prevProp, \"string\" == typeof (f = v) ? f !== p : !!Array.isArray(f) && !ls(f, p));\n                                        let S = T || g === r && y.isActive && !b && x || e > m && x;\n                                        const w = Array.isArray(v) ? v : [\n                                            v\n                                        ];\n                                        let E = w.reduce(i, {});\n                                        !1 === P && (E = {});\n                                        const { prevResolvedValues: A = {} } = y, V = {\n                                            ...A,\n                                            ...E\n                                        }, C = (t1)=>{\n                                            S = !0, h.delete(t1), y.needsAnimating[t1] = !0;\n                                        };\n                                        for(const t1 in V){\n                                            const e = E[t1], n = A[t1];\n                                            d.hasOwnProperty(t1) || (e !== n ? c(e) && c(n) ? !ls(e, n) || T ? C(t1) : y.protectedKeys[t1] = !0 : void 0 !== e ? C(t1) : h.add(t1) : void 0 !== e && h.has(t1) ? C(t1) : y.protectedKeys[t1] = !0);\n                                        }\n                                        y.prevProp = v, y.prevResolvedValues = E, y.isActive && (d = {\n                                            ...d,\n                                            ...E\n                                        }), s && t1.blockInitialAnimation && (S = !1), S && !b && u.push(...w.map((t1)=>({\n                                                animation: t1,\n                                                options: {\n                                                    type: g,\n                                                    ...o\n                                                }\n                                            })));\n                                    }\n                                    var p, f;\n                                    if (h.size) {\n                                        const e = {};\n                                        h.forEach((n)=>{\n                                            const s = t1.getBaseTarget(n);\n                                            void 0 !== s && (e[n] = s);\n                                        }), u.push({\n                                            animation: e\n                                        });\n                                    }\n                                    let g = Boolean(u.length);\n                                    return s && !1 === a.initial && !t1.manuallyAnimateOnMount && (g = !1), s = !1, g ? e(u) : Promise.resolve();\n                                }\n                                return {\n                                    animateChanges: o,\n                                    setActive: function(e, s, i) {\n                                        var r;\n                                        if (n[e].isActive === s) return Promise.resolve();\n                                        null === (r = t1.variantChildren) || void 0 === r || r.forEach((t1)=>{\n                                            var n;\n                                            return null === (n = t1.animationState) || void 0 === n ? void 0 : n.setActive(e, s);\n                                        }), n[e].isActive = s;\n                                        const a = o(i, e);\n                                        for(const t1 in n)n[t1].protectedKeys = {};\n                                        return a;\n                                    },\n                                    setAnimateFunction: function(n) {\n                                        e = n(t1);\n                                    },\n                                    getState: ()=>n\n                                };\n                            }(t1));\n                        }\n                        updateAnimationControlsSubscription() {\n                            const { animate: t1 } = this.node.getProps();\n                            this.unmount(), _e(t1) && (this.unmount = t1.subscribe(this.node));\n                        }\n                        mount() {\n                            this.updateAnimationControlsSubscription();\n                        }\n                        update() {\n                            const { animate: t1 } = this.node.getProps(), { animate: e } = this.node.prevProps || {};\n                            t1 !== e && this.updateAnimationControlsSubscription();\n                        }\n                        unmount() {}\n                    }\n                },\n                exit: {\n                    Feature: class extends Jn {\n                        constructor(){\n                            super(...arguments), this.id = ds++;\n                        }\n                        update() {\n                            if (!this.node.presenceContext) return;\n                            const { isPresent: t1, onExitComplete: e, custom: n } = this.node.presenceContext, { isPresent: s } = this.node.prevPresenceContext || {};\n                            if (!this.node.animationState || t1 === s) return;\n                            const i = this.node.animationState.setActive(\"exit\", !t1, {\n                                custom: null != n ? n : this.node.getProps().custom\n                            });\n                            e && !t1 && i.then(()=>e(this.id));\n                        }\n                        mount() {\n                            const { register: t1 } = this.node.presenceContext || {};\n                            t1 && (this.unmount = t1(this.id));\n                        }\n                        unmount() {}\n                    }\n                }\n            }, ps = (t1, e)=>Math.abs(t1 - e);\n            class fs {\n                constructor(t1, e, { transformPagePoint: n } = {}){\n                    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.updatePoint = ()=>{\n                        if (!this.lastMoveEvent || !this.lastMoveEventInfo) return;\n                        const t1 = vs(this.lastMoveEventInfo, this.history), e = null !== this.startEvent, n = function(t1, e) {\n                            const n = ps(t1.x, e.x), s = ps(t1.y, e.y);\n                            return Math.sqrt(n ** 2 + s ** 2);\n                        }(t1.offset, {\n                            x: 0,\n                            y: 0\n                        }) >= 3;\n                        if (!e && !n) return;\n                        const { point: s } = t1, { timestamp: i } = x;\n                        this.history.push({\n                            ...s,\n                            timestamp: i\n                        });\n                        const { onStart: o, onMove: r } = this.handlers;\n                        e || (o && o(this.lastMoveEvent, t1), this.startEvent = this.lastMoveEvent), r && r(this.lastMoveEvent, t1);\n                    }, this.handlePointerMove = (t1, e)=>{\n                        this.lastMoveEvent = t1, this.lastMoveEventInfo = gs(e, this.transformPagePoint), y.update(this.updatePoint, !0);\n                    }, this.handlePointerUp = (t1, e)=>{\n                        if (this.end(), !this.lastMoveEvent || !this.lastMoveEventInfo) return;\n                        const { onEnd: n, onSessionEnd: s } = this.handlers, i = vs(\"pointercancel\" === t1.type ? this.lastMoveEventInfo : gs(e, this.transformPagePoint), this.history);\n                        this.startEvent && n && n(t1, i), s && s(t1, i);\n                    }, !zn(t1)) return;\n                    this.handlers = e, this.transformPagePoint = n;\n                    const s = gs(Yn(t1), this.transformPagePoint), { point: i } = s, { timestamp: o } = x;\n                    this.history = [\n                        {\n                            ...i,\n                            timestamp: o\n                        }\n                    ];\n                    const { onSessionStart: r } = e;\n                    r && r(t1, vs(s, this.history)), this.removeListeners = se(Xn(window, \"pointermove\", this.handlePointerMove), Xn(window, \"pointerup\", this.handlePointerUp), Xn(window, \"pointercancel\", this.handlePointerUp));\n                }\n                updateHandlers(t1) {\n                    this.handlers = t1;\n                }\n                end() {\n                    this.removeListeners && this.removeListeners(), v(this.updatePoint);\n                }\n            }\n            function gs(t1, e) {\n                return e ? {\n                    point: e(t1.point)\n                } : t1;\n            }\n            function ys(t1, e) {\n                return {\n                    x: t1.x - e.x,\n                    y: t1.y - e.y\n                };\n            }\n            function vs({ point: t1 }, e) {\n                return {\n                    point: t1,\n                    delta: ys(t1, Ps(e)),\n                    offset: ys(t1, xs(e)),\n                    velocity: bs(e, .1)\n                };\n            }\n            function xs(t1) {\n                return t1[0];\n            }\n            function Ps(t1) {\n                return t1[t1.length - 1];\n            }\n            function bs(t1, e) {\n                if (t1.length < 2) return {\n                    x: 0,\n                    y: 0\n                };\n                let n = t1.length - 1, s = null;\n                const i = Ps(t1);\n                for(; n >= 0 && (s = t1[n], !(i.timestamp - s.timestamp > Ct(e)));)n--;\n                if (!s) return {\n                    x: 0,\n                    y: 0\n                };\n                const o = Mt(i.timestamp - s.timestamp);\n                if (0 === o) return {\n                    x: 0,\n                    y: 0\n                };\n                const r = {\n                    x: (i.x - s.x) / o,\n                    y: (i.y - s.y) / o\n                };\n                return r.x === 1 / 0 && (r.x = 0), r.y === 1 / 0 && (r.y = 0), r;\n            }\n            function Ts(t1) {\n                return t1.max - t1.min;\n            }\n            function Ss(t1, e = 0, n = .01) {\n                return Math.abs(t1 - e) <= n;\n            }\n            function ws(t1, e, n, s = .5) {\n                t1.origin = s, t1.originPoint = Kt(e.min, e.max, t1.origin), t1.scale = Ts(n) / Ts(e), (Ss(t1.scale, 1, 1e-4) || isNaN(t1.scale)) && (t1.scale = 1), t1.translate = Kt(n.min, n.max, t1.origin) - t1.originPoint, (Ss(t1.translate) || isNaN(t1.translate)) && (t1.translate = 0);\n            }\n            function Es(t1, e, n, s) {\n                ws(t1.x, e.x, n.x, s ? s.originX : void 0), ws(t1.y, e.y, n.y, s ? s.originY : void 0);\n            }\n            function As(t1, e, n) {\n                t1.min = n.min + e.min, t1.max = t1.min + Ts(e);\n            }\n            function Vs(t1, e, n) {\n                t1.min = e.min - n.min, t1.max = t1.min + Ts(e);\n            }\n            function Cs(t1, e, n) {\n                Vs(t1.x, e.x, n.x), Vs(t1.y, e.y, n.y);\n            }\n            function Ms(t1, e, n) {\n                return {\n                    min: void 0 !== e ? t1.min + e : void 0,\n                    max: void 0 !== n ? t1.max + n - (t1.max - t1.min) : void 0\n                };\n            }\n            function Ds(t1, e) {\n                let n = e.min - t1.min, s = e.max - t1.max;\n                return e.max - e.min < t1.max - t1.min && ([n, s] = [\n                    s,\n                    n\n                ]), {\n                    min: n,\n                    max: s\n                };\n            }\n            const ks = .35;\n            function Rs(t1, e, n) {\n                return {\n                    min: Ls(t1, e),\n                    max: Ls(t1, n)\n                };\n            }\n            function Ls(t1, e) {\n                return \"number\" == typeof t1 ? t1 : t1[e] || 0;\n            }\n            function js(t1) {\n                return [\n                    t1(\"x\"),\n                    t1(\"y\")\n                ];\n            }\n            function Bs({ top: t1, left: e, right: n, bottom: s }) {\n                return {\n                    x: {\n                        min: e,\n                        max: n\n                    },\n                    y: {\n                        min: t1,\n                        max: s\n                    }\n                };\n            }\n            function Fs(t1) {\n                return void 0 === t1 || 1 === t1;\n            }\n            function Os({ scale: t1, scaleX: e, scaleY: n }) {\n                return !Fs(t1) || !Fs(e) || !Fs(n);\n            }\n            function Is(t1) {\n                return Os(t1) || Us(t1) || t1.z || t1.rotate || t1.rotateX || t1.rotateY;\n            }\n            function Us(t1) {\n                return Ns(t1.x) || Ns(t1.y);\n            }\n            function Ns(t1) {\n                return t1 && \"0%\" !== t1;\n            }\n            function $s(t1, e, n) {\n                return n + e * (t1 - n);\n            }\n            function Ws(t1, e, n, s, i) {\n                return void 0 !== i && (t1 = $s(t1, i, s)), $s(t1, n, s) + e;\n            }\n            function Hs(t1, e = 0, n = 1, s, i) {\n                t1.min = Ws(t1.min, e, n, s, i), t1.max = Ws(t1.max, e, n, s, i);\n            }\n            function zs(t1, { x: e, y: n }) {\n                Hs(t1.x, e.translate, e.scale, e.originPoint), Hs(t1.y, n.translate, n.scale, n.originPoint);\n            }\n            function Ys(t1) {\n                return Number.isInteger(t1) || t1 > 1.0000000000001 || t1 < .999999999999 ? t1 : 1;\n            }\n            function Xs(t1, e) {\n                t1.min = t1.min + e, t1.max = t1.max + e;\n            }\n            function Gs(t1, e, [n, s, i]) {\n                const o = void 0 !== e[i] ? e[i] : .5, r = Kt(t1.min, t1.max, o);\n                Hs(t1, e[n], e[s], r, e.scale);\n            }\n            const qs = [\n                \"x\",\n                \"scaleX\",\n                \"originX\"\n            ], Zs = [\n                \"y\",\n                \"scaleY\",\n                \"originY\"\n            ];\n            function Ks(t1, e) {\n                Gs(t1.x, e, qs), Gs(t1.y, e, Zs);\n            }\n            function _s(t1, e) {\n                return Bs(function(t1, e) {\n                    if (!e) return t1;\n                    const n = e({\n                        x: t1.left,\n                        y: t1.top\n                    }), s = e({\n                        x: t1.right,\n                        y: t1.bottom\n                    });\n                    return {\n                        top: n.y,\n                        left: n.x,\n                        bottom: s.y,\n                        right: s.x\n                    };\n                }(t1.getBoundingClientRect(), e));\n            }\n            const Js = new WeakMap;\n            class Qs {\n                constructor(t1){\n                    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = {\n                        x: 0,\n                        y: 0\n                    }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = {\n                        x: {\n                            min: 0,\n                            max: 0\n                        },\n                        y: {\n                            min: 0,\n                            max: 0\n                        }\n                    }, this.visualElement = t1;\n                }\n                start(t1, { snapToCursor: e = !1 } = {}) {\n                    const { presenceContext: n } = this.visualElement;\n                    n && !1 === n.isPresent || (this.panSession = new fs(t1, {\n                        onSessionStart: (t1)=>{\n                            this.stopAnimation(), e && this.snapToCursor(Yn(t1, \"page\").point);\n                        },\n                        onStart: (t1, e)=>{\n                            const { drag: n, dragPropagation: s, onDragStart: i } = this.getProps();\n                            if (n && !s && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = Kn(n), !this.openGlobalLock)) return;\n                            this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), js((t1)=>{\n                                let e = this.getAxisMotionValue(t1).get() || 0;\n                                if (H.test(e)) {\n                                    const { projection: n } = this.visualElement;\n                                    if (n && n.layout) {\n                                        const s = n.layout.layoutBox[t1];\n                                        s && (e = Ts(s) * (parseFloat(e) / 100));\n                                    }\n                                }\n                                this.originPoint[t1] = e;\n                            }), i && y.update(()=>i(t1, e), !1, !0);\n                            const { animationState: o } = this.visualElement;\n                            o && o.setActive(\"whileDrag\", !0);\n                        },\n                        onMove: (t1, e)=>{\n                            const { dragPropagation: n, dragDirectionLock: s, onDirectionLock: i, onDrag: o } = this.getProps();\n                            if (!n && !this.openGlobalLock) return;\n                            const { offset: r } = e;\n                            if (s && null === this.currentDirection) return this.currentDirection = function(t1, e = 10) {\n                                let n = null;\n                                return Math.abs(t1.y) > e ? n = \"y\" : Math.abs(t1.x) > e && (n = \"x\"), n;\n                            }(r), void (null !== this.currentDirection && i && i(this.currentDirection));\n                            this.updateAxis(\"x\", e.point, r), this.updateAxis(\"y\", e.point, r), this.visualElement.render(), o && o(t1, e);\n                        },\n                        onSessionEnd: (t1, e)=>this.stop(t1, e)\n                    }, {\n                        transformPagePoint: this.visualElement.getTransformPagePoint()\n                    }));\n                }\n                stop(t1, e) {\n                    const n = this.isDragging;\n                    if (this.cancel(), !n) return;\n                    const { velocity: s } = e;\n                    this.startAnimation(s);\n                    const { onDragEnd: i } = this.getProps();\n                    i && y.update(()=>i(t1, e));\n                }\n                cancel() {\n                    this.isDragging = !1;\n                    const { projection: t1, animationState: e } = this.visualElement;\n                    t1 && (t1.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;\n                    const { dragPropagation: n } = this.getProps();\n                    !n && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), e && e.setActive(\"whileDrag\", !1);\n                }\n                updateAxis(t1, e, n) {\n                    const { drag: s } = this.getProps();\n                    if (!n || !ti(t1, s, this.currentDirection)) return;\n                    const i = this.getAxisMotionValue(t1);\n                    let o = this.originPoint[t1] + n[t1];\n                    this.constraints && this.constraints[t1] && (o = function(t1, { min: e, max: n }, s) {\n                        return void 0 !== e && t1 < e ? t1 = s ? Kt(e, t1, s.min) : Math.max(t1, e) : void 0 !== n && t1 > n && (t1 = s ? Kt(n, t1, s.max) : Math.min(t1, n)), t1;\n                    }(o, this.constraints[t1], this.elastic[t1])), i.set(o);\n                }\n                resolveConstraints() {\n                    const { dragConstraints: t1, dragElastic: e } = this.getProps(), { layout: n } = this.visualElement.projection || {}, s = this.constraints;\n                    t1 && Ze(t1) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : this.constraints = !(!t1 || !n) && function(t1, { top: e, left: n, bottom: s, right: i }) {\n                        return {\n                            x: Ms(t1.x, n, i),\n                            y: Ms(t1.y, e, s)\n                        };\n                    }(n.layoutBox, t1), this.elastic = function(t1 = ks) {\n                        return !1 === t1 ? t1 = 0 : !0 === t1 && (t1 = ks), {\n                            x: Rs(t1, \"left\", \"right\"),\n                            y: Rs(t1, \"top\", \"bottom\")\n                        };\n                    }(e), s !== this.constraints && n && this.constraints && !this.hasMutatedConstraints && js((t1)=>{\n                        this.getAxisMotionValue(t1) && (this.constraints[t1] = function(t1, e) {\n                            const n = {};\n                            return void 0 !== e.min && (n.min = e.min - t1.min), void 0 !== e.max && (n.max = e.max - t1.min), n;\n                        }(n.layoutBox[t1], this.constraints[t1]));\n                    });\n                }\n                resolveRefConstraints() {\n                    const { dragConstraints: t1, onMeasureDragConstraints: e } = this.getProps();\n                    if (!t1 || !Ze(t1)) return !1;\n                    const n = t1.current;\n                    r(null !== n, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n                    const { projection: s } = this.visualElement;\n                    if (!s || !s.layout) return !1;\n                    const i = function(t1, e, n) {\n                        const s = _s(t1, n), { scroll: i } = e;\n                        return i && (Xs(s.x, i.offset.x), Xs(s.y, i.offset.y)), s;\n                    }(n, s.root, this.visualElement.getTransformPagePoint());\n                    let o = function(t1, e) {\n                        return {\n                            x: Ds(t1.x, e.x),\n                            y: Ds(t1.y, e.y)\n                        };\n                    }(s.layout.layoutBox, i);\n                    if (e) {\n                        const t1 = e(function({ x: t1, y: e }) {\n                            return {\n                                top: e.min,\n                                right: t1.max,\n                                bottom: e.max,\n                                left: t1.min\n                            };\n                        }(o));\n                        this.hasMutatedConstraints = !!t1, t1 && (o = Bs(t1));\n                    }\n                    return o;\n                }\n                startAnimation(t1) {\n                    const { drag: e, dragMomentum: n, dragElastic: s, dragTransition: i, dragSnapToOrigin: o, onDragTransitionEnd: r } = this.getProps(), a = this.constraints || {}, l = js((r)=>{\n                        if (!ti(r, e, this.currentDirection)) return;\n                        let l = a && a[r] || {};\n                        o && (l = {\n                            min: 0,\n                            max: 0\n                        });\n                        const u = s ? 200 : 1e6, c = s ? 40 : 1e7, h = {\n                            type: \"inertia\",\n                            velocity: n ? t1[r] : 0,\n                            bounceStiffness: u,\n                            bounceDamping: c,\n                            timeConstant: 750,\n                            restDelta: 1,\n                            restSpeed: 10,\n                            ...i,\n                            ...l\n                        };\n                        return this.startAxisValueAnimation(r, h);\n                    });\n                    return Promise.all(l).then(r);\n                }\n                startAxisValueAnimation(t1, e) {\n                    const n = this.getAxisMotionValue(t1);\n                    return n.start(Le(t1, n, 0, e));\n                }\n                stopAnimation() {\n                    js((t1)=>this.getAxisMotionValue(t1).stop());\n                }\n                getAxisMotionValue(t1) {\n                    const e = \"_drag\" + t1.toUpperCase(), n = this.visualElement.getProps();\n                    return n[e] || this.visualElement.getValue(t1, (n.initial ? n.initial[t1] : void 0) || 0);\n                }\n                snapToCursor(t1) {\n                    js((e)=>{\n                        const { drag: n } = this.getProps();\n                        if (!ti(e, n, this.currentDirection)) return;\n                        const { projection: s } = this.visualElement, i = this.getAxisMotionValue(e);\n                        if (s && s.layout) {\n                            const { min: n, max: o } = s.layout.layoutBox[e];\n                            i.set(t1[e] - Kt(n, o, .5));\n                        }\n                    });\n                }\n                scalePositionWithinConstraints() {\n                    if (!this.visualElement.current) return;\n                    const { drag: t1, dragConstraints: e } = this.getProps(), { projection: n } = this.visualElement;\n                    if (!Ze(e) || !n || !this.constraints) return;\n                    this.stopAnimation();\n                    const s = {\n                        x: 0,\n                        y: 0\n                    };\n                    js((t1)=>{\n                        const e = this.getAxisMotionValue(t1);\n                        if (e) {\n                            const n = e.get();\n                            s[t1] = function(t1, e) {\n                                let n = .5;\n                                const s = Ts(t1), i = Ts(e);\n                                return i > s ? n = ue(e.min, e.max - s, t1.min) : s > i && (n = ue(t1.min, t1.max - i, e.min)), R(0, 1, n);\n                            }({\n                                min: n,\n                                max: n\n                            }, this.constraints[t1]);\n                        }\n                    });\n                    const { transformTemplate: i } = this.visualElement.getProps();\n                    this.visualElement.current.style.transform = i ? i({}, \"\") : \"none\", n.root && n.root.updateScroll(), n.updateLayout(), this.resolveConstraints(), js((e)=>{\n                        if (!ti(e, t1, null)) return;\n                        const n = this.getAxisMotionValue(e), { min: i, max: o } = this.constraints[e];\n                        n.set(Kt(i, o, s[e]));\n                    });\n                }\n                addListeners() {\n                    if (!this.visualElement.current) return;\n                    Js.set(this.visualElement, this);\n                    const t1 = Xn(this.visualElement.current, \"pointerdown\", (t1)=>{\n                        const { drag: e, dragListener: n = !0 } = this.getProps();\n                        e && n && this.start(t1);\n                    }), e = ()=>{\n                        const { dragConstraints: t1 } = this.getProps();\n                        Ze(t1) && (this.constraints = this.resolveRefConstraints());\n                    }, { projection: n } = this.visualElement, s = n.addEventListener(\"measure\", e);\n                    n && !n.layout && (n.root && n.root.updateScroll(), n.updateLayout()), e();\n                    const i = Hn(window, \"resize\", ()=>this.scalePositionWithinConstraints()), o = n.addEventListener(\"didUpdate\", ({ delta: t1, hasLayoutChanged: e })=>{\n                        this.isDragging && e && (js((e)=>{\n                            const n = this.getAxisMotionValue(e);\n                            n && (this.originPoint[e] += t1[e].translate, n.set(n.get() + t1[e].translate));\n                        }), this.visualElement.render());\n                    });\n                    return ()=>{\n                        i(), t1(), s(), o && o();\n                    };\n                }\n                getProps() {\n                    const t1 = this.visualElement.getProps(), { drag: e = !1, dragDirectionLock: n = !1, dragPropagation: s = !1, dragConstraints: i = !1, dragElastic: o = ks, dragMomentum: r = !0 } = t1;\n                    return {\n                        ...t1,\n                        drag: e,\n                        dragDirectionLock: n,\n                        dragPropagation: s,\n                        dragConstraints: i,\n                        dragElastic: o,\n                        dragMomentum: r\n                    };\n                }\n            }\n            function ti(t1, e, n) {\n                return !(!0 !== e && e !== t1 || null !== n && n !== t1);\n            }\n            const ei = (t1)=>(e, n)=>{\n                    t1 && y.update(()=>t1(e, n));\n                }, ni = {\n                hasAnimatedSinceResize: !0,\n                hasEverUpdated: !1\n            };\n            function si(t1, e) {\n                return e.max === e.min ? 0 : t1 / (e.max - e.min) * 100;\n            }\n            const ii = {\n                correct: (t1, e)=>{\n                    if (!e.target) return t1;\n                    if (\"string\" == typeof t1) {\n                        if (!z.test(t1)) return t1;\n                        t1 = parseFloat(t1);\n                    }\n                    return `${si(t1, e.target.x)}% ${si(t1, e.target.y)}%`;\n                }\n            }, oi = {\n                correct: (t1, { treeScale: e, projectionDelta: n })=>{\n                    const s = t1, i = it.parse(t1);\n                    if (i.length > 5) return s;\n                    const o = it.createTransformer(t1), r = \"number\" != typeof i[0] ? 1 : 0, a = n.x.scale * e.x, l = n.y.scale * e.y;\n                    i[0 + r] /= a, i[1 + r] /= l;\n                    const u = Kt(a, l, .5);\n                    return \"number\" == typeof i[2 + r] && (i[2 + r] /= u), \"number\" == typeof i[3 + r] && (i[3 + r] /= u), o(i);\n                }\n            };\n            class ri extends t1.Component {\n                componentDidMount() {\n                    const { visualElement: t1, layoutGroup: e, switchLayoutGroup: n, layoutId: s } = this.props, { projection: i } = t1;\n                    var o;\n                    o = li, Object.assign(pn, o), i && (e.group && e.group.add(i), n && n.register && s && n.register(i), i.root.didUpdate(), i.addEventListener(\"animationComplete\", ()=>{\n                        this.safeToRemove();\n                    }), i.setOptions({\n                        ...i.options,\n                        onExitComplete: ()=>this.safeToRemove()\n                    })), ni.hasEverUpdated = !0;\n                }\n                getSnapshotBeforeUpdate(t1) {\n                    const { layoutDependency: e, visualElement: n, drag: s, isPresent: i } = this.props, o = n.projection;\n                    return o ? (o.isPresent = i, s || t1.layoutDependency !== e || void 0 === e ? o.willUpdate() : this.safeToRemove(), t1.isPresent !== i && (i ? o.promote() : o.relegate() || y.postRender(()=>{\n                        const t1 = o.getStack();\n                        t1 && t1.members.length || this.safeToRemove();\n                    })), null) : null;\n                }\n                componentDidUpdate() {\n                    const { projection: t1 } = this.props.visualElement;\n                    t1 && (t1.root.didUpdate(), queueMicrotask(()=>{\n                        !t1.currentAnimation && t1.isLead() && this.safeToRemove();\n                    }));\n                }\n                componentWillUnmount() {\n                    const { visualElement: t1, layoutGroup: e, switchLayoutGroup: n } = this.props, { projection: s } = t1;\n                    s && (s.scheduleCheckAfterUnmount(), e && e.group && e.group.remove(s), n && n.deregister && n.deregister(s));\n                }\n                safeToRemove() {\n                    const { safeToRemove: t1 } = this.props;\n                    t1 && t1();\n                }\n                render() {\n                    return null;\n                }\n            }\n            function ai(e) {\n                const [n, s] = function() {\n                    const e = (0, t1.useContext)(Ge);\n                    if (null === e) return [\n                        !0,\n                        null\n                    ];\n                    const { isPresent: n, onExitComplete: s, register: i } = e, o = (0, t1.useId)();\n                    return (0, t1.useEffect)(()=>i(o), []), !n && s ? [\n                        !1,\n                        ()=>s && s(o)\n                    ] : [\n                        !0\n                    ];\n                }(), i = (0, t1.useContext)(rn);\n                return t1.createElement(ri, {\n                    ...e,\n                    layoutGroup: i,\n                    switchLayoutGroup: (0, t1.useContext)(an),\n                    isPresent: n,\n                    safeToRemove: s\n                });\n            }\n            const li = {\n                borderRadius: {\n                    ...ii,\n                    applyTo: [\n                        \"borderTopLeftRadius\",\n                        \"borderTopRightRadius\",\n                        \"borderBottomLeftRadius\",\n                        \"borderBottomRightRadius\"\n                    ]\n                },\n                borderTopLeftRadius: ii,\n                borderTopRightRadius: ii,\n                borderBottomLeftRadius: ii,\n                borderBottomRightRadius: ii,\n                boxShadow: oi\n            }, ui = [\n                \"TopLeft\",\n                \"TopRight\",\n                \"BottomLeft\",\n                \"BottomRight\"\n            ], ci = ui.length, hi = (t1)=>\"string\" == typeof t1 ? parseFloat(t1) : t1, di = (t1)=>\"number\" == typeof t1 || z.test(t1);\n            function mi(t1, e) {\n                return void 0 !== t1[e] ? t1[e] : t1.borderRadius;\n            }\n            const pi = gi(0, .5, Ht), fi = gi(.5, .95, n);\n            function gi(t1, e, n) {\n                return (s)=>s < t1 ? 0 : s > e ? 1 : n(ue(t1, e, s));\n            }\n            function yi(t1, e) {\n                t1.min = e.min, t1.max = e.max;\n            }\n            function vi(t1, e) {\n                yi(t1.x, e.x), yi(t1.y, e.y);\n            }\n            function xi(t1, e, n, s, i) {\n                return t1 = $s(t1 -= e, 1 / n, s), void 0 !== i && (t1 = $s(t1, 1 / i, s)), t1;\n            }\n            function Pi(t1, e, [n, s, i], o, r) {\n                !function(t1, e = 0, n = 1, s = .5, i, o = t1, r = t1) {\n                    if (H.test(e) && (e = parseFloat(e), e = Kt(r.min, r.max, e / 100) - r.min), \"number\" != typeof e) return;\n                    let a = Kt(o.min, o.max, s);\n                    t1 === o && (a -= e), t1.min = xi(t1.min, e, n, a, i), t1.max = xi(t1.max, e, n, a, i);\n                }(t1, e[n], e[s], e[i], e.scale, o, r);\n            }\n            const bi = [\n                \"x\",\n                \"scaleX\",\n                \"originX\"\n            ], Ti = [\n                \"y\",\n                \"scaleY\",\n                \"originY\"\n            ];\n            function Si(t1, e, n, s) {\n                Pi(t1.x, e, bi, n ? n.x : void 0, s ? s.x : void 0), Pi(t1.y, e, Ti, n ? n.y : void 0, s ? s.y : void 0);\n            }\n            function wi(t1) {\n                return 0 === t1.translate && 1 === t1.scale;\n            }\n            function Ei(t1) {\n                return wi(t1.x) && wi(t1.y);\n            }\n            function Ai(t1, e) {\n                return Math.round(t1.x.min) === Math.round(e.x.min) && Math.round(t1.x.max) === Math.round(e.x.max) && Math.round(t1.y.min) === Math.round(e.y.min) && Math.round(t1.y.max) === Math.round(e.y.max);\n            }\n            function Vi(t1) {\n                return Ts(t1.x) / Ts(t1.y);\n            }\n            class Ci {\n                constructor(){\n                    this.members = [];\n                }\n                add(t1) {\n                    h(this.members, t1), t1.scheduleRender();\n                }\n                remove(t1) {\n                    if (d(this.members, t1), t1 === this.prevLead && (this.prevLead = void 0), t1 === this.lead) {\n                        const t1 = this.members[this.members.length - 1];\n                        t1 && this.promote(t1);\n                    }\n                }\n                relegate(t1) {\n                    const e = this.members.findIndex((e)=>t1 === e);\n                    if (0 === e) return !1;\n                    let n;\n                    for(let t1 = e; t1 >= 0; t1--){\n                        const e = this.members[t1];\n                        if (!1 !== e.isPresent) {\n                            n = e;\n                            break;\n                        }\n                    }\n                    return !!n && (this.promote(n), !0);\n                }\n                promote(t1, e) {\n                    const n = this.lead;\n                    if (t1 !== n && (this.prevLead = n, this.lead = t1, t1.show(), n)) {\n                        n.instance && n.scheduleRender(), t1.scheduleRender(), t1.resumeFrom = n, e && (t1.resumeFrom.preserveOpacity = !0), n.snapshot && (t1.snapshot = n.snapshot, t1.snapshot.latestValues = n.animationValues || n.latestValues), t1.root && t1.root.isUpdating && (t1.isLayoutDirty = !0);\n                        const { crossfade: s } = t1.options;\n                        !1 === s && n.hide();\n                    }\n                }\n                exitAnimationComplete() {\n                    this.members.forEach((t1)=>{\n                        const { options: e, resumingFrom: n } = t1;\n                        e.onExitComplete && e.onExitComplete(), n && n.options.onExitComplete && n.options.onExitComplete();\n                    });\n                }\n                scheduleRender() {\n                    this.members.forEach((t1)=>{\n                        t1.instance && t1.scheduleRender(!1);\n                    });\n                }\n                removeLeadSnapshot() {\n                    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);\n                }\n            }\n            function Mi(t1, e, n) {\n                let s = \"\";\n                const i = t1.x.translate / e.x, o = t1.y.translate / e.y;\n                if ((i || o) && (s = `translate3d(${i}px, ${o}px, 0) `), 1 === e.x && 1 === e.y || (s += `scale(${1 / e.x}, ${1 / e.y}) `), n) {\n                    const { rotate: t1, rotateX: e, rotateY: i } = n;\n                    t1 && (s += `rotate(${t1}deg) `), e && (s += `rotateX(${e}deg) `), i && (s += `rotateY(${i}deg) `);\n                }\n                const r = t1.x.scale * e.x, a = t1.y.scale * e.y;\n                return 1 === r && 1 === a || (s += `scale(${r}, ${a})`), s || \"none\";\n            }\n            const Di = (t1, e)=>t1.depth - e.depth;\n            class ki {\n                constructor(){\n                    this.children = [], this.isDirty = !1;\n                }\n                add(t1) {\n                    h(this.children, t1), this.isDirty = !0;\n                }\n                remove(t1) {\n                    d(this.children, t1), this.isDirty = !0;\n                }\n                forEach(t1) {\n                    this.isDirty && this.children.sort(Di), this.isDirty = !1, this.children.forEach(t1);\n                }\n            }\n            const Ri = [\n                \"\",\n                \"X\",\n                \"Y\",\n                \"Z\"\n            ];\n            let Li = 0;\n            const ji = {\n                type: \"projectionFrame\",\n                totalNodes: 0,\n                resolvedTargetDeltas: 0,\n                recalculatedProjection: 0\n            };\n            function Bi({ attachResizeListener: t1, defaultParent: e, measureScroll: n, checkIsScrollRoot: s, resetTransform: i }) {\n                return class {\n                    constructor(t1 = {}, n = null == e ? void 0 : e()){\n                        this.id = Li++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = {\n                            x: 1,\n                            y: 1\n                        }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.checkUpdateFailed = ()=>{\n                            this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());\n                        }, this.updateProjection = ()=>{\n                            var t1;\n                            ji.totalNodes = ji.resolvedTargetDeltas = ji.recalculatedProjection = 0, this.nodes.forEach(Ii), this.nodes.forEach(Yi), this.nodes.forEach(Xi), this.nodes.forEach(Ui), t1 = ji, window.MotionDebug && window.MotionDebug.record(t1);\n                        }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = t1, this.root = n ? n.root || n : this, this.path = n ? [\n                            ...n.path,\n                            n\n                        ] : [], this.parent = n, this.depth = n ? n.depth + 1 : 0;\n                        for(let t1 = 0; t1 < this.path.length; t1++)this.path[t1].shouldResetTransform = !0;\n                        this.root === this && (this.nodes = new ki);\n                    }\n                    addEventListener(t1, e) {\n                        return this.eventHandlers.has(t1) || this.eventHandlers.set(t1, new m), this.eventHandlers.get(t1).add(e);\n                    }\n                    notifyListeners(t1, ...e) {\n                        const n = this.eventHandlers.get(t1);\n                        n && n.notify(...e);\n                    }\n                    hasListeners(t1) {\n                        return this.eventHandlers.has(t1);\n                    }\n                    mount(e, n = this.root.hasTreeAnimated) {\n                        if (this.instance) return;\n                        var s;\n                        this.isSVG = (s = e) instanceof SVGElement && \"svg\" !== s.tagName, this.instance = e;\n                        const { layoutId: i, layout: o, visualElement: r } = this.options;\n                        if (r && !r.current && r.mount(e), this.root.nodes.add(this), this.parent && this.parent.children.add(this), n && (o || i) && (this.isLayoutDirty = !0), t1) {\n                            let n;\n                            const s = ()=>this.root.updateBlockedByResize = !1;\n                            t1(e, ()=>{\n                                this.root.updateBlockedByResize = !0, n && n(), n = function(t1, e) {\n                                    const n = performance.now(), s = ({ timestamp: e })=>{\n                                        const i = e - n;\n                                        i >= 250 && (v(s), t1(i - 250));\n                                    };\n                                    return y.read(s, !0), ()=>v(s);\n                                }(s), ni.hasAnimatedSinceResize && (ni.hasAnimatedSinceResize = !1, this.nodes.forEach(zi));\n                            });\n                        }\n                        i && this.root.registerSharedNode(i, this), !1 !== this.options.animate && r && (i || o) && this.addEventListener(\"didUpdate\", ({ delta: t1, hasLayoutChanged: e, hasRelativeTargetChanged: n, layout: s })=>{\n                            if (this.isTreeAnimationBlocked()) return this.target = void 0, void (this.relativeTarget = void 0);\n                            const i = this.options.transition || r.getDefaultTransition() || Ji, { onLayoutAnimationStart: o, onLayoutAnimationComplete: a } = r.getProps(), l = !this.targetLayout || !Ai(this.targetLayout, s) || n, u = !e && n;\n                            if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || u || e && (l || !this.currentAnimation)) {\n                                this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(t1, u);\n                                const e = {\n                                    ...Re(i, \"layout\"),\n                                    onPlay: o,\n                                    onComplete: a\n                                };\n                                (r.shouldReduceMotion || this.options.layoutRoot) && (e.delay = 0, e.type = !1), this.startAnimation(e);\n                            } else e || zi(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();\n                            this.targetLayout = s;\n                        });\n                    }\n                    unmount() {\n                        this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);\n                        const t1 = this.getStack();\n                        t1 && t1.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, v(this.updateProjection);\n                    }\n                    blockUpdate() {\n                        this.updateManuallyBlocked = !0;\n                    }\n                    unblockUpdate() {\n                        this.updateManuallyBlocked = !1;\n                    }\n                    isUpdateBlocked() {\n                        return this.updateManuallyBlocked || this.updateBlockedByResize;\n                    }\n                    isTreeAnimationBlocked() {\n                        return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;\n                    }\n                    startUpdate() {\n                        this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(Gi), this.animationId++);\n                    }\n                    getTransformTemplate() {\n                        const { visualElement: t1 } = this.options;\n                        return t1 && t1.getProps().transformTemplate;\n                    }\n                    willUpdate(t1 = !0) {\n                        if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) return void (this.options.onExitComplete && this.options.onExitComplete());\n                        if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return;\n                        this.isLayoutDirty = !0;\n                        for(let t1 = 0; t1 < this.path.length; t1++){\n                            const e = this.path[t1];\n                            e.shouldResetTransform = !0, e.updateScroll(\"snapshot\"), e.options.layoutRoot && e.willUpdate(!1);\n                        }\n                        const { layoutId: e, layout: n } = this.options;\n                        if (void 0 === e && !n) return;\n                        const s = this.getTransformTemplate();\n                        this.prevTransformTemplateValue = s ? s(this.latestValues, \"\") : void 0, this.updateSnapshot(), t1 && this.notifyListeners(\"willUpdate\");\n                    }\n                    update() {\n                        if (this.updateScheduled = !1, this.isUpdateBlocked()) return this.unblockUpdate(), this.clearAllSnapshots(), void this.nodes.forEach($i);\n                        this.isUpdating || this.nodes.forEach(Wi), this.isUpdating = !1, this.nodes.forEach(Hi), this.nodes.forEach(Fi), this.nodes.forEach(Oi), this.clearAllSnapshots();\n                        const t1 = performance.now();\n                        x.delta = R(0, 1e3 / 60, t1 - x.timestamp), x.timestamp = t1, x.isProcessing = !0, P.update.process(x), P.preRender.process(x), P.render.process(x), x.isProcessing = !1;\n                    }\n                    didUpdate() {\n                        this.updateScheduled || (this.updateScheduled = !0, queueMicrotask(()=>this.update()));\n                    }\n                    clearAllSnapshots() {\n                        this.nodes.forEach(Ni), this.sharedNodes.forEach(qi);\n                    }\n                    scheduleUpdateProjection() {\n                        y.preRender(this.updateProjection, !1, !0);\n                    }\n                    scheduleCheckAfterUnmount() {\n                        y.postRender(()=>{\n                            this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();\n                        });\n                    }\n                    updateSnapshot() {\n                        !this.snapshot && this.instance && (this.snapshot = this.measure());\n                    }\n                    updateLayout() {\n                        if (!this.instance) return;\n                        if (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead() || this.isLayoutDirty)) return;\n                        if (this.resumeFrom && !this.resumeFrom.instance) for(let t1 = 0; t1 < this.path.length; t1++)this.path[t1].updateScroll();\n                        const t1 = this.layout;\n                        this.layout = this.measure(!1), this.layoutCorrected = {\n                            x: {\n                                min: 0,\n                                max: 0\n                            },\n                            y: {\n                                min: 0,\n                                max: 0\n                            }\n                        }, this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners(\"measure\", this.layout.layoutBox);\n                        const { visualElement: e } = this.options;\n                        e && e.notify(\"LayoutMeasure\", this.layout.layoutBox, t1 ? t1.layoutBox : void 0);\n                    }\n                    updateScroll(t1 = \"measure\") {\n                        let e = Boolean(this.options.layoutScroll && this.instance);\n                        this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === t1 && (e = !1), e && (this.scroll = {\n                            animationId: this.root.animationId,\n                            phase: t1,\n                            isRoot: s(this.instance),\n                            offset: n(this.instance)\n                        });\n                    }\n                    resetTransform() {\n                        if (!i) return;\n                        const t1 = this.isLayoutDirty || this.shouldResetTransform, e = this.projectionDelta && !Ei(this.projectionDelta), n = this.getTransformTemplate(), s = n ? n(this.latestValues, \"\") : void 0, o = s !== this.prevTransformTemplateValue;\n                        t1 && (e || Is(this.latestValues) || o) && (i(this.instance, s), this.shouldResetTransform = !1, this.scheduleRender());\n                    }\n                    measure(t1 = !0) {\n                        const e = this.measurePageBox();\n                        let n = this.removeElementScroll(e);\n                        var s;\n                        return t1 && (n = this.removeTransform(n)), eo((s = n).x), eo(s.y), {\n                            animationId: this.root.animationId,\n                            measuredBox: e,\n                            layoutBox: n,\n                            latestValues: {},\n                            source: this.id\n                        };\n                    }\n                    measurePageBox() {\n                        const { visualElement: t1 } = this.options;\n                        if (!t1) return {\n                            x: {\n                                min: 0,\n                                max: 0\n                            },\n                            y: {\n                                min: 0,\n                                max: 0\n                            }\n                        };\n                        const e = t1.measureViewportBox(), { scroll: n } = this.root;\n                        return n && (Xs(e.x, n.offset.x), Xs(e.y, n.offset.y)), e;\n                    }\n                    removeElementScroll(t1) {\n                        const e = {\n                            x: {\n                                min: 0,\n                                max: 0\n                            },\n                            y: {\n                                min: 0,\n                                max: 0\n                            }\n                        };\n                        vi(e, t1);\n                        for(let n = 0; n < this.path.length; n++){\n                            const s = this.path[n], { scroll: i, options: o } = s;\n                            if (s !== this.root && i && o.layoutScroll) {\n                                if (i.isRoot) {\n                                    vi(e, t1);\n                                    const { scroll: n } = this.root;\n                                    n && (Xs(e.x, -n.offset.x), Xs(e.y, -n.offset.y));\n                                }\n                                Xs(e.x, i.offset.x), Xs(e.y, i.offset.y);\n                            }\n                        }\n                        return e;\n                    }\n                    applyTransform(t1, e = !1) {\n                        const n = {\n                            x: {\n                                min: 0,\n                                max: 0\n                            },\n                            y: {\n                                min: 0,\n                                max: 0\n                            }\n                        };\n                        vi(n, t1);\n                        for(let t1 = 0; t1 < this.path.length; t1++){\n                            const s = this.path[t1];\n                            !e && s.options.layoutScroll && s.scroll && s !== s.root && Ks(n, {\n                                x: -s.scroll.offset.x,\n                                y: -s.scroll.offset.y\n                            }), Is(s.latestValues) && Ks(n, s.latestValues);\n                        }\n                        return Is(this.latestValues) && Ks(n, this.latestValues), n;\n                    }\n                    removeTransform(t1) {\n                        const e = {\n                            x: {\n                                min: 0,\n                                max: 0\n                            },\n                            y: {\n                                min: 0,\n                                max: 0\n                            }\n                        };\n                        vi(e, t1);\n                        for(let t1 = 0; t1 < this.path.length; t1++){\n                            const n = this.path[t1];\n                            if (!n.instance) continue;\n                            if (!Is(n.latestValues)) continue;\n                            Os(n.latestValues) && n.updateSnapshot();\n                            const s = {\n                                x: {\n                                    min: 0,\n                                    max: 0\n                                },\n                                y: {\n                                    min: 0,\n                                    max: 0\n                                }\n                            };\n                            vi(s, n.measurePageBox()), Si(e, n.latestValues, n.snapshot ? n.snapshot.layoutBox : void 0, s);\n                        }\n                        return Is(this.latestValues) && Si(e, this.latestValues), e;\n                    }\n                    setTargetDelta(t1) {\n                        this.targetDelta = t1, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;\n                    }\n                    setOptions(t1) {\n                        this.options = {\n                            ...this.options,\n                            ...t1,\n                            crossfade: void 0 === t1.crossfade || t1.crossfade\n                        };\n                    }\n                    clearMeasurements() {\n                        this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;\n                    }\n                    forceRelativeParentToResolveTarget() {\n                        this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== x.timestamp && this.relativeParent.resolveTargetDelta(!0);\n                    }\n                    resolveTargetDelta(t1 = !1) {\n                        var e;\n                        const n = this.getLead();\n                        this.isProjectionDirty || (this.isProjectionDirty = n.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = n.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = n.isSharedProjectionDirty);\n                        const s = Boolean(this.resumingFrom) || this !== n;\n                        if (!(t1 || s && this.isSharedProjectionDirty || this.isProjectionDirty || (null === (e = this.parent) || void 0 === e ? void 0 : e.isProjectionDirty) || this.attemptToResolveRelativeTarget)) return;\n                        const { layout: i, layoutId: o } = this.options;\n                        if (this.layout && (i || o)) {\n                            if (this.resolvedRelativeTargetAt = x.timestamp, !this.targetDelta && !this.relativeTarget) {\n                                const t1 = this.getClosestProjectingParent();\n                                t1 && t1.layout && 1 !== this.animationProgress ? (this.relativeParent = t1, this.forceRelativeParentToResolveTarget(), this.relativeTarget = {\n                                    x: {\n                                        min: 0,\n                                        max: 0\n                                    },\n                                    y: {\n                                        min: 0,\n                                        max: 0\n                                    }\n                                }, this.relativeTargetOrigin = {\n                                    x: {\n                                        min: 0,\n                                        max: 0\n                                    },\n                                    y: {\n                                        min: 0,\n                                        max: 0\n                                    }\n                                }, Cs(this.relativeTargetOrigin, this.layout.layoutBox, t1.layout.layoutBox), vi(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;\n                            }\n                            if (this.relativeTarget || this.targetDelta) {\n                                var r, a, l;\n                                if (this.target || (this.target = {\n                                    x: {\n                                        min: 0,\n                                        max: 0\n                                    },\n                                    y: {\n                                        min: 0,\n                                        max: 0\n                                    }\n                                }, this.targetWithTransforms = {\n                                    x: {\n                                        min: 0,\n                                        max: 0\n                                    },\n                                    y: {\n                                        min: 0,\n                                        max: 0\n                                    }\n                                }), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), r = this.target, a = this.relativeTarget, l = this.relativeParent.target, As(r.x, a.x, l.x), As(r.y, a.y, l.y)) : this.targetDelta ? (Boolean(this.resumingFrom) ? this.target = this.applyTransform(this.layout.layoutBox) : vi(this.target, this.layout.layoutBox), zs(this.target, this.targetDelta)) : vi(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {\n                                    this.attemptToResolveRelativeTarget = !1;\n                                    const t1 = this.getClosestProjectingParent();\n                                    t1 && Boolean(t1.resumingFrom) === Boolean(this.resumingFrom) && !t1.options.layoutScroll && t1.target && 1 !== this.animationProgress ? (this.relativeParent = t1, this.forceRelativeParentToResolveTarget(), this.relativeTarget = {\n                                        x: {\n                                            min: 0,\n                                            max: 0\n                                        },\n                                        y: {\n                                            min: 0,\n                                            max: 0\n                                        }\n                                    }, this.relativeTargetOrigin = {\n                                        x: {\n                                            min: 0,\n                                            max: 0\n                                        },\n                                        y: {\n                                            min: 0,\n                                            max: 0\n                                        }\n                                    }, Cs(this.relativeTargetOrigin, this.target, t1.target), vi(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;\n                                }\n                                ji.resolvedTargetDeltas++;\n                            }\n                        }\n                    }\n                    getClosestProjectingParent() {\n                        if (this.parent && !Os(this.parent.latestValues) && !Us(this.parent.latestValues)) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();\n                    }\n                    isProjecting() {\n                        return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);\n                    }\n                    calcProjection() {\n                        var t1;\n                        const e = this.getLead(), n = Boolean(this.resumingFrom) || this !== e;\n                        let s = !0;\n                        if ((this.isProjectionDirty || (null === (t1 = this.parent) || void 0 === t1 ? void 0 : t1.isProjectionDirty)) && (s = !1), n && (this.isSharedProjectionDirty || this.isTransformDirty) && (s = !1), this.resolvedRelativeTargetAt === x.timestamp && (s = !1), s) return;\n                        const { layout: i, layoutId: o } = this.options;\n                        if (this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !i && !o) return;\n                        vi(this.layoutCorrected, this.layout.layoutBox);\n                        const r = this.treeScale.x, a = this.treeScale.y;\n                        !function(t1, e, n, s = !1) {\n                            const i = n.length;\n                            if (!i) return;\n                            let o, r;\n                            e.x = e.y = 1;\n                            for(let a = 0; a < i; a++){\n                                o = n[a], r = o.projectionDelta;\n                                const i = o.instance;\n                                i && i.style && \"contents\" === i.style.display || (s && o.options.layoutScroll && o.scroll && o !== o.root && Ks(t1, {\n                                    x: -o.scroll.offset.x,\n                                    y: -o.scroll.offset.y\n                                }), r && (e.x *= r.x.scale, e.y *= r.y.scale, zs(t1, r)), s && Is(o.latestValues) && Ks(t1, o.latestValues));\n                            }\n                            e.x = Ys(e.x), e.y = Ys(e.y);\n                        }(this.layoutCorrected, this.treeScale, this.path, n), !e.layout || e.target || 1 === this.treeScale.x && 1 === this.treeScale.y || (e.target = e.layout.layoutBox);\n                        const { target: l } = e;\n                        if (!l) return void (this.projectionTransform && (this.projectionDelta = {\n                            x: {\n                                translate: 0,\n                                scale: 1,\n                                origin: 0,\n                                originPoint: 0\n                            },\n                            y: {\n                                translate: 0,\n                                scale: 1,\n                                origin: 0,\n                                originPoint: 0\n                            }\n                        }, this.projectionTransform = \"none\", this.scheduleRender()));\n                        this.projectionDelta || (this.projectionDelta = {\n                            x: {\n                                translate: 0,\n                                scale: 1,\n                                origin: 0,\n                                originPoint: 0\n                            },\n                            y: {\n                                translate: 0,\n                                scale: 1,\n                                origin: 0,\n                                originPoint: 0\n                            }\n                        }, this.projectionDeltaWithTransform = {\n                            x: {\n                                translate: 0,\n                                scale: 1,\n                                origin: 0,\n                                originPoint: 0\n                            },\n                            y: {\n                                translate: 0,\n                                scale: 1,\n                                origin: 0,\n                                originPoint: 0\n                            }\n                        });\n                        const u = this.projectionTransform;\n                        Es(this.projectionDelta, this.layoutCorrected, l, this.latestValues), this.projectionTransform = Mi(this.projectionDelta, this.treeScale), this.projectionTransform === u && this.treeScale.x === r && this.treeScale.y === a || (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners(\"projectionUpdate\", l)), ji.recalculatedProjection++;\n                    }\n                    hide() {\n                        this.isVisible = !1;\n                    }\n                    show() {\n                        this.isVisible = !0;\n                    }\n                    scheduleRender(t1 = !0) {\n                        if (this.options.scheduleRender && this.options.scheduleRender(), t1) {\n                            const t1 = this.getStack();\n                            t1 && t1.scheduleRender();\n                        }\n                        this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);\n                    }\n                    setAnimationOrigin(t1, e = !1) {\n                        const n = this.snapshot, s = n ? n.latestValues : {}, i = {\n                            ...this.latestValues\n                        }, o = {\n                            x: {\n                                translate: 0,\n                                scale: 1,\n                                origin: 0,\n                                originPoint: 0\n                            },\n                            y: {\n                                translate: 0,\n                                scale: 1,\n                                origin: 0,\n                                originPoint: 0\n                            }\n                        };\n                        this.relativeParent && this.relativeParent.options.layoutRoot || (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !e;\n                        const r = {\n                            x: {\n                                min: 0,\n                                max: 0\n                            },\n                            y: {\n                                min: 0,\n                                max: 0\n                            }\n                        }, a = (n ? n.source : void 0) !== (this.layout ? this.layout.source : void 0), l = this.getStack(), u = !l || l.members.length <= 1, c = Boolean(a && !u && !0 === this.options.crossfade && !this.path.some(_i));\n                        let h;\n                        this.animationProgress = 0, this.mixTargetDelta = (e)=>{\n                            const n = e / 1e3;\n                            var l, d, m, p, f, g;\n                            Zi(o.x, t1.x, n), Zi(o.y, t1.y, n), this.setTargetDelta(o), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Cs(r, this.layout.layoutBox, this.relativeParent.layout.layoutBox), m = this.relativeTarget, p = this.relativeTargetOrigin, f = r, g = n, Ki(m.x, p.x, f.x, g), Ki(m.y, p.y, f.y, g), h && (l = this.relativeTarget, d = h, l.x.min === d.x.min && l.x.max === d.x.max && l.y.min === d.y.min && l.y.max === d.y.max) && (this.isProjectionDirty = !1), h || (h = {\n                                x: {\n                                    min: 0,\n                                    max: 0\n                                },\n                                y: {\n                                    min: 0,\n                                    max: 0\n                                }\n                            }), vi(h, this.relativeTarget)), a && (this.animationValues = i, function(t1, e, n, s, i, o) {\n                                i ? (t1.opacity = Kt(0, void 0 !== n.opacity ? n.opacity : 1, pi(s)), t1.opacityExit = Kt(void 0 !== e.opacity ? e.opacity : 1, 0, fi(s))) : o && (t1.opacity = Kt(void 0 !== e.opacity ? e.opacity : 1, void 0 !== n.opacity ? n.opacity : 1, s));\n                                for(let i = 0; i < ci; i++){\n                                    const o = `border${ui[i]}Radius`;\n                                    let r = mi(e, o), a = mi(n, o);\n                                    void 0 === r && void 0 === a || (r || (r = 0), a || (a = 0), 0 === r || 0 === a || di(r) === di(a) ? (t1[o] = Math.max(Kt(hi(r), hi(a), s), 0), (H.test(a) || H.test(r)) && (t1[o] += \"%\")) : t1[o] = a);\n                                }\n                                (e.rotate || n.rotate) && (t1.rotate = Kt(e.rotate || 0, n.rotate || 0, s));\n                            }(i, s, this.latestValues, n, c, u)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = n;\n                        }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);\n                    }\n                    startAnimation(t1) {\n                        this.notifyListeners(\"animationStart\"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (v(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = y.update(()=>{\n                            ni.hasAnimatedSinceResize = !0, this.currentAnimation = function(t1, e, n) {\n                                const s = je(0) ? 0 : S(0);\n                                return s.start(Le(\"\", s, 1e3, n)), s.animation;\n                            }(0, 0, {\n                                ...t1,\n                                onUpdate: (e)=>{\n                                    this.mixTargetDelta(e), t1.onUpdate && t1.onUpdate(e);\n                                },\n                                onComplete: ()=>{\n                                    t1.onComplete && t1.onComplete(), this.completeAnimation();\n                                }\n                            }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;\n                        });\n                    }\n                    completeAnimation() {\n                        this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);\n                        const t1 = this.getStack();\n                        t1 && t1.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners(\"animationComplete\");\n                    }\n                    finishAnimation() {\n                        this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(1e3), this.currentAnimation.stop()), this.completeAnimation();\n                    }\n                    applyTransformsToTarget() {\n                        const t1 = this.getLead();\n                        let { targetWithTransforms: e, target: n, layout: s, latestValues: i } = t1;\n                        if (e && n && s) {\n                            if (this !== t1 && this.layout && s && no(this.options.animationType, this.layout.layoutBox, s.layoutBox)) {\n                                n = this.target || {\n                                    x: {\n                                        min: 0,\n                                        max: 0\n                                    },\n                                    y: {\n                                        min: 0,\n                                        max: 0\n                                    }\n                                };\n                                const e = Ts(this.layout.layoutBox.x);\n                                n.x.min = t1.target.x.min, n.x.max = n.x.min + e;\n                                const s = Ts(this.layout.layoutBox.y);\n                                n.y.min = t1.target.y.min, n.y.max = n.y.min + s;\n                            }\n                            vi(e, n), Ks(e, i), Es(this.projectionDeltaWithTransform, this.layoutCorrected, e, i);\n                        }\n                    }\n                    registerSharedNode(t1, e) {\n                        this.sharedNodes.has(t1) || this.sharedNodes.set(t1, new Ci), this.sharedNodes.get(t1).add(e);\n                        const n = e.options.initialPromotionConfig;\n                        e.promote({\n                            transition: n ? n.transition : void 0,\n                            preserveFollowOpacity: n && n.shouldPreserveFollowOpacity ? n.shouldPreserveFollowOpacity(e) : void 0\n                        });\n                    }\n                    isLead() {\n                        const t1 = this.getStack();\n                        return !t1 || t1.lead === this;\n                    }\n                    getLead() {\n                        var t1;\n                        const { layoutId: e } = this.options;\n                        return e && (null === (t1 = this.getStack()) || void 0 === t1 ? void 0 : t1.lead) || this;\n                    }\n                    getPrevLead() {\n                        var t1;\n                        const { layoutId: e } = this.options;\n                        return e ? null === (t1 = this.getStack()) || void 0 === t1 ? void 0 : t1.prevLead : void 0;\n                    }\n                    getStack() {\n                        const { layoutId: t1 } = this.options;\n                        if (t1) return this.root.sharedNodes.get(t1);\n                    }\n                    promote({ needsReset: t1, transition: e, preserveFollowOpacity: n } = {}) {\n                        const s = this.getStack();\n                        s && s.promote(this, n), t1 && (this.projectionDelta = void 0, this.needsReset = !0), e && this.setOptions({\n                            transition: e\n                        });\n                    }\n                    relegate() {\n                        const t1 = this.getStack();\n                        return !!t1 && t1.relegate(this);\n                    }\n                    resetRotation() {\n                        const { visualElement: t1 } = this.options;\n                        if (!t1) return;\n                        let e = !1;\n                        const { latestValues: n } = t1;\n                        if ((n.rotate || n.rotateX || n.rotateY || n.rotateZ) && (e = !0), !e) return;\n                        const s = {};\n                        for(let e = 0; e < Ri.length; e++){\n                            const i = \"rotate\" + Ri[e];\n                            n[i] && (s[i] = n[i], t1.setStaticValue(i, 0));\n                        }\n                        t1.render();\n                        for(const e in s)t1.setStaticValue(e, s[e]);\n                        t1.scheduleRender();\n                    }\n                    getProjectionStyles(t1 = {}) {\n                        var e, n;\n                        const s = {};\n                        if (!this.instance || this.isSVG) return s;\n                        if (!this.isVisible) return {\n                            visibility: \"hidden\"\n                        };\n                        s.visibility = \"\";\n                        const i = this.getTransformTemplate();\n                        if (this.needsReset) return this.needsReset = !1, s.opacity = \"\", s.pointerEvents = In(t1.pointerEvents) || \"\", s.transform = i ? i(this.latestValues, \"\") : \"none\", s;\n                        const o = this.getLead();\n                        if (!this.projectionDelta || !this.layout || !o.target) {\n                            const e = {};\n                            return this.options.layoutId && (e.opacity = void 0 !== this.latestValues.opacity ? this.latestValues.opacity : 1, e.pointerEvents = In(t1.pointerEvents) || \"\"), this.hasProjected && !Is(this.latestValues) && (e.transform = i ? i({}, \"\") : \"none\", this.hasProjected = !1), e;\n                        }\n                        const r = o.animationValues || o.latestValues;\n                        this.applyTransformsToTarget(), s.transform = Mi(this.projectionDeltaWithTransform, this.treeScale, r), i && (s.transform = i(r, s.transform));\n                        const { x: a, y: l } = this.projectionDelta;\n                        s.transformOrigin = `${100 * a.origin}% ${100 * l.origin}% 0`, o.animationValues ? s.opacity = o === this ? null !== (n = null !== (e = r.opacity) && void 0 !== e ? e : this.latestValues.opacity) && void 0 !== n ? n : 1 : this.preserveOpacity ? this.latestValues.opacity : r.opacityExit : s.opacity = o === this ? void 0 !== r.opacity ? r.opacity : \"\" : void 0 !== r.opacityExit ? r.opacityExit : 0;\n                        for(const t1 in pn){\n                            if (void 0 === r[t1]) continue;\n                            const { correct: e, applyTo: n } = pn[t1], i = \"none\" === s.transform ? r[t1] : e(r[t1], o);\n                            if (n) {\n                                const t1 = n.length;\n                                for(let e = 0; e < t1; e++)s[n[e]] = i;\n                            } else s[t1] = i;\n                        }\n                        return this.options.layoutId && (s.pointerEvents = o === this ? In(t1.pointerEvents) || \"\" : \"none\"), s;\n                    }\n                    clearSnapshot() {\n                        this.resumeFrom = this.snapshot = void 0;\n                    }\n                    resetTree() {\n                        this.root.nodes.forEach((t1)=>{\n                            var e;\n                            return null === (e = t1.currentAnimation) || void 0 === e ? void 0 : e.stop();\n                        }), this.root.nodes.forEach($i), this.root.sharedNodes.clear();\n                    }\n                };\n            }\n            function Fi(t1) {\n                t1.updateLayout();\n            }\n            function Oi(t1) {\n                var e;\n                const n = (null === (e = t1.resumeFrom) || void 0 === e ? void 0 : e.snapshot) || t1.snapshot;\n                if (t1.isLead() && t1.layout && n && t1.hasListeners(\"didUpdate\")) {\n                    const { layoutBox: e, measuredBox: s } = t1.layout, { animationType: i } = t1.options, o = n.source !== t1.layout.source;\n                    \"size\" === i ? js((t1)=>{\n                        const s = o ? n.measuredBox[t1] : n.layoutBox[t1], i = Ts(s);\n                        s.min = e[t1].min, s.max = s.min + i;\n                    }) : no(i, n.layoutBox, e) && js((s)=>{\n                        const i = o ? n.measuredBox[s] : n.layoutBox[s], r = Ts(e[s]);\n                        i.max = i.min + r, t1.relativeTarget && !t1.currentAnimation && (t1.isProjectionDirty = !0, t1.relativeTarget[s].max = t1.relativeTarget[s].min + r);\n                    });\n                    const r = {\n                        x: {\n                            translate: 0,\n                            scale: 1,\n                            origin: 0,\n                            originPoint: 0\n                        },\n                        y: {\n                            translate: 0,\n                            scale: 1,\n                            origin: 0,\n                            originPoint: 0\n                        }\n                    };\n                    Es(r, e, n.layoutBox);\n                    const a = {\n                        x: {\n                            translate: 0,\n                            scale: 1,\n                            origin: 0,\n                            originPoint: 0\n                        },\n                        y: {\n                            translate: 0,\n                            scale: 1,\n                            origin: 0,\n                            originPoint: 0\n                        }\n                    };\n                    o ? Es(a, t1.applyTransform(s, !0), n.measuredBox) : Es(a, e, n.layoutBox);\n                    const l = !Ei(r);\n                    let u = !1;\n                    if (!t1.resumeFrom) {\n                        const s = t1.getClosestProjectingParent();\n                        if (s && !s.resumeFrom) {\n                            const { snapshot: i, layout: o } = s;\n                            if (i && o) {\n                                const r = {\n                                    x: {\n                                        min: 0,\n                                        max: 0\n                                    },\n                                    y: {\n                                        min: 0,\n                                        max: 0\n                                    }\n                                };\n                                Cs(r, n.layoutBox, i.layoutBox);\n                                const a = {\n                                    x: {\n                                        min: 0,\n                                        max: 0\n                                    },\n                                    y: {\n                                        min: 0,\n                                        max: 0\n                                    }\n                                };\n                                Cs(a, e, o.layoutBox), Ai(r, a) || (u = !0), s.options.layoutRoot && (t1.relativeTarget = a, t1.relativeTargetOrigin = r, t1.relativeParent = s);\n                            }\n                        }\n                    }\n                    t1.notifyListeners(\"didUpdate\", {\n                        layout: e,\n                        snapshot: n,\n                        delta: a,\n                        layoutDelta: r,\n                        hasLayoutChanged: l,\n                        hasRelativeTargetChanged: u\n                    });\n                } else if (t1.isLead()) {\n                    const { onExitComplete: e } = t1.options;\n                    e && e();\n                }\n                t1.options.transition = void 0;\n            }\n            function Ii(t1) {\n                ji.totalNodes++, t1.parent && (t1.isProjecting() || (t1.isProjectionDirty = t1.parent.isProjectionDirty), t1.isSharedProjectionDirty || (t1.isSharedProjectionDirty = Boolean(t1.isProjectionDirty || t1.parent.isProjectionDirty || t1.parent.isSharedProjectionDirty)), t1.isTransformDirty || (t1.isTransformDirty = t1.parent.isTransformDirty));\n            }\n            function Ui(t1) {\n                t1.isProjectionDirty = t1.isSharedProjectionDirty = t1.isTransformDirty = !1;\n            }\n            function Ni(t1) {\n                t1.clearSnapshot();\n            }\n            function $i(t1) {\n                t1.clearMeasurements();\n            }\n            function Wi(t1) {\n                t1.isLayoutDirty = !1;\n            }\n            function Hi(t1) {\n                const { visualElement: e } = t1.options;\n                e && e.getProps().onBeforeLayoutMeasure && e.notify(\"BeforeLayoutMeasure\"), t1.resetTransform();\n            }\n            function zi(t1) {\n                t1.finishAnimation(), t1.targetDelta = t1.relativeTarget = t1.target = void 0, t1.isProjectionDirty = !0;\n            }\n            function Yi(t1) {\n                t1.resolveTargetDelta();\n            }\n            function Xi(t1) {\n                t1.calcProjection();\n            }\n            function Gi(t1) {\n                t1.resetRotation();\n            }\n            function qi(t1) {\n                t1.removeLeadSnapshot();\n            }\n            function Zi(t1, e, n) {\n                t1.translate = Kt(e.translate, 0, n), t1.scale = Kt(e.scale, 1, n), t1.origin = e.origin, t1.originPoint = e.originPoint;\n            }\n            function Ki(t1, e, n, s) {\n                t1.min = Kt(e.min, n.min, s), t1.max = Kt(e.max, n.max, s);\n            }\n            function _i(t1) {\n                return t1.animationValues && void 0 !== t1.animationValues.opacityExit;\n            }\n            const Ji = {\n                duration: .45,\n                ease: [\n                    .4,\n                    0,\n                    .1,\n                    1\n                ]\n            }, Qi = (t1)=>\"undefined\" != typeof navigator && navigator.userAgent.toLowerCase().includes(t1), to = Qi(\"applewebkit/\") && !Qi(\"chrome/\") ? Math.round : n;\n            function eo(t1) {\n                t1.min = to(t1.min), t1.max = to(t1.max);\n            }\n            function no(t1, e, n) {\n                return \"position\" === t1 || \"preserve-aspect\" === t1 && !Ss(Vi(e), Vi(n), .2);\n            }\n            const so = Bi({\n                attachResizeListener: (t1, e)=>Hn(t1, \"resize\", e),\n                measureScroll: ()=>({\n                        x: document.documentElement.scrollLeft || document.body.scrollLeft,\n                        y: document.documentElement.scrollTop || document.body.scrollTop\n                    }),\n                checkIsScrollRoot: ()=>!0\n            }), io = {\n                current: void 0\n            }, oo = Bi({\n                measureScroll: (t1)=>({\n                        x: t1.scrollLeft,\n                        y: t1.scrollTop\n                    }),\n                defaultParent: ()=>{\n                    if (!io.current) {\n                        const t1 = new so({});\n                        t1.mount(window), t1.setOptions({\n                            layoutScroll: !0\n                        }), io.current = t1;\n                    }\n                    return io.current;\n                },\n                resetTransform: (t1, e)=>{\n                    t1.style.transform = void 0 !== e ? e : \"none\";\n                },\n                checkIsScrollRoot: (t1)=>Boolean(\"fixed\" === window.getComputedStyle(t1).position)\n            }), ro = {\n                pan: {\n                    Feature: class extends Jn {\n                        constructor(){\n                            super(...arguments), this.removePointerDownListener = n;\n                        }\n                        onPointerDown(t1) {\n                            this.session = new fs(t1, this.createPanHandlers(), {\n                                transformPagePoint: this.node.getTransformPagePoint()\n                            });\n                        }\n                        createPanHandlers() {\n                            const { onPanSessionStart: t1, onPanStart: e, onPan: n, onPanEnd: s } = this.node.getProps();\n                            return {\n                                onSessionStart: ei(t1),\n                                onStart: ei(e),\n                                onMove: n,\n                                onEnd: (t1, e)=>{\n                                    delete this.session, s && y.update(()=>s(t1, e));\n                                }\n                            };\n                        }\n                        mount() {\n                            this.removePointerDownListener = Xn(this.node.current, \"pointerdown\", (t1)=>this.onPointerDown(t1));\n                        }\n                        update() {\n                            this.session && this.session.updateHandlers(this.createPanHandlers());\n                        }\n                        unmount() {\n                            this.removePointerDownListener(), this.session && this.session.end();\n                        }\n                    }\n                },\n                drag: {\n                    Feature: class extends Jn {\n                        constructor(t1){\n                            super(t1), this.removeGroupControls = n, this.removeListeners = n, this.controls = new Qs(t1);\n                        }\n                        mount() {\n                            const { dragControls: t1 } = this.node.getProps();\n                            t1 && (this.removeGroupControls = t1.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || n;\n                        }\n                        unmount() {\n                            this.removeGroupControls(), this.removeListeners();\n                        }\n                    },\n                    ProjectionNode: oo,\n                    MeasureLayout: ai\n                }\n            }, ao = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\n            function lo(t1, e, n = 1) {\n                r(n <= 4, `Max CSS variable fallback depth detected in property \"${t1}\". This may indicate a circular fallback dependency.`);\n                const [s, i] = function(t1) {\n                    const e = ao.exec(t1);\n                    if (!e) return [\n                        , \n                    ];\n                    const [, n, s] = e;\n                    return [\n                        n,\n                        s\n                    ];\n                }(t1);\n                if (!s) return;\n                const o = window.getComputedStyle(e).getPropertyValue(s);\n                if (o) {\n                    const t1 = o.trim();\n                    return l(t1) ? parseFloat(t1) : t1;\n                }\n                return A(i) ? lo(i, e, n + 1) : i;\n            }\n            const uo = new Set([\n                \"width\",\n                \"height\",\n                \"top\",\n                \"left\",\n                \"right\",\n                \"bottom\",\n                \"x\",\n                \"y\",\n                \"translateX\",\n                \"translateY\"\n            ]), co = (t1)=>uo.has(t1), ho = (t1)=>t1 === L || t1 === z, mo = (t1, e)=>parseFloat(t1.split(\", \")[e]), po = (t1, e)=>(n, { transform: s })=>{\n                    if (\"none\" === s || !s) return 0;\n                    const i = s.match(/^matrix3d\\((.+)\\)$/);\n                    if (i) return mo(i[1], e);\n                    {\n                        const e = s.match(/^matrix\\((.+)\\)$/);\n                        return e ? mo(e[1], t1) : 0;\n                    }\n                }, fo = new Set([\n                \"x\",\n                \"y\",\n                \"z\"\n            ]), go = wt.filter((t1)=>!fo.has(t1)), yo = {\n                width: ({ x: t1 }, { paddingLeft: e = \"0\", paddingRight: n = \"0\" })=>t1.max - t1.min - parseFloat(e) - parseFloat(n),\n                height: ({ y: t1 }, { paddingTop: e = \"0\", paddingBottom: n = \"0\" })=>t1.max - t1.min - parseFloat(e) - parseFloat(n),\n                top: (t1, { top: e })=>parseFloat(e),\n                left: (t1, { left: e })=>parseFloat(e),\n                bottom: ({ y: t1 }, { top: e })=>parseFloat(e) + (t1.max - t1.min),\n                right: ({ x: t1 }, { left: e })=>parseFloat(e) + (t1.max - t1.min),\n                x: po(4, 13),\n                y: po(5, 14)\n            };\n            yo.translateX = yo.x, yo.translateY = yo.y;\n            function vo(t1, e, n, s) {\n                return ((t1)=>Object.keys(t1).some(co))(e) ? ((t1, e, n = {}, s = {})=>{\n                    e = {\n                        ...e\n                    }, s = {\n                        ...s\n                    };\n                    const i = Object.keys(e).filter(co);\n                    let o = [], a = !1;\n                    const l = [];\n                    if (i.forEach((i)=>{\n                        const u = t1.getValue(i);\n                        if (!t1.hasValue(i)) return;\n                        let h = n[i], d = gt(h);\n                        const m = e[i];\n                        let p;\n                        if (c(m)) {\n                            const t1 = m.length, e = null === m[0] ? 1 : 0;\n                            h = m[e], d = gt(h);\n                            for(let n = e; n < t1 && null !== m[n]; n++)p ? r(gt(m[n]) === p, \"All keyframes must be of the same type\") : (p = gt(m[n]), r(p === d || ho(d) && ho(p), \"Keyframes must be of the same dimension as the current value\"));\n                        } else p = gt(m);\n                        if (d !== p) if (ho(d) && ho(p)) {\n                            const t1 = u.get();\n                            \"string\" == typeof t1 && u.set(parseFloat(t1)), \"string\" == typeof m ? e[i] = parseFloat(m) : Array.isArray(m) && p === z && (e[i] = m.map(parseFloat));\n                        } else (null == d ? void 0 : d.transform) && (null == p ? void 0 : p.transform) && (0 === h || 0 === m) ? 0 === h ? u.set(p.transform(h)) : e[i] = d.transform(m) : (a || (o = function(t1) {\n                            const e = [];\n                            return go.forEach((n)=>{\n                                const s = t1.getValue(n);\n                                void 0 !== s && (e.push([\n                                    n,\n                                    s.get()\n                                ]), s.set(n.startsWith(\"scale\") ? 1 : 0));\n                            }), e.length && t1.render(), e;\n                        }(t1), a = !0), l.push(i), s[i] = void 0 !== s[i] ? s[i] : e[i], u.jump(m));\n                    }), l.length) {\n                        const n = l.indexOf(\"height\") >= 0 ? window.pageYOffset : null, i = ((t1, e, n)=>{\n                            const s = e.measureViewportBox(), i = e.current, o = getComputedStyle(i), { display: r } = o, a = {};\n                            \"none\" === r && e.setStaticValue(\"display\", t1.display || \"block\"), n.forEach((t1)=>{\n                                a[t1] = yo[t1](s, o);\n                            }), e.render();\n                            const l = e.measureViewportBox();\n                            return n.forEach((n)=>{\n                                const s = e.getValue(n);\n                                s && s.jump(a[n]), t1[n] = yo[n](l, o);\n                            }), t1;\n                        })(e, t1, l);\n                        return o.length && o.forEach(([e, n])=>{\n                            t1.getValue(e).set(n);\n                        }), t1.render(), He && null !== n && window.scrollTo({\n                            top: n\n                        }), {\n                            target: i,\n                            transitionEnd: s\n                        };\n                    }\n                    return {\n                        target: e,\n                        transitionEnd: s\n                    };\n                })(t1, e, n, s) : {\n                    target: e,\n                    transitionEnd: s\n                };\n            }\n            const xo = {\n                current: null\n            }, Po = {\n                current: !1\n            }, bo = new WeakMap, To = Object.keys(on), So = To.length, wo = [\n                \"AnimationStart\",\n                \"AnimationComplete\",\n                \"Update\",\n                \"BeforeLayoutMeasure\",\n                \"LayoutMeasure\",\n                \"LayoutAnimationStart\",\n                \"LayoutAnimationComplete\"\n            ], Eo = Qe.length;\n            class Ao extends class {\n                constructor({ parent: t1, props: e, presenceContext: n, reducedMotionConfig: s, visualState: i }, o = {}){\n                    this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = ()=>this.notify(\"Update\", this.latestValues), this.render = ()=>{\n                        this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));\n                    }, this.scheduleRender = ()=>y.render(this.render, !1, !0);\n                    const { latestValues: r, renderState: a } = i;\n                    this.latestValues = r, this.baseTarget = {\n                        ...r\n                    }, this.initialValues = e.initial ? {\n                        ...r\n                    } : {}, this.renderState = a, this.parent = t1, this.props = e, this.presenceContext = n, this.depth = t1 ? t1.depth + 1 : 0, this.reducedMotionConfig = s, this.options = o, this.isControllingVariants = tn(e), this.isVariantNode = en(e), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = Boolean(t1 && t1.current);\n                    const { willChange: l, ...u } = this.scrapeMotionValuesFromProps(e, {});\n                    for(const t1 in u){\n                        const e = u[t1];\n                        void 0 !== r[t1] && je(e) && (e.set(r[t1], !1), Be(l) && l.add(t1));\n                    }\n                }\n                scrapeMotionValuesFromProps(t1, e) {\n                    return {};\n                }\n                mount(t1) {\n                    this.current = t1, bo.set(t1, this), this.projection && !this.projection.instance && this.projection.mount(t1), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((t1, e)=>this.bindToMotionValue(e, t1)), Po.current || function() {\n                        if (Po.current = !0, He) if (window.matchMedia) {\n                            const t1 = window.matchMedia(\"(prefers-reduced-motion)\"), e = ()=>xo.current = t1.matches;\n                            t1.addListener(e), e();\n                        } else xo.current = !1;\n                    }(), this.shouldReduceMotion = \"never\" !== this.reducedMotionConfig && (\"always\" === this.reducedMotionConfig || xo.current), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);\n                }\n                unmount() {\n                    bo.delete(this.current), this.projection && this.projection.unmount(), v(this.notifyUpdate), v(this.render), this.valueSubscriptions.forEach((t1)=>t1()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);\n                    for(const t1 in this.events)this.events[t1].clear();\n                    for(const t1 in this.features)this.features[t1].unmount();\n                    this.current = null;\n                }\n                bindToMotionValue(t1, e) {\n                    const n = Et.has(t1), s = e.on(\"change\", (e)=>{\n                        this.latestValues[t1] = e, this.props.onUpdate && y.update(this.notifyUpdate, !1, !0), n && this.projection && (this.projection.isTransformDirty = !0);\n                    }), i = e.on(\"renderRequest\", this.scheduleRender);\n                    this.valueSubscriptions.set(t1, ()=>{\n                        s(), i();\n                    });\n                }\n                sortNodePosition(t1) {\n                    return this.current && this.sortInstanceNodePosition && this.type === t1.type ? this.sortInstanceNodePosition(this.current, t1.current) : 0;\n                }\n                loadFeatures({ children: t1, ...e }, n, s, i) {\n                    let o, r;\n                    for(let t1 = 0; t1 < So; t1++){\n                        const n = To[t1], { isEnabled: s, Feature: i, ProjectionNode: a, MeasureLayout: l } = on[n];\n                        a && (o = a), s(e) && (!this.features[n] && i && (this.features[n] = new i(this)), l && (r = l));\n                    }\n                    if (!this.projection && o) {\n                        this.projection = new o(this.latestValues, this.parent && this.parent.projection);\n                        const { layoutId: t1, layout: n, drag: s, dragConstraints: r, layoutScroll: a, layoutRoot: l } = e;\n                        this.projection.setOptions({\n                            layoutId: t1,\n                            layout: n,\n                            alwaysMeasureLayout: Boolean(s) || r && Ze(r),\n                            visualElement: this,\n                            scheduleRender: ()=>this.scheduleRender(),\n                            animationType: \"string\" == typeof n ? n : \"both\",\n                            initialPromotionConfig: i,\n                            layoutScroll: a,\n                            layoutRoot: l\n                        });\n                    }\n                    return r;\n                }\n                updateFeatures() {\n                    for(const t1 in this.features){\n                        const e = this.features[t1];\n                        e.isMounted ? e.update() : (e.mount(), e.isMounted = !0);\n                    }\n                }\n                triggerBuild() {\n                    this.build(this.renderState, this.latestValues, this.options, this.props);\n                }\n                measureViewportBox() {\n                    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : {\n                        x: {\n                            min: 0,\n                            max: 0\n                        },\n                        y: {\n                            min: 0,\n                            max: 0\n                        }\n                    };\n                }\n                getStaticValue(t1) {\n                    return this.latestValues[t1];\n                }\n                setStaticValue(t1, e) {\n                    this.latestValues[t1] = e;\n                }\n                makeTargetAnimatable(t1, e = !0) {\n                    return this.makeTargetAnimatableFromInstance(t1, this.props, e);\n                }\n                update(t1, e) {\n                    (t1.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t1, this.prevPresenceContext = this.presenceContext, this.presenceContext = e;\n                    for(let e = 0; e < wo.length; e++){\n                        const n = wo[e];\n                        this.propEventSubscriptions[n] && (this.propEventSubscriptions[n](), delete this.propEventSubscriptions[n]);\n                        const s = t1[\"on\" + n];\n                        s && (this.propEventSubscriptions[n] = this.on(n, s));\n                    }\n                    this.prevMotionValues = function(t1, e, n) {\n                        const { willChange: s } = e;\n                        for(const i in e){\n                            const o = e[i], r = n[i];\n                            if (je(o)) t1.addValue(i, o), Be(s) && s.add(i);\n                            else if (je(r)) t1.addValue(i, S(o, {\n                                owner: t1\n                            })), Be(s) && s.remove(i);\n                            else if (r !== o) if (t1.hasValue(i)) {\n                                const e = t1.getValue(i);\n                                !e.hasAnimated && e.set(o);\n                            } else {\n                                const e = t1.getStaticValue(i);\n                                t1.addValue(i, S(void 0 !== e ? e : o, {\n                                    owner: t1\n                                }));\n                            }\n                        }\n                        for(const s in n)void 0 === e[s] && t1.removeValue(s);\n                        return e;\n                    }(this, this.scrapeMotionValuesFromProps(t1, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();\n                }\n                getProps() {\n                    return this.props;\n                }\n                getVariant(t1) {\n                    return this.props.variants ? this.props.variants[t1] : void 0;\n                }\n                getDefaultTransition() {\n                    return this.props.transition;\n                }\n                getTransformPagePoint() {\n                    return this.props.transformPagePoint;\n                }\n                getClosestVariantNode() {\n                    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;\n                }\n                getVariantContext(t1 = !1) {\n                    if (t1) return this.parent ? this.parent.getVariantContext() : void 0;\n                    if (!this.isControllingVariants) {\n                        const t1 = this.parent && this.parent.getVariantContext() || {};\n                        return void 0 !== this.props.initial && (t1.initial = this.props.initial), t1;\n                    }\n                    const e = {};\n                    for(let t1 = 0; t1 < Eo; t1++){\n                        const n = Qe[t1], s = this.props[n];\n                        (Ke(s) || !1 === s) && (e[n] = s);\n                    }\n                    return e;\n                }\n                addVariantChild(t1) {\n                    const e = this.getClosestVariantNode();\n                    if (e) return e.variantChildren && e.variantChildren.add(t1), ()=>e.variantChildren.delete(t1);\n                }\n                addValue(t1, e) {\n                    e !== this.values.get(t1) && (this.removeValue(t1), this.bindToMotionValue(t1, e)), this.values.set(t1, e), this.latestValues[t1] = e.get();\n                }\n                removeValue(t1) {\n                    this.values.delete(t1);\n                    const e = this.valueSubscriptions.get(t1);\n                    e && (e(), this.valueSubscriptions.delete(t1)), delete this.latestValues[t1], this.removeValueFromRenderState(t1, this.renderState);\n                }\n                hasValue(t1) {\n                    return this.values.has(t1);\n                }\n                getValue(t1, e) {\n                    if (this.props.values && this.props.values[t1]) return this.props.values[t1];\n                    let n = this.values.get(t1);\n                    return void 0 === n && void 0 !== e && (n = S(e, {\n                        owner: this\n                    }), this.addValue(t1, n)), n;\n                }\n                readValue(t1) {\n                    var e;\n                    return void 0 === this.latestValues[t1] && this.current ? null !== (e = this.getBaseTargetFromProps(this.props, t1)) && void 0 !== e ? e : this.readValueFromInstance(this.current, t1, this.options) : this.latestValues[t1];\n                }\n                setBaseTarget(t1, e) {\n                    this.baseTarget[t1] = e;\n                }\n                getBaseTarget(t1) {\n                    var e;\n                    const { initial: n } = this.props, s = \"string\" == typeof n || \"object\" == typeof n ? null === (e = vt(this.props, n)) || void 0 === e ? void 0 : e[t1] : void 0;\n                    if (n && void 0 !== s) return s;\n                    const i = this.getBaseTargetFromProps(this.props, t1);\n                    return void 0 === i || je(i) ? void 0 !== this.initialValues[t1] && void 0 === s ? void 0 : this.baseTarget[t1] : i;\n                }\n                on(t1, e) {\n                    return this.events[t1] || (this.events[t1] = new m), this.events[t1].add(e);\n                }\n                notify(t1, ...e) {\n                    this.events[t1] && this.events[t1].notify(...e);\n                }\n            } {\n                sortInstanceNodePosition(t1, e) {\n                    return 2 & t1.compareDocumentPosition(e) ? 1 : -1;\n                }\n                getBaseTargetFromProps(t1, e) {\n                    return t1.style ? t1.style[e] : void 0;\n                }\n                removeValueFromRenderState(t1, { vars: e, style: n }) {\n                    delete e[t1], delete n[t1];\n                }\n                makeTargetAnimatableFromInstance({ transition: t1, transitionEnd: e, ...n }, { transformValues: s }, i) {\n                    let o = function(t1, e, n) {\n                        const s = {};\n                        for(const i in t1){\n                            const t1 = St(i, e);\n                            if (void 0 !== t1) s[i] = t1;\n                            else {\n                                const t1 = n.getValue(i);\n                                t1 && (s[i] = t1.get());\n                            }\n                        }\n                        return s;\n                    }(n, t1 || {}, this);\n                    if (s && (e && (e = s(e)), n && (n = s(n)), o && (o = s(o))), i) {\n                        !function(t1, e, n) {\n                            var s, i;\n                            const o = Object.keys(e).filter((e)=>!t1.hasValue(e)), r = o.length;\n                            var a;\n                            if (r) for(let c = 0; c < r; c++){\n                                const r = o[c], h = e[r];\n                                let d = null;\n                                Array.isArray(h) && (d = h[0]), null === d && (d = null !== (i = null !== (s = n[r]) && void 0 !== s ? s : t1.readValue(r)) && void 0 !== i ? i : e[r]), null != d && (\"string\" == typeof d && (l(d) || u(d)) ? d = parseFloat(d) : (a = d, !yt.find(pt(a)) && it.test(h) && (d = mt(r, h))), t1.addValue(r, S(d, {\n                                    owner: t1\n                                })), void 0 === n[r] && (n[r] = d), null !== d && t1.setBaseTarget(r, d));\n                            }\n                        }(this, n, o);\n                        const t1 = ((t1, e, n, s)=>{\n                            const i = function(t1, { ...e }, n) {\n                                const s = t1.current;\n                                if (!(s instanceof Element)) return {\n                                    target: e,\n                                    transitionEnd: n\n                                };\n                                n && (n = {\n                                    ...n\n                                }), t1.values.forEach((t1)=>{\n                                    const e = t1.get();\n                                    if (!A(e)) return;\n                                    const n = lo(e, s);\n                                    n && t1.set(n);\n                                });\n                                for(const t1 in e){\n                                    const i = e[t1];\n                                    if (!A(i)) continue;\n                                    const o = lo(i, s);\n                                    o && (e[t1] = o, n || (n = {}), void 0 === n[t1] && (n[t1] = i));\n                                }\n                                return {\n                                    target: e,\n                                    transitionEnd: n\n                                };\n                            }(t1, e, s);\n                            return vo(t1, e = i.target, n, s = i.transitionEnd);\n                        })(this, n, o, e);\n                        e = t1.transitionEnd, n = t1.target;\n                    }\n                    return {\n                        transition: t1,\n                        transitionEnd: e,\n                        ...n\n                    };\n                }\n            }\n            class Vo extends Ao {\n                readValueFromInstance(t1, e) {\n                    if (Et.has(e)) {\n                        const t1 = dt(e);\n                        return t1 && t1.default || 0;\n                    }\n                    {\n                        const s = (n = t1, window.getComputedStyle(n)), i = (E(e) ? s.getPropertyValue(e) : s[e]) || 0;\n                        return \"string\" == typeof i ? i.trim() : i;\n                    }\n                    var n;\n                }\n                measureInstanceViewportBox(t1, { transformPagePoint: e }) {\n                    return _s(t1, e);\n                }\n                build(t1, e, n, s) {\n                    xn(t1, e, n, s.transformTemplate);\n                }\n                scrapeMotionValuesFromProps(t1, e) {\n                    return Fn(t1, e);\n                }\n                handleChildMotionValue() {\n                    this.childSubscription && (this.childSubscription(), delete this.childSubscription);\n                    const { children: t1 } = this.props;\n                    je(t1) && (this.childSubscription = t1.on(\"change\", (t1)=>{\n                        this.current && (this.current.textContent = `${t1}`);\n                    }));\n                }\n                renderInstance(t1, e, n, s) {\n                    Ln(t1, e, n, s);\n                }\n            }\n            class Co extends Ao {\n                constructor(){\n                    super(...arguments), this.isSVGTag = !1;\n                }\n                getBaseTargetFromProps(t1, e) {\n                    return t1[e];\n                }\n                readValueFromInstance(t1, e) {\n                    if (Et.has(e)) {\n                        const t1 = dt(e);\n                        return t1 && t1.default || 0;\n                    }\n                    return e = jn.has(e) ? e : At(e), t1.getAttribute(e);\n                }\n                measureInstanceViewportBox() {\n                    return {\n                        x: {\n                            min: 0,\n                            max: 0\n                        },\n                        y: {\n                            min: 0,\n                            max: 0\n                        }\n                    };\n                }\n                scrapeMotionValuesFromProps(t1, e) {\n                    return On(t1, e);\n                }\n                build(t1, e, n, s) {\n                    Mn(t1, e, n, this.isSVGTag, s.transformTemplate);\n                }\n                renderInstance(t1, e, n, s) {\n                    Bn(t1, e, 0, s);\n                }\n                mount(t1) {\n                    this.isSVGTag = Dn(t1.tagName), super.mount(t1);\n                }\n            }\n            const Mo = (t1, e)=>mn(t1) ? new Co(e, {\n                    enableHardwareAcceleration: !1\n                }) : new Vo(e, {\n                    enableHardwareAcceleration: !0\n                }), Do = {\n                ...ms,\n                ...as,\n                ...ro,\n                layout: {\n                    ProjectionNode: oo,\n                    MeasureLayout: ai\n                }\n            }, ko = hn((t1, e)=>(function(t1, { forwardMotionProps: e = !1 }, n, s) {\n                    return {\n                        ...mn(t1) ? $n : Wn,\n                        preloadedFeatures: n,\n                        useRender: Rn(e),\n                        createVisualElement: s,\n                        Component: t1\n                    };\n                })(t1, e, Do, Mo)), Ro = [\n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6,\n                7,\n                8,\n                9,\n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6,\n                7,\n                8,\n                9,\n                0,\n                1,\n                2,\n                3,\n                4,\n                5,\n                6,\n                7,\n                8,\n                9\n            ], Lo = ({ className: n, animateToNumber: s, fontStyle: i, transitions: o, includeComma: r, locale: l })=>{\n                const u = e().useRef(null), c = function(e, { root: n, margin: s, amount: i, once: o = !1 } = {}) {\n                    const [r, l] = (0, t1.useState)(!1);\n                    return (0, t1.useEffect)(()=>{\n                        if (!e.current || o && r) return;\n                        const t1 = {\n                            root: n && n.current || void 0,\n                            margin: s,\n                            amount: i\n                        };\n                        return function(t1, e, { root: n, margin: s, amount: i = \"some\" } = {}) {\n                            const o = function(t1, e, n) {\n                                if (\"string\" == typeof t1) {\n                                    t1 = document.querySelectorAll(t1);\n                                } else t1 instanceof Element && (t1 = [\n                                    t1\n                                ]);\n                                return Array.from(t1 || []);\n                            }(t1), r = new WeakMap, l = new IntersectionObserver((t1)=>{\n                                t1.forEach((t1)=>{\n                                    const n = r.get(t1.target);\n                                    if (t1.isIntersecting !== Boolean(n)) if (t1.isIntersecting) {\n                                        const n = e(t1);\n                                        \"function\" == typeof n ? r.set(t1.target, n) : l.unobserve(t1.target);\n                                    } else n && (n(t1), r.delete(t1.target));\n                                });\n                            }, {\n                                root: n,\n                                rootMargin: s,\n                                threshold: \"number\" == typeof i ? i : a[i]\n                            });\n                            return o.forEach((t1)=>l.observe(t1)), ()=>l.disconnect();\n                        }(e.current, ()=>(l(!0), o ? void 0 : ()=>l(!1)), t1);\n                    }, [\n                        n,\n                        e,\n                        s,\n                        o\n                    ]), r;\n                }(u, {\n                    once: !0\n                }), h = function() {\n                    const t1 = We($e);\n                    return ze(t1.mount, []), t1;\n                }(), d = e().useRef(0), m = r ? Math.abs(s).toLocaleString(l || \"en-US\") : String(Math.abs(s)), p = Array.from(m, Number).map((t1, e)=>isNaN(t1) ? m[e] : t1), [f, g] = e().useState(0), y = e().useRef(null);\n                return e().useEffect(()=>{\n                    var t1, e;\n                    const n = null === (t1 = y.current.getClientRects()) || void 0 === t1 || null === (e = t1[0]) || void 0 === e ? void 0 : e.height;\n                    n && g(n);\n                }, [\n                    s,\n                    i\n                ]), e().useEffect(()=>{\n                    c && h.start(\"visible\");\n                }, [\n                    c,\n                    s\n                ]), e().createElement(\"span\", {\n                    ref: u\n                }, 0 !== f && e().createElement(\"div\", {\n                    style: {\n                        display: \"flex\",\n                        flexDirection: \"row\",\n                        overflow: \"hidden\"\n                    },\n                    className: n\n                }, p.map((t1, n)=>\"string\" == typeof t1 ? e().createElement(\"div\", {\n                        key: n,\n                        style: {\n                            ...i,\n                            fontVariantNumeric: \"tabular-nums\"\n                        }\n                    }, t1) : e().createElement(\"div\", {\n                        key: n,\n                        style: {\n                            height: f\n                        }\n                    }, Ro.map((t1)=>e().createElement(ko.div, {\n                            style: {\n                                ...i,\n                                fontVariantNumeric: \"tabular-nums\"\n                            },\n                            key: \"\" + d.current++,\n                            initial: \"hidden\",\n                            variants: {\n                                hidden: {\n                                    y: 0\n                                },\n                                visible: {\n                                    y: f * p[n] * -1 - 20 * f\n                                }\n                            },\n                            animate: h,\n                            transition: null == o ? void 0 : o(n)\n                        }, t1))))), e().createElement(\"div\", {\n                    ref: y,\n                    style: {\n                        position: \"absolute\",\n                        top: -9999,\n                        ...i\n                    }\n                }, 0));\n            }, jo = e().memo(Lo, (t1, e)=>t1.animateToNumber === e.animateToNumber && t1.fontStyle === e.fontStyle && t1.includeComma === e.includeComma);\n        })(), i;\n    })();\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtYW5pbWF0ZWQtbnVtYmVycy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxDQUFDLFNBQVNBLEVBQUMsRUFBQ0MsQ0FBQztJQUFFLElBQUcsSUFBaURFLEVBQUNBLE9BQU9ELE9BQU8sR0FBQ0QsRUFBRUcsbUJBQU9BLENBQUMsd0dBQU87U0FBUSxhQUE0TDtBQUFBLEVBQUVNLE1BQU0sU0FBU1YsRUFBQztJQUFFLE9BQU0sQ0FBQztRQUFLO1FBQWEsSUFBSUMsSUFBRTtZQUFDLEtBQUlBLENBQUFBO2dCQUFJQSxFQUFFQyxPQUFPLEdBQUNGO1lBQUM7UUFBQyxHQUFFTyxJQUFFLENBQUM7UUFBRSxTQUFTRSxFQUFFVCxFQUFDO1lBQUUsSUFBSVcsSUFBRUosQ0FBQyxDQUFDUCxHQUFFO1lBQUMsSUFBRyxLQUFLLE1BQUlXLEdBQUUsT0FBT0EsRUFBRVQsT0FBTztZQUFDLElBQUlVLElBQUVMLENBQUMsQ0FBQ1AsR0FBRSxHQUFDO2dCQUFDRSxTQUFRLENBQUM7WUFBQztZQUFFLE9BQU9ELENBQUMsQ0FBQ0QsR0FBRSxDQUFDWSxHQUFFQSxFQUFFVixPQUFPLEVBQUNPLElBQUdHLEVBQUVWLE9BQU87UUFBQTtRQUFDTyxFQUFFRixDQUFDLEdBQUNQLENBQUFBO1lBQUksSUFBSUMsSUFBRUQsTUFBR0EsR0FBRWEsVUFBVSxHQUFDLElBQUliLEdBQUVjLE9BQU8sR0FBQyxJQUFJZDtZQUFFLE9BQU9TLEVBQUVNLENBQUMsQ0FBQ2QsR0FBRTtnQkFBQ2UsR0FBRWY7WUFBQyxJQUFHQTtRQUFDLEdBQUVRLEVBQUVNLENBQUMsR0FBQyxDQUFDZixJQUFFQztZQUFLLElBQUksSUFBSU0sS0FBS04sRUFBRVEsRUFBRUcsQ0FBQyxDQUFDWCxHQUFFTSxNQUFJLENBQUNFLEVBQUVHLENBQUMsQ0FBQ1osSUFBRU8sTUFBSVUsT0FBT0MsY0FBYyxDQUFDbEIsSUFBRU8sR0FBRTtnQkFBQ1ksWUFBVyxDQUFDO2dCQUFF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YUFBYSxDQUFDMmpCLEdBQUdtQixHQUFHLEVBQUM7NEJBQUM5akIsT0FBTTtnQ0FBQyxHQUFHdmhCLENBQUM7Z0NBQUNvbEMsb0JBQW1COzRCQUFjOzRCQUFFdGIsS0FBSSxLQUFHMXBCLEVBQUVpRSxPQUFPOzRCQUFHa2IsU0FBUTs0QkFBU2hQLFVBQVM7Z0NBQUMrMEIsUUFBTztvQ0FBQ3RpQyxHQUFFO2dDQUFDO2dDQUFFdWlDLFNBQVE7b0NBQUN2aUMsR0FBRVQsSUFBRUQsQ0FBQyxDQUFDMUMsRUFBRSxHQUFDLENBQUMsSUFBRSxLQUFHMkM7Z0NBQUM7NEJBQUM7NEJBQUUrWCxTQUFRNVk7NEJBQUVzUCxZQUFXLFFBQU0vUSxJQUFFLEtBQUssSUFBRUEsRUFBRUw7d0JBQUUsR0FBRVAsU0FBU0MsSUFBSWloQixhQUFhLENBQUMsT0FBTTtvQkFBQzJELEtBQUlsaEI7b0JBQUV1ZSxPQUFNO3dCQUFDOGQsVUFBUzt3QkFBVzN5QixLQUFJLENBQUM7d0JBQUssR0FBRzFNLENBQUM7b0JBQUE7Z0JBQUMsR0FBRTtZQUFHLEdBQUVpQixLQUFHM0IsSUFBSWttQyxJQUFJLENBQUNuQixJQUFJLENBQUNobEMsSUFBRUMsSUFBSUQsR0FBRWtsQyxlQUFlLEtBQUdqbEMsRUFBRWlsQyxlQUFlLElBQUVsbEMsR0FBRW1sQyxTQUFTLEtBQUdsbEMsRUFBRWtsQyxTQUFTLElBQUVubEMsR0FBRXFsQyxZQUFZLEtBQUdwbEMsRUFBRW9sQyxZQUFZO1FBQUUsTUFBSzFrQztJQUFDO0FBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1wZXJzb25hbC1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvcmVhY3QtYW5pbWF0ZWQtbnVtYmVycy9kaXN0L2luZGV4LmpzPzg0MDYiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKHQsZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZShyZXF1aXJlKFwicmVhY3RcIikpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXCJyZWFjdFwiXSxlKTtlbHNle3ZhciBuPVwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2UocmVxdWlyZShcInJlYWN0XCIpKTplKHQucmVhY3QpO2Zvcih2YXIgcyBpbiBuKShcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzOnQpW3NdPW5bc119fShzZWxmLChmdW5jdGlvbih0KXtyZXR1cm4oKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17Mjk3OmU9PntlLmV4cG9ydHM9dH19LG49e307ZnVuY3Rpb24gcyh0KXt2YXIgaT1uW3RdO2lmKHZvaWQgMCE9PWkpcmV0dXJuIGkuZXhwb3J0czt2YXIgbz1uW3RdPXtleHBvcnRzOnt9fTtyZXR1cm4gZVt0XShvLG8uZXhwb3J0cyxzKSxvLmV4cG9ydHN9cy5uPXQ9Pnt2YXIgZT10JiZ0Ll9fZXNNb2R1bGU/KCk9PnQuZGVmYXVsdDooKT0+dDtyZXR1cm4gcy5kKGUse2E6ZX0pLGV9LHMuZD0odCxlKT0+e2Zvcih2YXIgbiBpbiBlKXMubyhlLG4pJiYhcy5vKHQsbikmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4se2VudW1lcmFibGU6ITAsZ2V0OmVbbl19KX0scy5vPSh0LGUpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSxzLnI9dD0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9O3ZhciBpPXt9O3JldHVybigoKT0+e3MucihpKSxzLmQoaSx7ZGVmYXVsdDooKT0+am99KTt2YXIgdD1zKDI5NyksZT1zLm4odCk7Y29uc3Qgbj10PT50O2xldCBvPW4scj1uO2NvbnN0IGE9e3NvbWU6MCxhbGw6MX07Y29uc3QgbD10PT4vXlxcLT9cXGQqXFwuP1xcZCskLy50ZXN0KHQpLHU9dD0+L14wW14uXFxzXSskLy50ZXN0KHQpLGM9dD0+QXJyYXkuaXNBcnJheSh0KTtmdW5jdGlvbiBoKHQsZSl7LTE9PT10LmluZGV4T2YoZSkmJnQucHVzaChlKX1mdW5jdGlvbiBkKHQsZSl7Y29uc3Qgbj10LmluZGV4T2YoZSk7bj4tMSYmdC5zcGxpY2UobiwxKX1jbGFzcyBte2NvbnN0cnVjdG9yKCl7dGhpcy5zdWJzY3JpcHRpb25zPVtdfWFkZCh0KXtyZXR1cm4gaCh0aGlzLnN1YnNjcmlwdGlvbnMsdCksKCk9PmQodGhpcy5zdWJzY3JpcHRpb25zLHQpfW5vdGlmeSh0LGUsbil7Y29uc3Qgcz10aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoO2lmKHMpaWYoMT09PXMpdGhpcy5zdWJzY3JpcHRpb25zWzBdKHQsZSxuKTtlbHNlIGZvcihsZXQgaT0wO2k8cztpKyspe2NvbnN0IHM9dGhpcy5zdWJzY3JpcHRpb25zW2ldO3MmJnModCxlLG4pfX1nZXRTaXplKCl7cmV0dXJuIHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGh9Y2xlYXIoKXt0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoPTB9fWZ1bmN0aW9uIHAodCxlKXtyZXR1cm4gZT90KigxZTMvZSk6MH1jbGFzcyBme2NvbnN0cnVjdG9yKCl7dGhpcy5vcmRlcj1bXSx0aGlzLnNjaGVkdWxlZD1uZXcgU2V0fWFkZCh0KXtpZighdGhpcy5zY2hlZHVsZWQuaGFzKHQpKXJldHVybiB0aGlzLnNjaGVkdWxlZC5hZGQodCksdGhpcy5vcmRlci5wdXNoKHQpLCEwfXJlbW92ZSh0KXtjb25zdCBlPXRoaXMub3JkZXIuaW5kZXhPZih0KTstMSE9PWUmJih0aGlzLm9yZGVyLnNwbGljZShlLDEpLHRoaXMuc2NoZWR1bGVkLmRlbGV0ZSh0KSl9Y2xlYXIoKXt0aGlzLm9yZGVyLmxlbmd0aD0wLHRoaXMuc2NoZWR1bGVkLmNsZWFyKCl9fWNvbnN0IGc9W1wicHJlcGFyZVwiLFwicmVhZFwiLFwidXBkYXRlXCIsXCJwcmVSZW5kZXJcIixcInJlbmRlclwiLFwicG9zdFJlbmRlclwiXSx7c2NoZWR1bGU6eSxjYW5jZWw6dixzdGF0ZTp4LHN0ZXBzOlB9PWZ1bmN0aW9uKHQsZSl7bGV0IG49ITEscz0hMDtjb25zdCBpPXtkZWx0YTowLHRpbWVzdGFtcDowLGlzUHJvY2Vzc2luZzohMX0sbz1nLnJlZHVjZSgoKHQsZSk9Pih0W2VdPWZ1bmN0aW9uKHQpe2xldCBlPW5ldyBmLG49bmV3IGYscz0wLGk9ITEsbz0hMTtjb25zdCByPW5ldyBXZWFrU2V0LGE9e3NjaGVkdWxlOih0LG89ITEsYT0hMSk9Pntjb25zdCBsPWEmJmksdT1sP2U6bjtyZXR1cm4gbyYmci5hZGQodCksdS5hZGQodCkmJmwmJmkmJihzPWUub3JkZXIubGVuZ3RoKSx0fSxjYW5jZWw6dD0+e24ucmVtb3ZlKHQpLHIuZGVsZXRlKHQpfSxwcm9jZXNzOmw9PntpZihpKW89ITA7ZWxzZXtpZihpPSEwLFtlLG5dPVtuLGVdLG4uY2xlYXIoKSxzPWUub3JkZXIubGVuZ3RoLHMpZm9yKGxldCBuPTA7bjxzO24rKyl7Y29uc3Qgcz1lLm9yZGVyW25dO3MobCksci5oYXMocykmJihhLnNjaGVkdWxlKHMpLHQoKSl9aT0hMSxvJiYobz0hMSxhLnByb2Nlc3MobCkpfX19O3JldHVybiBhfSgoKCk9Pm49ITApKSx0KSkse30pLHI9dD0+b1t0XS5wcm9jZXNzKGkpLGE9KCk9Pntjb25zdCBlPXBlcmZvcm1hbmNlLm5vdygpO249ITEsaS5kZWx0YT1zPzFlMy82MDpNYXRoLm1heChNYXRoLm1pbihlLWkudGltZXN0YW1wLDQwKSwxKSxpLnRpbWVzdGFtcD1lLGkuaXNQcm9jZXNzaW5nPSEwLGcuZm9yRWFjaChyKSxpLmlzUHJvY2Vzc2luZz0hMSxuJiYocz0hMSx0KGEpKX07cmV0dXJue3NjaGVkdWxlOmcucmVkdWNlKCgoZSxyKT0+e2NvbnN0IGw9b1tyXTtyZXR1cm4gZVtyXT0oZSxvPSExLHI9ITEpPT4obnx8KG49ITAscz0hMCxpLmlzUHJvY2Vzc2luZ3x8dChhKSksbC5zY2hlZHVsZShlLG8scikpLGV9KSx7fSksY2FuY2VsOnQ9PmcuZm9yRWFjaCgoZT0+b1tlXS5jYW5jZWwodCkpKSxzdGF0ZTppLHN0ZXBzOm99fShcInVuZGVmaW5lZFwiIT10eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lP3JlcXVlc3RBbmltYXRpb25GcmFtZTpuKSxiPXtjdXJyZW50OnZvaWQgMH07Y2xhc3MgVHtjb25zdHJ1Y3Rvcih0LGU9e30pe3ZhciBuO3RoaXMudmVyc2lvbj1cIjEwLjE2LjVcIix0aGlzLnRpbWVEZWx0YT0wLHRoaXMubGFzdFVwZGF0ZWQ9MCx0aGlzLmNhblRyYWNrVmVsb2NpdHk9ITEsdGhpcy5ldmVudHM9e30sdGhpcy51cGRhdGVBbmROb3RpZnk9KHQsZT0hMCk9Pnt0aGlzLnByZXY9dGhpcy5jdXJyZW50LHRoaXMuY3VycmVudD10O2NvbnN0e2RlbHRhOm4sdGltZXN0YW1wOnN9PXg7dGhpcy5sYXN0VXBkYXRlZCE9PXMmJih0aGlzLnRpbWVEZWx0YT1uLHRoaXMubGFzdFVwZGF0ZWQ9cyx5LnBvc3RSZW5kZXIodGhpcy5zY2hlZHVsZVZlbG9jaXR5Q2hlY2spKSx0aGlzLnByZXYhPT10aGlzLmN1cnJlbnQmJnRoaXMuZXZlbnRzLmNoYW5nZSYmdGhpcy5ldmVudHMuY2hhbmdlLm5vdGlmeSh0aGlzLmN1cnJlbnQpLHRoaXMuZXZlbnRzLnZlbG9jaXR5Q2hhbmdlJiZ0aGlzLmV2ZW50cy52ZWxvY2l0eUNoYW5nZS5ub3RpZnkodGhpcy5nZXRWZWxvY2l0eSgpKSxlJiZ0aGlzLmV2ZW50cy5yZW5kZXJSZXF1ZXN0JiZ0aGlzLmV2ZW50cy5yZW5kZXJSZXF1ZXN0Lm5vdGlmeSh0aGlzLmN1cnJlbnQpfSx0aGlzLnNjaGVkdWxlVmVsb2NpdHlDaGVjaz0oKT0+eS5wb3N0UmVuZGVyKHRoaXMudmVsb2NpdHlDaGVjayksdGhpcy52ZWxvY2l0eUNoZWNrPSh7dGltZXN0YW1wOnR9KT0+e3QhPT10aGlzLmxhc3RVcGRhdGVkJiYodGhpcy5wcmV2PXRoaXMuY3VycmVudCx0aGlzLmV2ZW50cy52ZWxvY2l0eUNoYW5nZSYmdGhpcy5ldmVudHMudmVsb2NpdHlDaGFuZ2Uubm90aWZ5KHRoaXMuZ2V0VmVsb2NpdHkoKSkpfSx0aGlzLmhhc0FuaW1hdGVkPSExLHRoaXMucHJldj10aGlzLmN1cnJlbnQ9dCx0aGlzLmNhblRyYWNrVmVsb2NpdHk9KG49dGhpcy5jdXJyZW50LCFpc05hTihwYXJzZUZsb2F0KG4pKSksdGhpcy5vd25lcj1lLm93bmVyfW9uQ2hhbmdlKHQpe3JldHVybiB0aGlzLm9uKFwiY2hhbmdlXCIsdCl9b24odCxlKXt0aGlzLmV2ZW50c1t0XXx8KHRoaXMuZXZlbnRzW3RdPW5ldyBtKTtjb25zdCBuPXRoaXMuZXZlbnRzW3RdLmFkZChlKTtyZXR1cm5cImNoYW5nZVwiPT09dD8oKT0+e24oKSx5LnJlYWQoKCgpPT57dGhpcy5ldmVudHMuY2hhbmdlLmdldFNpemUoKXx8dGhpcy5zdG9wKCl9KSl9Om59Y2xlYXJMaXN0ZW5lcnMoKXtmb3IoY29uc3QgdCBpbiB0aGlzLmV2ZW50cyl0aGlzLmV2ZW50c1t0XS5jbGVhcigpfWF0dGFjaCh0LGUpe3RoaXMucGFzc2l2ZUVmZmVjdD10LHRoaXMuc3RvcFBhc3NpdmVFZmZlY3Q9ZX1zZXQodCxlPSEwKXtlJiZ0aGlzLnBhc3NpdmVFZmZlY3Q/dGhpcy5wYXNzaXZlRWZmZWN0KHQsdGhpcy51cGRhdGVBbmROb3RpZnkpOnRoaXMudXBkYXRlQW5kTm90aWZ5KHQsZSl9c2V0V2l0aFZlbG9jaXR5KHQsZSxuKXt0aGlzLnNldChlKSx0aGlzLnByZXY9dCx0aGlzLnRpbWVEZWx0YT1ufWp1bXAodCl7dGhpcy51cGRhdGVBbmROb3RpZnkodCksdGhpcy5wcmV2PXQsdGhpcy5zdG9wKCksdGhpcy5zdG9wUGFzc2l2ZUVmZmVjdCYmdGhpcy5zdG9wUGFzc2l2ZUVmZmVjdCgpfWdldCgpe3JldHVybiBiLmN1cnJlbnQmJmIuY3VycmVudC5wdXNoKHRoaXMpLHRoaXMuY3VycmVudH1nZXRQcmV2aW91cygpe3JldHVybiB0aGlzLnByZXZ9Z2V0VmVsb2NpdHkoKXtyZXR1cm4gdGhpcy5jYW5UcmFja1ZlbG9jaXR5P3AocGFyc2VGbG9hdCh0aGlzLmN1cnJlbnQpLXBhcnNlRmxvYXQodGhpcy5wcmV2KSx0aGlzLnRpbWVEZWx0YSk6MH1zdGFydCh0KXtyZXR1cm4gdGhpcy5zdG9wKCksbmV3IFByb21pc2UoKGU9Pnt0aGlzLmhhc0FuaW1hdGVkPSEwLHRoaXMuYW5pbWF0aW9uPXQoZSksdGhpcy5ldmVudHMuYW5pbWF0aW9uU3RhcnQmJnRoaXMuZXZlbnRzLmFuaW1hdGlvblN0YXJ0Lm5vdGlmeSgpfSkpLnRoZW4oKCgpPT57dGhpcy5ldmVudHMuYW5pbWF0aW9uQ29tcGxldGUmJnRoaXMuZXZlbnRzLmFuaW1hdGlvbkNvbXBsZXRlLm5vdGlmeSgpLHRoaXMuY2xlYXJBbmltYXRpb24oKX0pKX1zdG9wKCl7dGhpcy5hbmltYXRpb24mJih0aGlzLmFuaW1hdGlvbi5zdG9wKCksdGhpcy5ldmVudHMuYW5pbWF0aW9uQ2FuY2VsJiZ0aGlzLmV2ZW50cy5hbmltYXRpb25DYW5jZWwubm90aWZ5KCkpLHRoaXMuY2xlYXJBbmltYXRpb24oKX1pc0FuaW1hdGluZygpe3JldHVybiEhdGhpcy5hbmltYXRpb259Y2xlYXJBbmltYXRpb24oKXtkZWxldGUgdGhpcy5hbmltYXRpb259ZGVzdHJveSgpe3RoaXMuY2xlYXJMaXN0ZW5lcnMoKSx0aGlzLnN0b3AoKSx0aGlzLnN0b3BQYXNzaXZlRWZmZWN0JiZ0aGlzLnN0b3BQYXNzaXZlRWZmZWN0KCl9fWZ1bmN0aW9uIFModCxlKXtyZXR1cm4gbmV3IFQodCxlKX1jb25zdCB3PXQ9PmU9Plwic3RyaW5nXCI9PXR5cGVvZiBlJiZlLnN0YXJ0c1dpdGgodCksRT13KFwiLS1cIiksQT13KFwidmFyKC0tXCIpLFY9dD0+TWF0aC5yb3VuZCgxZTUqdCkvMWU1LEM9LygtKT8oW1xcZF0qXFwuP1tcXGRdKSsvZyxNPS8oI1swLTlhLWZdezMsOH18KHJnYnxoc2wpYT9cXCgoLT9bXFxkXFwuXSslP1ssXFxzXSspezJ9KC0/W1xcZFxcLl0rJT8pXFxzKltcXCxcXC9dP1xccypbXFxkXFwuXSolP1xcKSkvZ2ksRD0vXigjWzAtOWEtZl17Myw4fXwocmdifGhzbClhP1xcKCgtP1tcXGRcXC5dKyU/WyxcXHNdKyl7Mn0oLT9bXFxkXFwuXSslPylcXHMqW1xcLFxcL10/XFxzKltcXGRcXC5dKiU/XFwpKSQvaTtmdW5jdGlvbiBrKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0fWNvbnN0IFI9KHQsZSxuKT0+TWF0aC5taW4oTWF0aC5tYXgobix0KSxlKSxMPXt0ZXN0OnQ9PlwibnVtYmVyXCI9PXR5cGVvZiB0LHBhcnNlOnBhcnNlRmxvYXQsdHJhbnNmb3JtOnQ9PnR9LGo9ey4uLkwsdHJhbnNmb3JtOnQ9PlIoMCwxLHQpfSxCPXsuLi5MLGRlZmF1bHQ6MX0sRj0odCxlKT0+bj0+Qm9vbGVhbihrKG4pJiZELnRlc3QobikmJm4uc3RhcnRzV2l0aCh0KXx8ZSYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sZSkpLE89KHQsZSxuKT0+cz0+e2lmKCFrKHMpKXJldHVybiBzO2NvbnN0W2ksbyxyLGFdPXMubWF0Y2goQyk7cmV0dXJue1t0XTpwYXJzZUZsb2F0KGkpLFtlXTpwYXJzZUZsb2F0KG8pLFtuXTpwYXJzZUZsb2F0KHIpLGFscGhhOnZvaWQgMCE9PWE/cGFyc2VGbG9hdChhKToxfX0sST17Li4uTCx0cmFuc2Zvcm06dD0+TWF0aC5yb3VuZCgodD0+UigwLDI1NSx0KSkodCkpfSxVPXt0ZXN0OkYoXCJyZ2JcIixcInJlZFwiKSxwYXJzZTpPKFwicmVkXCIsXCJncmVlblwiLFwiYmx1ZVwiKSx0cmFuc2Zvcm06KHtyZWQ6dCxncmVlbjplLGJsdWU6bixhbHBoYTpzPTF9KT0+XCJyZ2JhKFwiK0kudHJhbnNmb3JtKHQpK1wiLCBcIitJLnRyYW5zZm9ybShlKStcIiwgXCIrSS50cmFuc2Zvcm0obikrXCIsIFwiK1Yoai50cmFuc2Zvcm0ocykpK1wiKVwifSxOPXt0ZXN0OkYoXCIjXCIpLHBhcnNlOmZ1bmN0aW9uKHQpe2xldCBlPVwiXCIsbj1cIlwiLHM9XCJcIixpPVwiXCI7cmV0dXJuIHQubGVuZ3RoPjU/KGU9dC5zdWJzdHJpbmcoMSwzKSxuPXQuc3Vic3RyaW5nKDMsNSkscz10LnN1YnN0cmluZyg1LDcpLGk9dC5zdWJzdHJpbmcoNyw5KSk6KGU9dC5zdWJzdHJpbmcoMSwyKSxuPXQuc3Vic3RyaW5nKDIsMykscz10LnN1YnN0cmluZygzLDQpLGk9dC5zdWJzdHJpbmcoNCw1KSxlKz1lLG4rPW4scys9cyxpKz1pKSx7cmVkOnBhcnNlSW50KGUsMTYpLGdyZWVuOnBhcnNlSW50KG4sMTYpLGJsdWU6cGFyc2VJbnQocywxNiksYWxwaGE6aT9wYXJzZUludChpLDE2KS8yNTU6MX19LHRyYW5zZm9ybTpVLnRyYW5zZm9ybX0sJD10PT4oe3Rlc3Q6ZT0+ayhlKSYmZS5lbmRzV2l0aCh0KSYmMT09PWUuc3BsaXQoXCIgXCIpLmxlbmd0aCxwYXJzZTpwYXJzZUZsb2F0LHRyYW5zZm9ybTplPT5gJHtlfSR7dH1gfSksVz0kKFwiZGVnXCIpLEg9JChcIiVcIiksej0kKFwicHhcIiksWT0kKFwidmhcIiksWD0kKFwidndcIiksRz17Li4uSCxwYXJzZTp0PT5ILnBhcnNlKHQpLzEwMCx0cmFuc2Zvcm06dD0+SC50cmFuc2Zvcm0oMTAwKnQpfSxxPXt0ZXN0OkYoXCJoc2xcIixcImh1ZVwiKSxwYXJzZTpPKFwiaHVlXCIsXCJzYXR1cmF0aW9uXCIsXCJsaWdodG5lc3NcIiksdHJhbnNmb3JtOih7aHVlOnQsc2F0dXJhdGlvbjplLGxpZ2h0bmVzczpuLGFscGhhOnM9MX0pPT5cImhzbGEoXCIrTWF0aC5yb3VuZCh0KStcIiwgXCIrSC50cmFuc2Zvcm0oVihlKSkrXCIsIFwiK0gudHJhbnNmb3JtKFYobikpK1wiLCBcIitWKGoudHJhbnNmb3JtKHMpKStcIilcIn0sWj17dGVzdDp0PT5VLnRlc3QodCl8fE4udGVzdCh0KXx8cS50ZXN0KHQpLHBhcnNlOnQ9PlUudGVzdCh0KT9VLnBhcnNlKHQpOnEudGVzdCh0KT9xLnBhcnNlKHQpOk4ucGFyc2UodCksdHJhbnNmb3JtOnQ9PmsodCk/dDp0Lmhhc093blByb3BlcnR5KFwicmVkXCIpP1UudHJhbnNmb3JtKHQpOnEudHJhbnNmb3JtKHQpfSxLPXtyZWdleDovdmFyXFxzKlxcKFxccyotLVtcXHctXSsoXFxzKixcXHMqKD86KD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopKyk/XFxzKlxcKS9nLGNvdW50S2V5OlwiVmFyc1wiLHRva2VuOlwiJHt2fVwiLHBhcnNlOm59LF89e3JlZ2V4Ok0sY291bnRLZXk6XCJDb2xvcnNcIix0b2tlbjpcIiR7Y31cIixwYXJzZTpaLnBhcnNlfSxKPXtyZWdleDpDLGNvdW50S2V5OlwiTnVtYmVyc1wiLHRva2VuOlwiJHtufVwiLHBhcnNlOkwucGFyc2V9O2Z1bmN0aW9uIFEodCx7cmVnZXg6ZSxjb3VudEtleTpuLHRva2VuOnMscGFyc2U6aX0pe2NvbnN0IG89dC50b2tlbmlzZWQubWF0Y2goZSk7byYmKHRbXCJudW1cIituXT1vLmxlbmd0aCx0LnRva2VuaXNlZD10LnRva2VuaXNlZC5yZXBsYWNlKGUscyksdC52YWx1ZXMucHVzaCguLi5vLm1hcChpKSkpfWZ1bmN0aW9uIHR0KHQpe2NvbnN0IGU9dC50b1N0cmluZygpLG49e3ZhbHVlOmUsdG9rZW5pc2VkOmUsdmFsdWVzOltdLG51bVZhcnM6MCxudW1Db2xvcnM6MCxudW1OdW1iZXJzOjB9O3JldHVybiBuLnZhbHVlLmluY2x1ZGVzKFwidmFyKC0tXCIpJiZRKG4sSyksUShuLF8pLFEobixKKSxufWZ1bmN0aW9uIGV0KHQpe3JldHVybiB0dCh0KS52YWx1ZXN9ZnVuY3Rpb24gbnQodCl7Y29uc3R7dmFsdWVzOmUsbnVtQ29sb3JzOm4sbnVtVmFyczpzLHRva2VuaXNlZDppfT10dCh0KSxvPWUubGVuZ3RoO3JldHVybiB0PT57bGV0IGU9aTtmb3IobGV0IGk9MDtpPG87aSsrKWU9aTxzP2UucmVwbGFjZShLLnRva2VuLHRbaV0pOmk8cytuP2UucmVwbGFjZShfLnRva2VuLFoudHJhbnNmb3JtKHRbaV0pKTplLnJlcGxhY2UoSi50b2tlbixWKHRbaV0pKTtyZXR1cm4gZX19Y29uc3Qgc3Q9dD0+XCJudW1iZXJcIj09dHlwZW9mIHQ/MDp0LGl0PXt0ZXN0OmZ1bmN0aW9uKHQpe3ZhciBlLG47cmV0dXJuIGlzTmFOKHQpJiZrKHQpJiYoKG51bGw9PT0oZT10Lm1hdGNoKEMpKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5sZW5ndGgpfHwwKSsoKG51bGw9PT0obj10Lm1hdGNoKE0pKXx8dm9pZCAwPT09bj92b2lkIDA6bi5sZW5ndGgpfHwwKT4wfSxwYXJzZTpldCxjcmVhdGVUcmFuc2Zvcm1lcjpudCxnZXRBbmltYXRhYmxlTm9uZTpmdW5jdGlvbih0KXtjb25zdCBlPWV0KHQpO3JldHVybiBudCh0KShlLm1hcChzdCkpfX0sb3Q9bmV3IFNldChbXCJicmlnaHRuZXNzXCIsXCJjb250cmFzdFwiLFwic2F0dXJhdGVcIixcIm9wYWNpdHlcIl0pO2Z1bmN0aW9uIHJ0KHQpe2NvbnN0W2Usbl09dC5zbGljZSgwLC0xKS5zcGxpdChcIihcIik7aWYoXCJkcm9wLXNoYWRvd1wiPT09ZSlyZXR1cm4gdDtjb25zdFtzXT1uLm1hdGNoKEMpfHxbXTtpZighcylyZXR1cm4gdDtjb25zdCBpPW4ucmVwbGFjZShzLFwiXCIpO2xldCBvPW90LmhhcyhlKT8xOjA7cmV0dXJuIHMhPT1uJiYobyo9MTAwKSxlK1wiKFwiK28raStcIilcIn1jb25zdCBhdD0vKFthLXotXSopXFwoLio/XFwpL2csbHQ9ey4uLml0LGdldEFuaW1hdGFibGVOb25lOnQ9Pntjb25zdCBlPXQubWF0Y2goYXQpO3JldHVybiBlP2UubWFwKHJ0KS5qb2luKFwiIFwiKTp0fX0sdXQ9ey4uLkwsdHJhbnNmb3JtOk1hdGgucm91bmR9LGN0PXtib3JkZXJXaWR0aDp6LGJvcmRlclRvcFdpZHRoOnosYm9yZGVyUmlnaHRXaWR0aDp6LGJvcmRlckJvdHRvbVdpZHRoOnosYm9yZGVyTGVmdFdpZHRoOnosYm9yZGVyUmFkaXVzOnoscmFkaXVzOnosYm9yZGVyVG9wTGVmdFJhZGl1czp6LGJvcmRlclRvcFJpZ2h0UmFkaXVzOnosYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6eixib3JkZXJCb3R0b21MZWZ0UmFkaXVzOnosd2lkdGg6eixtYXhXaWR0aDp6LGhlaWdodDp6LG1heEhlaWdodDp6LHNpemU6eix0b3A6eixyaWdodDp6LGJvdHRvbTp6LGxlZnQ6eixwYWRkaW5nOnoscGFkZGluZ1RvcDp6LHBhZGRpbmdSaWdodDp6LHBhZGRpbmdCb3R0b206eixwYWRkaW5nTGVmdDp6LG1hcmdpbjp6LG1hcmdpblRvcDp6LG1hcmdpblJpZ2h0OnosbWFyZ2luQm90dG9tOnosbWFyZ2luTGVmdDp6LHJvdGF0ZTpXLHJvdGF0ZVg6Vyxyb3RhdGVZOlcscm90YXRlWjpXLHNjYWxlOkIsc2NhbGVYOkIsc2NhbGVZOkIsc2NhbGVaOkIsc2tldzpXLHNrZXdYOlcsc2tld1k6VyxkaXN0YW5jZTp6LHRyYW5zbGF0ZVg6eix0cmFuc2xhdGVZOnosdHJhbnNsYXRlWjp6LHg6eix5OnoseixwZXJzcGVjdGl2ZTp6LHRyYW5zZm9ybVBlcnNwZWN0aXZlOnosb3BhY2l0eTpqLG9yaWdpblg6RyxvcmlnaW5ZOkcsb3JpZ2luWjp6LHpJbmRleDp1dCxmaWxsT3BhY2l0eTpqLHN0cm9rZU9wYWNpdHk6aixudW1PY3RhdmVzOnV0fSxodD17Li4uY3QsY29sb3I6WixiYWNrZ3JvdW5kQ29sb3I6WixvdXRsaW5lQ29sb3I6WixmaWxsOlosc3Ryb2tlOlosYm9yZGVyQ29sb3I6Wixib3JkZXJUb3BDb2xvcjpaLGJvcmRlclJpZ2h0Q29sb3I6Wixib3JkZXJCb3R0b21Db2xvcjpaLGJvcmRlckxlZnRDb2xvcjpaLGZpbHRlcjpsdCxXZWJraXRGaWx0ZXI6bHR9LGR0PXQ9Pmh0W3RdO2Z1bmN0aW9uIG10KHQsZSl7bGV0IG49ZHQodCk7cmV0dXJuIG4hPT1sdCYmKG49aXQpLG4uZ2V0QW5pbWF0YWJsZU5vbmU/bi5nZXRBbmltYXRhYmxlTm9uZShlKTp2b2lkIDB9Y29uc3QgcHQ9dD0+ZT0+ZS50ZXN0KHQpLGZ0PVtMLHosSCxXLFgsWSx7dGVzdDp0PT5cImF1dG9cIj09PXQscGFyc2U6dD0+dH1dLGd0PXQ9PmZ0LmZpbmQocHQodCkpLHl0PVsuLi5mdCxaLGl0XTtmdW5jdGlvbiB2dCh0LGUsbixzPXt9LGk9e30pe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJihlPWUodm9pZCAwIT09bj9uOnQuY3VzdG9tLHMsaSkpLFwic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT10LnZhcmlhbnRzJiZ0LnZhcmlhbnRzW2VdKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiYoZT1lKHZvaWQgMCE9PW4/bjp0LmN1c3RvbSxzLGkpKSxlfWZ1bmN0aW9uIHh0KHQsZSxuKXtjb25zdCBzPXQuZ2V0UHJvcHMoKTtyZXR1cm4gdnQocyxlLHZvaWQgMCE9PW4/bjpzLmN1c3RvbSxmdW5jdGlvbih0KXtjb25zdCBlPXt9O3JldHVybiB0LnZhbHVlcy5mb3JFYWNoKCgodCxuKT0+ZVtuXT10LmdldCgpKSksZX0odCksZnVuY3Rpb24odCl7Y29uc3QgZT17fTtyZXR1cm4gdC52YWx1ZXMuZm9yRWFjaCgoKHQsbik9PmVbbl09dC5nZXRWZWxvY2l0eSgpKSksZX0odCkpfWZ1bmN0aW9uIFB0KHQsZSxuKXt0Lmhhc1ZhbHVlKGUpP3QuZ2V0VmFsdWUoZSkuc2V0KG4pOnQuYWRkVmFsdWUoZSxTKG4pKX1mdW5jdGlvbiBidCh0LGUpe2NvbnN0IG49eHQodCxlKTtsZXR7dHJhbnNpdGlvbkVuZDpzPXt9LHRyYW5zaXRpb246aT17fSwuLi5vfT1uP3QubWFrZVRhcmdldEFuaW1hdGFibGUobiwhMSk6e307bz17Li4ubywuLi5zfTtmb3IoY29uc3QgZSBpbiBvKVB0KHQsZSwocj1vW2VdLGMocik/cltyLmxlbmd0aC0xXXx8MDpyKSk7dmFyIHJ9ZnVuY3Rpb24gVHQodCxlKXtbLi4uZV0ucmV2ZXJzZSgpLmZvckVhY2goKG49Pntjb25zdCBzPXQuZ2V0VmFyaWFudChuKTtzJiZidCh0LHMpLHQudmFyaWFudENoaWxkcmVuJiZ0LnZhcmlhbnRDaGlsZHJlbi5mb3JFYWNoKCh0PT57VHQodCxlKX0pKX0pKX1mdW5jdGlvbiBTdCh0LGUpe2lmKGUpcmV0dXJuKGVbdF18fGUuZGVmYXVsdHx8ZSkuZnJvbX1jb25zdCB3dD1bXCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiLFwieFwiLFwieVwiLFwielwiLFwidHJhbnNsYXRlWFwiLFwidHJhbnNsYXRlWVwiLFwidHJhbnNsYXRlWlwiLFwic2NhbGVcIixcInNjYWxlWFwiLFwic2NhbGVZXCIsXCJyb3RhdGVcIixcInJvdGF0ZVhcIixcInJvdGF0ZVlcIixcInJvdGF0ZVpcIixcInNrZXdcIixcInNrZXdYXCIsXCJza2V3WVwiXSxFdD1uZXcgU2V0KHd0KSxBdD10PT50LnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpLFZ0PVwiZGF0YS1cIitBdChcImZyYW1lckFwcGVhcklkXCIpLEN0PXQ9PjFlMyp0LE10PXQ9PnQvMWUzLER0PXQ9PkFycmF5LmlzQXJyYXkodCkmJlwibnVtYmVyXCI9PXR5cGVvZiB0WzBdO2Z1bmN0aW9uIGt0KHQpe3JldHVybiBCb29sZWFuKCF0fHxcInN0cmluZ1wiPT10eXBlb2YgdCYmTHRbdF18fER0KHQpfHxBcnJheS5pc0FycmF5KHQpJiZ0LmV2ZXJ5KGt0KSl9Y29uc3QgUnQ9KFt0LGUsbixzXSk9PmBjdWJpYy1iZXppZXIoJHt0fSwgJHtlfSwgJHtufSwgJHtzfSlgLEx0PXtsaW5lYXI6XCJsaW5lYXJcIixlYXNlOlwiZWFzZVwiLGVhc2VJbjpcImVhc2UtaW5cIixlYXNlT3V0OlwiZWFzZS1vdXRcIixlYXNlSW5PdXQ6XCJlYXNlLWluLW91dFwiLGNpcmNJbjpSdChbMCwuNjUsLjU1LDFdKSxjaXJjT3V0OlJ0KFsuNTUsMCwxLC40NV0pLGJhY2tJbjpSdChbLjMxLC4wMSwuNjYsLS41OV0pLGJhY2tPdXQ6UnQoWy4zMywxLjUzLC42OSwuOTldKX07ZnVuY3Rpb24ganQodCl7aWYodClyZXR1cm4gRHQodCk/UnQodCk6QXJyYXkuaXNBcnJheSh0KT90Lm1hcChqdCk6THRbdF19Y29uc3QgQnQ9KHQsZSxuKT0+KCgoMS0zKm4rMyplKSp0KygzKm4tNiplKSkqdCszKmUpKnQ7ZnVuY3Rpb24gRnQodCxlLHMsaSl7aWYodD09PWUmJnM9PT1pKXJldHVybiBuO3JldHVybiBuPT4wPT09bnx8MT09PW4/bjpCdChmdW5jdGlvbih0LGUsbixzLGkpe2xldCBvLHIsYT0wO2Rve3I9ZSsobi1lKS8yLG89QnQocixzLGkpLXQsbz4wP249cjplPXJ9d2hpbGUoTWF0aC5hYnMobyk+MWUtNyYmKythPDEyKTtyZXR1cm4gcn0obiwwLDEsdCxzKSxlLGkpfWNvbnN0IE90PUZ0KC40MiwwLDEsMSksSXQ9RnQoMCwwLC41OCwxKSxVdD1GdCguNDIsMCwuNTgsMSksTnQ9dD0+ZT0+ZTw9LjU/dCgyKmUpLzI6KDItdCgyKigxLWUpKSkvMiwkdD10PT5lPT4xLXQoMS1lKSxXdD10PT4xLU1hdGguc2luKE1hdGguYWNvcyh0KSksSHQ9JHQoV3QpLHp0PU50KEh0KSxZdD1GdCguMzMsMS41MywuNjksLjk5KSxYdD0kdChZdCksR3Q9TnQoWHQpLHF0PXtsaW5lYXI6bixlYXNlSW46T3QsZWFzZUluT3V0OlV0LGVhc2VPdXQ6SXQsY2lyY0luOld0LGNpcmNJbk91dDp6dCxjaXJjT3V0Okh0LGJhY2tJbjpYdCxiYWNrSW5PdXQ6R3QsYmFja091dDpZdCxhbnRpY2lwYXRlOnQ9Pih0Kj0yKTwxPy41Klh0KHQpOi41KigyLU1hdGgucG93KDIsLTEwKih0LTEpKSl9LFp0PXQ9PntpZihBcnJheS5pc0FycmF5KHQpKXtyKDQ9PT10Lmxlbmd0aCxcIkN1YmljIGJlemllciBhcnJheXMgbXVzdCBjb250YWluIGZvdXIgbnVtZXJpY2FsIHZhbHVlcy5cIik7Y29uc3RbZSxuLHMsaV09dDtyZXR1cm4gRnQoZSxuLHMsaSl9cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQ/KHIodm9pZCAwIT09cXRbdF0sYEludmFsaWQgZWFzaW5nIHR5cGUgJyR7dH0nYCkscXRbdF0pOnR9LEt0PSh0LGUsbik9Pi1uKnQrbiplK3Q7ZnVuY3Rpb24gX3QodCxlLG4pe3JldHVybiBuPDAmJihuKz0xKSxuPjEmJihuLT0xKSxuPDEvNj90KzYqKGUtdCkqbjpuPC41P2U6bjwyLzM/dCsoZS10KSooMi8zLW4pKjY6dH1jb25zdCBKdD0odCxlLG4pPT57Y29uc3Qgcz10KnQ7cmV0dXJuIE1hdGguc3FydChNYXRoLm1heCgwLG4qKGUqZS1zKStzKSl9LFF0PVtOLFUscV07ZnVuY3Rpb24gdGUodCl7Y29uc3QgZT0obj10LFF0LmZpbmQoKHQ9PnQudGVzdChuKSkpKTt2YXIgbjtyKEJvb2xlYW4oZSksYCcke3R9JyBpcyBub3QgYW4gYW5pbWF0YWJsZSBjb2xvci4gVXNlIHRoZSBlcXVpdmFsZW50IGNvbG9yIGNvZGUgaW5zdGVhZC5gKTtsZXQgcz1lLnBhcnNlKHQpO3JldHVybiBlPT09cSYmKHM9ZnVuY3Rpb24oe2h1ZTp0LHNhdHVyYXRpb246ZSxsaWdodG5lc3M6bixhbHBoYTpzfSl7dC89MzYwLG4vPTEwMDtsZXQgaT0wLG89MCxyPTA7aWYoZS89MTAwKXtjb25zdCBzPW48LjU/biooMStlKTpuK2UtbiplLGE9MipuLXM7aT1fdChhLHMsdCsxLzMpLG89X3QoYSxzLHQpLHI9X3QoYSxzLHQtMS8zKX1lbHNlIGk9bz1yPW47cmV0dXJue3JlZDpNYXRoLnJvdW5kKDI1NSppKSxncmVlbjpNYXRoLnJvdW5kKDI1NSpvKSxibHVlOk1hdGgucm91bmQoMjU1KnIpLGFscGhhOnN9fShzKSksc31jb25zdCBlZT0odCxlKT0+e2NvbnN0IG49dGUodCkscz10ZShlKSxpPXsuLi5ufTtyZXR1cm4gdD0+KGkucmVkPUp0KG4ucmVkLHMucmVkLHQpLGkuZ3JlZW49SnQobi5ncmVlbixzLmdyZWVuLHQpLGkuYmx1ZT1KdChuLmJsdWUscy5ibHVlLHQpLGkuYWxwaGE9S3Qobi5hbHBoYSxzLmFscGhhLHQpLFUudHJhbnNmb3JtKGkpKX0sbmU9KHQsZSk9Pm49PmUodChuKSksc2U9KC4uLnQpPT50LnJlZHVjZShuZSksaWU9KHQsZSk9Pm49PmAke24+MD9lOnR9YDtmdW5jdGlvbiBvZSh0LGUpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0P249Pkt0KHQsZSxuKTpaLnRlc3QodCk/ZWUodCxlKTp0LnN0YXJ0c1dpdGgoXCJ2YXIoXCIpP2llKHQsZSk6bGUodCxlKX1jb25zdCByZT0odCxlKT0+e2NvbnN0IG49Wy4uLnRdLHM9bi5sZW5ndGgsaT10Lm1hcCgoKHQsbik9Pm9lKHQsZVtuXSkpKTtyZXR1cm4gdD0+e2ZvcihsZXQgZT0wO2U8cztlKyspbltlXT1pW2VdKHQpO3JldHVybiBufX0sYWU9KHQsZSk9Pntjb25zdCBuPXsuLi50LC4uLmV9LHM9e307Zm9yKGNvbnN0IGkgaW4gbil2b2lkIDAhPT10W2ldJiZ2b2lkIDAhPT1lW2ldJiYoc1tpXT1vZSh0W2ldLGVbaV0pKTtyZXR1cm4gdD0+e2Zvcihjb25zdCBlIGluIHMpbltlXT1zW2VdKHQpO3JldHVybiBufX0sbGU9KHQsZSk9Pntjb25zdCBuPWl0LmNyZWF0ZVRyYW5zZm9ybWVyKGUpLHM9dHQodCksaT10dChlKTtyZXR1cm4gcy5udW1WYXJzPT09aS5udW1WYXJzJiZzLm51bUNvbG9ycz09PWkubnVtQ29sb3JzJiZzLm51bU51bWJlcnM+PWkubnVtTnVtYmVycz9zZShyZShzLnZhbHVlcyxpLnZhbHVlcyksbik6KG8oITAsYENvbXBsZXggdmFsdWVzICcke3R9JyBhbmQgJyR7ZX0nIHRvbyBkaWZmZXJlbnQgdG8gbWl4LiBFbnN1cmUgYWxsIGNvbG9ycyBhcmUgb2YgdGhlIHNhbWUgdHlwZSwgYW5kIHRoYXQgZWFjaCBjb250YWlucyB0aGUgc2FtZSBxdWFudGl0eSBvZiBudW1iZXIgYW5kIGNvbG9yIHZhbHVlcy4gRmFsbGluZyBiYWNrIHRvIGluc3RhbnQgdHJhbnNpdGlvbi5gKSxpZSh0LGUpKX0sdWU9KHQsZSxuKT0+e2NvbnN0IHM9ZS10O3JldHVybiAwPT09cz8xOihuLXQpL3N9LGNlPSh0LGUpPT5uPT5LdCh0LGUsbik7ZnVuY3Rpb24gaGUodCxlLHtjbGFtcDpzPSEwLGVhc2U6aSxtaXhlcjpvfT17fSl7Y29uc3QgYT10Lmxlbmd0aDtpZihyKGE9PT1lLmxlbmd0aCxcIkJvdGggaW5wdXQgYW5kIG91dHB1dCByYW5nZXMgbXVzdCBiZSB0aGUgc2FtZSBsZW5ndGhcIiksMT09PWEpcmV0dXJuKCk9PmVbMF07dFswXT50W2EtMV0mJih0PVsuLi50XS5yZXZlcnNlKCksZT1bLi4uZV0ucmV2ZXJzZSgpKTtjb25zdCBsPWZ1bmN0aW9uKHQsZSxzKXtjb25zdCBpPVtdLG89c3x8KFwibnVtYmVyXCI9PXR5cGVvZihyPXRbMF0pP2NlOlwic3RyaW5nXCI9PXR5cGVvZiByP1oudGVzdChyKT9lZTpsZTpBcnJheS5pc0FycmF5KHIpP3JlOlwib2JqZWN0XCI9PXR5cGVvZiByP2FlOmNlKTt2YXIgcjtjb25zdCBhPXQubGVuZ3RoLTE7Zm9yKGxldCBzPTA7czxhO3MrKyl7bGV0IHI9byh0W3NdLHRbcysxXSk7aWYoZSl7Y29uc3QgdD1BcnJheS5pc0FycmF5KGUpP2Vbc118fG46ZTtyPXNlKHQscil9aS5wdXNoKHIpfXJldHVybiBpfShlLGksbyksdT1sLmxlbmd0aCxjPWU9PntsZXQgbj0wO2lmKHU+MSlmb3IoO248dC5sZW5ndGgtMiYmIShlPHRbbisxXSk7bisrKTtjb25zdCBzPXVlKHRbbl0sdFtuKzFdLGUpO3JldHVybiBsW25dKHMpfTtyZXR1cm4gcz9lPT5jKFIodFswXSx0W2EtMV0sZSkpOmN9ZnVuY3Rpb24gZGUoe2R1cmF0aW9uOnQ9MzAwLGtleWZyYW1lczplLHRpbWVzOm4sZWFzZTpzPVwiZWFzZUluT3V0XCJ9KXtjb25zdCBpPSh0PT5BcnJheS5pc0FycmF5KHQpJiZcIm51bWJlclwiIT10eXBlb2YgdFswXSkocyk/cy5tYXAoWnQpOlp0KHMpLG89e2RvbmU6ITEsdmFsdWU6ZVswXX0scj1oZShmdW5jdGlvbih0LGUpe3JldHVybiB0Lm1hcCgodD0+dCplKSl9KG4mJm4ubGVuZ3RoPT09ZS5sZW5ndGg/bjpmdW5jdGlvbih0KXtjb25zdCBlPVswXTtyZXR1cm4gZnVuY3Rpb24odCxlKXtjb25zdCBuPXRbdC5sZW5ndGgtMV07Zm9yKGxldCBzPTE7czw9ZTtzKyspe2NvbnN0IGk9dWUoMCxlLHMpO3QucHVzaChLdChuLDEsaSkpfX0oZSx0Lmxlbmd0aC0xKSxlfShlKSx0KSxlLHtlYXNlOkFycmF5LmlzQXJyYXkoaSk/aTooYT1lLGw9aSxhLm1hcCgoKCk9Pmx8fFV0KSkuc3BsaWNlKDAsYS5sZW5ndGgtMSkpfSk7dmFyIGEsbDtyZXR1cm57Y2FsY3VsYXRlZER1cmF0aW9uOnQsbmV4dDplPT4oby52YWx1ZT1yKGUpLG8uZG9uZT1lPj10LG8pfX1mdW5jdGlvbiBtZSh0LGUsbil7Y29uc3Qgcz1NYXRoLm1heChlLTUsMCk7cmV0dXJuIHAobi10KHMpLGUtcyl9ZnVuY3Rpb24gcGUodCxlKXtyZXR1cm4gdCpNYXRoLnNxcnQoMS1lKmUpfWNvbnN0IGZlPVtcImR1cmF0aW9uXCIsXCJib3VuY2VcIl0sZ2U9W1wic3RpZmZuZXNzXCIsXCJkYW1waW5nXCIsXCJtYXNzXCJdO2Z1bmN0aW9uIHllKHQsZSl7cmV0dXJuIGUuc29tZSgoZT0+dm9pZCAwIT09dFtlXSkpfWZ1bmN0aW9uIHZlKHtrZXlmcmFtZXM6dCxyZXN0RGVsdGE6ZSxyZXN0U3BlZWQ6biwuLi5zfSl7Y29uc3QgaT10WzBdLHI9dFt0Lmxlbmd0aC0xXSxhPXtkb25lOiExLHZhbHVlOml9LHtzdGlmZm5lc3M6bCxkYW1waW5nOnUsbWFzczpjLHZlbG9jaXR5OmgsZHVyYXRpb246ZCxpc1Jlc29sdmVkRnJvbUR1cmF0aW9uOm19PWZ1bmN0aW9uKHQpe2xldCBlPXt2ZWxvY2l0eTowLHN0aWZmbmVzczoxMDAsZGFtcGluZzoxMCxtYXNzOjEsaXNSZXNvbHZlZEZyb21EdXJhdGlvbjohMSwuLi50fTtpZigheWUodCxnZSkmJnllKHQsZmUpKXtjb25zdCBuPWZ1bmN0aW9uKHtkdXJhdGlvbjp0PTgwMCxib3VuY2U6ZT0uMjUsdmVsb2NpdHk6bj0wLG1hc3M6cz0xfSl7bGV0IGkscjtvKHQ8PUN0KDEwKSxcIlNwcmluZyBkdXJhdGlvbiBtdXN0IGJlIDEwIHNlY29uZHMgb3IgbGVzc1wiKTtsZXQgYT0xLWU7YT1SKC4wNSwxLGEpLHQ9UiguMDEsMTAsTXQodCkpLGE8MT8oaT1lPT57Y29uc3Qgcz1lKmEsaT1zKnQ7cmV0dXJuLjAwMS0ocy1uKS9wZShlLGEpKk1hdGguZXhwKC1pKX0scj1lPT57Y29uc3Qgcz1lKmEqdCxvPXMqbituLHI9TWF0aC5wb3coYSwyKSpNYXRoLnBvdyhlLDIpKnQsbD1NYXRoLmV4cCgtcyksdT1wZShNYXRoLnBvdyhlLDIpLGEpO3JldHVybiguMDAxLWkoZSk+MD8tMToxKSooKG8tcikqbCkvdX0pOihpPWU9Pk1hdGguZXhwKC1lKnQpKigoZS1uKSp0KzEpLS4wMDEscj1lPT5NYXRoLmV4cCgtZSp0KSoodCp0KihuLWUpKSk7Y29uc3QgbD1mdW5jdGlvbih0LGUsbil7bGV0IHM9bjtmb3IobGV0IG49MTtuPDEyO24rKylzLT10KHMpL2Uocyk7cmV0dXJuIHN9KGksciw1L3QpO2lmKHQ9Q3QodCksaXNOYU4obCkpcmV0dXJue3N0aWZmbmVzczoxMDAsZGFtcGluZzoxMCxkdXJhdGlvbjp0fTt7Y29uc3QgZT1NYXRoLnBvdyhsLDIpKnM7cmV0dXJue3N0aWZmbmVzczplLGRhbXBpbmc6MiphKk1hdGguc3FydChzKmUpLGR1cmF0aW9uOnR9fX0odCk7ZT17Li4uZSwuLi5uLHZlbG9jaXR5OjAsbWFzczoxfSxlLmlzUmVzb2x2ZWRGcm9tRHVyYXRpb249ITB9cmV0dXJuIGV9KHMpLHA9aD8tTXQoaCk6MCxmPXUvKDIqTWF0aC5zcXJ0KGwqYykpLGc9ci1pLHk9TXQoTWF0aC5zcXJ0KGwvYykpLHY9TWF0aC5hYnMoZyk8NTtsZXQgeDtpZihufHwobj12Py4wMToyKSxlfHwoZT12Py4wMDU6LjUpLGY8MSl7Y29uc3QgdD1wZSh5LGYpO3g9ZT0+e2NvbnN0IG49TWF0aC5leHAoLWYqeSplKTtyZXR1cm4gci1uKigocCtmKnkqZykvdCpNYXRoLnNpbih0KmUpK2cqTWF0aC5jb3ModCplKSl9fWVsc2UgaWYoMT09PWYpeD10PT5yLU1hdGguZXhwKC15KnQpKihnKyhwK3kqZykqdCk7ZWxzZXtjb25zdCB0PXkqTWF0aC5zcXJ0KGYqZi0xKTt4PWU9Pntjb25zdCBuPU1hdGguZXhwKC1mKnkqZSkscz1NYXRoLm1pbih0KmUsMzAwKTtyZXR1cm4gci1uKigocCtmKnkqZykqTWF0aC5zaW5oKHMpK3QqZypNYXRoLmNvc2gocykpL3R9fXJldHVybntjYWxjdWxhdGVkRHVyYXRpb246bSYmZHx8bnVsbCxuZXh0OnQ9Pntjb25zdCBzPXgodCk7aWYobSlhLmRvbmU9dD49ZDtlbHNle2xldCBpPXA7MCE9PXQmJihpPWY8MT9tZSh4LHQscyk6MCk7Y29uc3Qgbz1NYXRoLmFicyhpKTw9bixsPU1hdGguYWJzKHItcyk8PWU7YS5kb25lPW8mJmx9cmV0dXJuIGEudmFsdWU9YS5kb25lP3I6cyxhfX19ZnVuY3Rpb24geGUoe2tleWZyYW1lczp0LHZlbG9jaXR5OmU9MCxwb3dlcjpuPS44LHRpbWVDb25zdGFudDpzPTMyNSxib3VuY2VEYW1waW5nOmk9MTAsYm91bmNlU3RpZmZuZXNzOm89NTAwLG1vZGlmeVRhcmdldDpyLG1pbjphLG1heDpsLHJlc3REZWx0YTp1PS41LHJlc3RTcGVlZDpjfSl7Y29uc3QgaD10WzBdLGQ9e2RvbmU6ITEsdmFsdWU6aH0sbT10PT52b2lkIDA9PT1hP2w6dm9pZCAwPT09bHx8TWF0aC5hYnMoYS10KTxNYXRoLmFicyhsLXQpP2E6bDtsZXQgcD1uKmU7Y29uc3QgZj1oK3AsZz12b2lkIDA9PT1yP2Y6cihmKTtnIT09ZiYmKHA9Zy1oKTtjb25zdCB5PXQ9Pi1wKk1hdGguZXhwKC10L3MpLHY9dD0+Zyt5KHQpLHg9dD0+e2NvbnN0IGU9eSh0KSxuPXYodCk7ZC5kb25lPU1hdGguYWJzKGUpPD11LGQudmFsdWU9ZC5kb25lP2c6bn07bGV0IFAsYjtjb25zdCBUPXQ9Pnt2YXIgZTtlPWQudmFsdWUsKHZvaWQgMCE9PWEmJmU8YXx8dm9pZCAwIT09bCYmZT5sKSYmKFA9dCxiPXZlKHtrZXlmcmFtZXM6W2QudmFsdWUsbShkLnZhbHVlKV0sdmVsb2NpdHk6bWUodix0LGQudmFsdWUpLGRhbXBpbmc6aSxzdGlmZm5lc3M6byxyZXN0RGVsdGE6dSxyZXN0U3BlZWQ6Y30pKX07cmV0dXJuIFQoMCkse2NhbGN1bGF0ZWREdXJhdGlvbjpudWxsLG5leHQ6dD0+e2xldCBlPSExO3JldHVybiBifHx2b2lkIDAhPT1QfHwoZT0hMCx4KHQpLFQodCkpLHZvaWQgMCE9PVAmJnQ+UD9iLm5leHQodC1QKTooIWUmJngodCksZCl9fX1jb25zdCBQZT10PT57Y29uc3QgZT0oe3RpbWVzdGFtcDplfSk9PnQoZSk7cmV0dXJue3N0YXJ0OigpPT55LnVwZGF0ZShlLCEwKSxzdG9wOigpPT52KGUpLG5vdzooKT0+eC5pc1Byb2Nlc3Npbmc/eC50aW1lc3RhbXA6cGVyZm9ybWFuY2Uubm93KCl9fTtmdW5jdGlvbiBiZSh0KXtsZXQgZT0wLG49dC5uZXh0KGUpO2Zvcig7IW4uZG9uZSYmZTwyZTQ7KWUrPTUwLG49dC5uZXh0KGUpO3JldHVybiBlPj0yZTQ/MS8wOmV9Y29uc3QgVGU9e2RlY2F5OnhlLGluZXJ0aWE6eGUsdHdlZW46ZGUsa2V5ZnJhbWVzOmRlLHNwcmluZzp2ZX07ZnVuY3Rpb24gU2Uoe2F1dG9wbGF5OnQ9ITAsZGVsYXk6ZT0wLGRyaXZlcjpuPVBlLGtleWZyYW1lczpzLHR5cGU6aT1cImtleWZyYW1lc1wiLHJlcGVhdDpvPTAscmVwZWF0RGVsYXk6cj0wLHJlcGVhdFR5cGU6YT1cImxvb3BcIixvblBsYXk6bCxvblN0b3A6dSxvbkNvbXBsZXRlOmMsb25VcGRhdGU6aCwuLi5kfSl7bGV0IG0scCxmPTEsZz0hMTtjb25zdCB5PSgpPT57cD1uZXcgUHJvbWlzZSgodD0+e209dH0pKX07bGV0IHY7eSgpO2NvbnN0IHg9VGVbaV18fGRlO2xldCBQO3ghPT1kZSYmXCJudW1iZXJcIiE9dHlwZW9mIHNbMF0mJihQPWhlKFswLDEwMF0scyx7Y2xhbXA6ITF9KSxzPVswLDEwMF0pO2NvbnN0IGI9eCh7Li4uZCxrZXlmcmFtZXM6c30pO2xldCBUO1wibWlycm9yXCI9PT1hJiYoVD14KHsuLi5kLGtleWZyYW1lczpbLi4uc10ucmV2ZXJzZSgpLHZlbG9jaXR5Oi0oZC52ZWxvY2l0eXx8MCl9KSk7bGV0IFM9XCJpZGxlXCIsdz1udWxsLEU9bnVsbCxBPW51bGw7bnVsbD09PWIuY2FsY3VsYXRlZER1cmF0aW9uJiZvJiYoYi5jYWxjdWxhdGVkRHVyYXRpb249YmUoYikpO2NvbnN0e2NhbGN1bGF0ZWREdXJhdGlvbjpWfT1iO2xldCBDPTEvMCxNPTEvMDtudWxsIT09ViYmKEM9VityLE09QyoobysxKS1yKTtsZXQgRD0wO2NvbnN0IGs9dD0+e2lmKG51bGw9PT1FKXJldHVybjtmPjAmJihFPU1hdGgubWluKEUsdCkpLGY8MCYmKEU9TWF0aC5taW4odC1NL2YsRSkpLEQ9bnVsbCE9PXc/dzpNYXRoLnJvdW5kKHQtRSkqZjtjb25zdCBuPUQtZSooZj49MD8xOi0xKSxpPWY+PTA/bjwwOm4+TTtEPU1hdGgubWF4KG4sMCksXCJmaW5pc2hlZFwiPT09UyYmbnVsbD09PXcmJihEPU0pO2xldCBsPUQsdT1iO2lmKG8pe2NvbnN0IHQ9RC9DO2xldCBlPU1hdGguZmxvb3IodCksbj10JTE7IW4mJnQ+PTEmJihuPTEpLDE9PT1uJiZlLS0sZT1NYXRoLm1pbihlLG8rMSk7Y29uc3Qgcz1Cb29sZWFuKGUlMik7cyYmKFwicmV2ZXJzZVwiPT09YT8obj0xLW4sciYmKG4tPXIvQykpOlwibWlycm9yXCI9PT1hJiYodT1UKSk7bGV0IGk9UigwLDEsbik7RD5NJiYoaT1cInJldmVyc2VcIj09PWEmJnM/MTowKSxsPWkqQ31jb25zdCBjPWk/e2RvbmU6ITEsdmFsdWU6c1swXX06dS5uZXh0KGwpO1AmJihjLnZhbHVlPVAoYy52YWx1ZSkpO2xldHtkb25lOmR9PWM7aXx8bnVsbD09PVZ8fChkPWY+PTA/RD49TTpEPD0wKTtjb25zdCBtPW51bGw9PT13JiYoXCJmaW5pc2hlZFwiPT09U3x8XCJydW5uaW5nXCI9PT1TJiZkKTtyZXR1cm4gaCYmaChjLnZhbHVlKSxtJiZCKCksY30sTD0oKT0+e3YmJnYuc3RvcCgpLHY9dm9pZCAwfSxqPSgpPT57Uz1cImlkbGVcIixMKCksbSgpLHkoKSxFPUE9bnVsbH0sQj0oKT0+e1M9XCJmaW5pc2hlZFwiLGMmJmMoKSxMKCksbSgpfSxGPSgpPT57aWYoZylyZXR1cm47dnx8KHY9bihrKSk7Y29uc3QgdD12Lm5vdygpO2wmJmwoKSxudWxsIT09dz9FPXQtdzpFJiZcImZpbmlzaGVkXCIhPT1TfHwoRT10KSxcImZpbmlzaGVkXCI9PT1TJiZ5KCksQT1FLHc9bnVsbCxTPVwicnVubmluZ1wiLHYuc3RhcnQoKX07dCYmRigpO2NvbnN0IE89e3RoZW46KHQsZSk9PnAudGhlbih0LGUpLGdldCB0aW1lKCl7cmV0dXJuIE10KEQpfSxzZXQgdGltZSh0KXt0PUN0KHQpLEQ9dCxudWxsPT09dyYmdiYmMCE9PWY/RT12Lm5vdygpLXQvZjp3PXR9LGdldCBkdXJhdGlvbigpe2NvbnN0IHQ9bnVsbD09PWIuY2FsY3VsYXRlZER1cmF0aW9uP2JlKGIpOmIuY2FsY3VsYXRlZER1cmF0aW9uO3JldHVybiBNdCh0KX0sZ2V0IHNwZWVkKCl7cmV0dXJuIGZ9LHNldCBzcGVlZCh0KXt0IT09ZiYmdiYmKGY9dCxPLnRpbWU9TXQoRCkpfSxnZXQgc3RhdGUoKXtyZXR1cm4gU30scGxheTpGLHBhdXNlOigpPT57Uz1cInBhdXNlZFwiLHc9RH0sc3RvcDooKT0+e2c9ITAsXCJpZGxlXCIhPT1TJiYoUz1cImlkbGVcIix1JiZ1KCksaigpKX0sY2FuY2VsOigpPT57bnVsbCE9PUEmJmsoQSksaigpfSxjb21wbGV0ZTooKT0+e1M9XCJmaW5pc2hlZFwifSxzYW1wbGU6dD0+KEU9MCxrKHQpKX07cmV0dXJuIE99Y29uc3Qgd2U9ZnVuY3Rpb24odCl7bGV0IGU7cmV0dXJuKCk9Pih2b2lkIDA9PT1lJiYoZT1PYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChFbGVtZW50LnByb3RvdHlwZSxcImFuaW1hdGVcIikpLGUpfSgpLEVlPW5ldyBTZXQoW1wib3BhY2l0eVwiLFwiY2xpcFBhdGhcIixcImZpbHRlclwiLFwidHJhbnNmb3JtXCIsXCJiYWNrZ3JvdW5kQ29sb3JcIl0pO2NvbnN0IEFlPXt0eXBlOlwic3ByaW5nXCIsc3RpZmZuZXNzOjUwMCxkYW1waW5nOjI1LHJlc3RTcGVlZDoxMH0sVmU9e3R5cGU6XCJrZXlmcmFtZXNcIixkdXJhdGlvbjouOH0sQ2U9e3R5cGU6XCJrZXlmcmFtZXNcIixlYXNlOlsuMjUsLjEsLjM1LDFdLGR1cmF0aW9uOi4zfSxNZT0odCx7a2V5ZnJhbWVzOmV9KT0+ZS5sZW5ndGg+Mj9WZTpFdC5oYXModCk/dC5zdGFydHNXaXRoKFwic2NhbGVcIik/e3R5cGU6XCJzcHJpbmdcIixzdGlmZm5lc3M6NTUwLGRhbXBpbmc6MD09PWVbMV0/MipNYXRoLnNxcnQoNTUwKTozMCxyZXN0U3BlZWQ6MTB9OkFlOkNlLERlPSh0LGUpPT4hKFwiekluZGV4XCI9PT10fHxcIm51bWJlclwiIT10eXBlb2YgZSYmIUFycmF5LmlzQXJyYXkoZSkmJihcInN0cmluZ1wiIT10eXBlb2YgZXx8IWl0LnRlc3QoZSkmJlwiMFwiIT09ZXx8ZS5zdGFydHNXaXRoKFwidXJsKFwiKSkpO2Z1bmN0aW9uIGtlKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0PzA9PT10Om51bGwhPT10P1wibm9uZVwiPT09dHx8XCIwXCI9PT10fHx1KHQpOnZvaWQgMH1mdW5jdGlvbiBSZSh0LGUpe3JldHVybiB0W2VdfHx0LmRlZmF1bHR8fHR9Y29uc3QgTGU9KHQsZSxzLGk9e30pPT5yPT57Y29uc3QgYT1SZShpLHQpfHx7fSxsPWEuZGVsYXl8fGkuZGVsYXl8fDA7bGV0e2VsYXBzZWQ6dT0wfT1pO3UtPUN0KGwpO2NvbnN0IGM9ZnVuY3Rpb24odCxlLG4scyl7Y29uc3QgaT1EZShlLG4pO2xldCBvO289QXJyYXkuaXNBcnJheShuKT9bLi4ubl06W251bGwsbl07Y29uc3Qgcj12b2lkIDAhPT1zLmZyb20/cy5mcm9tOnQuZ2V0KCk7bGV0IGE7Y29uc3QgbD1bXTtmb3IobGV0IHQ9MDt0PG8ubGVuZ3RoO3QrKyludWxsPT09b1t0XSYmKG9bdF09MD09PXQ/cjpvW3QtMV0pLGtlKG9bdF0pJiZsLnB1c2godCksXCJzdHJpbmdcIj09dHlwZW9mIG9bdF0mJlwibm9uZVwiIT09b1t0XSYmXCIwXCIhPT1vW3RdJiYoYT1vW3RdKTtpZihpJiZsLmxlbmd0aCYmYSlmb3IobGV0IHQ9MDt0PGwubGVuZ3RoO3QrKylvW2xbdF1dPW10KGUsYSk7cmV0dXJuIG99KGUsdCxzLGEpLGg9Y1swXSxkPWNbYy5sZW5ndGgtMV0sbT1EZSh0LGgpLHA9RGUodCxkKTtvKG09PT1wLGBZb3UgYXJlIHRyeWluZyB0byBhbmltYXRlICR7dH0gZnJvbSBcIiR7aH1cIiB0byBcIiR7ZH1cIi4gJHtofSBpcyBub3QgYW4gYW5pbWF0YWJsZSB2YWx1ZSAtIHRvIGVuYWJsZSB0aGlzIGFuaW1hdGlvbiBzZXQgJHtofSB0byBhIHZhbHVlIGFuaW1hdGFibGUgdG8gJHtkfSB2aWEgdGhlIFxcYHN0eWxlXFxgIHByb3BlcnR5LmApO2xldCBmPXtrZXlmcmFtZXM6Yyx2ZWxvY2l0eTplLmdldFZlbG9jaXR5KCksZWFzZTpcImVhc2VPdXRcIiwuLi5hLGRlbGF5Oi11LG9uVXBkYXRlOnQ9PntlLnNldCh0KSxhLm9uVXBkYXRlJiZhLm9uVXBkYXRlKHQpfSxvbkNvbXBsZXRlOigpPT57cigpLGEub25Db21wbGV0ZSYmYS5vbkNvbXBsZXRlKCl9fTtpZihmdW5jdGlvbih7d2hlbjp0LGRlbGF5OmUsZGVsYXlDaGlsZHJlbjpuLHN0YWdnZXJDaGlsZHJlbjpzLHN0YWdnZXJEaXJlY3Rpb246aSxyZXBlYXQ6byxyZXBlYXRUeXBlOnIscmVwZWF0RGVsYXk6YSxmcm9tOmwsZWxhcHNlZDp1LC4uLmN9KXtyZXR1cm4hIU9iamVjdC5rZXlzKGMpLmxlbmd0aH0oYSl8fChmPXsuLi5mLC4uLk1lKHQsZil9KSxmLmR1cmF0aW9uJiYoZi5kdXJhdGlvbj1DdChmLmR1cmF0aW9uKSksZi5yZXBlYXREZWxheSYmKGYucmVwZWF0RGVsYXk9Q3QoZi5yZXBlYXREZWxheSkpLCFtfHwhcHx8ITE9PT1hLnR5cGUpcmV0dXJuIGZ1bmN0aW9uKHtrZXlmcmFtZXM6dCxkZWxheTplLG9uVXBkYXRlOnMsb25Db21wbGV0ZTppfSl7Y29uc3Qgbz0oKT0+KHMmJnModFt0Lmxlbmd0aC0xXSksaSYmaSgpLHt0aW1lOjAsc3BlZWQ6MSxkdXJhdGlvbjowLHBsYXk6bixwYXVzZTpuLHN0b3A6bix0aGVuOnQ9Pih0KCksUHJvbWlzZS5yZXNvbHZlKCkpLGNhbmNlbDpuLGNvbXBsZXRlOm59KTtyZXR1cm4gZT9TZSh7a2V5ZnJhbWVzOlswLDFdLGR1cmF0aW9uOjAsZGVsYXk6ZSxvbkNvbXBsZXRlOm99KTpvKCl9KGYpO2lmKGUub3duZXImJmUub3duZXIuY3VycmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50JiYhZS5vd25lci5nZXRQcm9wcygpLm9uVXBkYXRlKXtjb25zdCBzPWZ1bmN0aW9uKHQsZSx7b25VcGRhdGU6cyxvbkNvbXBsZXRlOmksLi4ub30pe2lmKCF3ZSgpfHwhRWUuaGFzKGUpfHxvLnJlcGVhdERlbGF5fHxcIm1pcnJvclwiPT09by5yZXBlYXRUeXBlfHwwPT09by5kYW1waW5nfHxcImluZXJ0aWFcIj09PW8udHlwZSlyZXR1cm4hMTtsZXQgcixhLGw9ITE7Y29uc3QgdT0oKT0+e2E9bmV3IFByb21pc2UoKHQ9PntyPXR9KSl9O3UoKTtsZXR7a2V5ZnJhbWVzOmMsZHVyYXRpb246aD0zMDAsZWFzZTpkLHRpbWVzOm19PW87aWYoKCh0LGUpPT5cInNwcmluZ1wiPT09ZS50eXBlfHxcImJhY2tncm91bmRDb2xvclwiPT09dHx8IWt0KGUuZWFzZSkpKGUsbykpe2NvbnN0IHQ9U2Uoey4uLm8scmVwZWF0OjAsZGVsYXk6MH0pO2xldCBlPXtkb25lOiExLHZhbHVlOmNbMF19O2NvbnN0IG49W107bGV0IHM9MDtmb3IoOyFlLmRvbmUmJnM8MmU0OyllPXQuc2FtcGxlKHMpLG4ucHVzaChlLnZhbHVlKSxzKz0xMDttPXZvaWQgMCxjPW4saD1zLTEwLGQ9XCJsaW5lYXJcIn1jb25zdCBwPWZ1bmN0aW9uKHQsZSxuLHtkZWxheTpzPTAsZHVyYXRpb246aSxyZXBlYXQ6bz0wLHJlcGVhdFR5cGU6cj1cImxvb3BcIixlYXNlOmEsdGltZXM6bH09e30pe2NvbnN0IHU9e1tlXTpufTtsJiYodS5vZmZzZXQ9bCk7Y29uc3QgYz1qdChhKTtyZXR1cm4gQXJyYXkuaXNBcnJheShjKSYmKHUuZWFzaW5nPWMpLHQuYW5pbWF0ZSh1LHtkZWxheTpzLGR1cmF0aW9uOmksZWFzaW5nOkFycmF5LmlzQXJyYXkoYyk/XCJsaW5lYXJcIjpjLGZpbGw6XCJib3RoXCIsaXRlcmF0aW9uczpvKzEsZGlyZWN0aW9uOlwicmV2ZXJzZVwiPT09cj9cImFsdGVybmF0ZVwiOlwibm9ybWFsXCJ9KX0odC5vd25lci5jdXJyZW50LGUsYyx7Li4ubyxkdXJhdGlvbjpoLGVhc2U6ZCx0aW1lczptfSk7by5zeW5jU3RhcnQmJihwLnN0YXJ0VGltZT14LmlzUHJvY2Vzc2luZz94LnRpbWVzdGFtcDpkb2N1bWVudC50aW1lbGluZT9kb2N1bWVudC50aW1lbGluZS5jdXJyZW50VGltZTpwZXJmb3JtYW5jZS5ub3coKSk7Y29uc3QgZj0oKT0+cC5jYW5jZWwoKSxnPSgpPT57eS51cGRhdGUoZikscigpLHUoKX07cmV0dXJuIHAub25maW5pc2g9KCk9Pnt0LnNldChmdW5jdGlvbih0LHtyZXBlYXQ6ZSxyZXBlYXRUeXBlOm49XCJsb29wXCJ9KXtyZXR1cm4gdFtlJiZcImxvb3BcIiE9PW4mJmUlMj09MT8wOnQubGVuZ3RoLTFdfShjLG8pKSxpJiZpKCksZygpfSx7dGhlbjoodCxlKT0+YS50aGVuKHQsZSksYXR0YWNoVGltZWxpbmU6dD0+KHAudGltZWxpbmU9dCxwLm9uZmluaXNoPW51bGwsbiksZ2V0IHRpbWUoKXtyZXR1cm4gTXQocC5jdXJyZW50VGltZXx8MCl9LHNldCB0aW1lKHQpe3AuY3VycmVudFRpbWU9Q3QodCl9LGdldCBzcGVlZCgpe3JldHVybiBwLnBsYXliYWNrUmF0ZX0sc2V0IHNwZWVkKHQpe3AucGxheWJhY2tSYXRlPXR9LGdldCBkdXJhdGlvbigpe3JldHVybiBNdChoKX0scGxheTooKT0+e2x8fChwLnBsYXkoKSx2KGYpKX0scGF1c2U6KCk9PnAucGF1c2UoKSxzdG9wOigpPT57aWYobD0hMCxcImlkbGVcIj09PXAucGxheVN0YXRlKXJldHVybjtjb25zdHtjdXJyZW50VGltZTplfT1wO2lmKGUpe2NvbnN0IG49U2Uoey4uLm8sYXV0b3BsYXk6ITF9KTt0LnNldFdpdGhWZWxvY2l0eShuLnNhbXBsZShlLTEwKS52YWx1ZSxuLnNhbXBsZShlKS52YWx1ZSwxMCl9ZygpfSxjb21wbGV0ZTooKT0+cC5maW5pc2goKSxjYW5jZWw6Z319KGUsdCxmKTtpZihzKXJldHVybiBzfXJldHVybiBTZShmKX0samU9dD0+Qm9vbGVhbih0JiZ0LmdldFZlbG9jaXR5KTtmdW5jdGlvbiBCZSh0KXtyZXR1cm4gQm9vbGVhbihqZSh0KSYmdC5hZGQpfWZ1bmN0aW9uIEZlKHtwcm90ZWN0ZWRLZXlzOnQsbmVlZHNBbmltYXRpbmc6ZX0sbil7Y29uc3Qgcz10Lmhhc093blByb3BlcnR5KG4pJiYhMCE9PWVbbl07cmV0dXJuIGVbbl09ITEsc31mdW5jdGlvbiBPZSh0LGUse2RlbGF5Om49MCx0cmFuc2l0aW9uT3ZlcnJpZGU6cyx0eXBlOml9PXt9KXtsZXR7dHJhbnNpdGlvbjpvPXQuZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSx0cmFuc2l0aW9uRW5kOnIsLi4uYX09dC5tYWtlVGFyZ2V0QW5pbWF0YWJsZShlKTtjb25zdCBsPXQuZ2V0VmFsdWUoXCJ3aWxsQ2hhbmdlXCIpO3MmJihvPXMpO2NvbnN0IHU9W10sYz1pJiZ0LmFuaW1hdGlvblN0YXRlJiZ0LmFuaW1hdGlvblN0YXRlLmdldFN0YXRlKClbaV07Zm9yKGNvbnN0IGUgaW4gYSl7Y29uc3Qgcz10LmdldFZhbHVlKGUpLGk9YVtlXTtpZighc3x8dm9pZCAwPT09aXx8YyYmRmUoYyxlKSljb250aW51ZTtjb25zdCByPXtkZWxheTpuLGVsYXBzZWQ6MCwuLi5vfTtpZih3aW5kb3cuSGFuZG9mZkFwcGVhckFuaW1hdGlvbnMmJiFzLmhhc0FuaW1hdGVkKXtjb25zdCBuPXQuZ2V0UHJvcHMoKVtWdF07biYmKHIuZWxhcHNlZD13aW5kb3cuSGFuZG9mZkFwcGVhckFuaW1hdGlvbnMobixlLHMseSksci5zeW5jU3RhcnQ9ITApfXMuc3RhcnQoTGUoZSxzLGksdC5zaG91bGRSZWR1Y2VNb3Rpb24mJkV0LmhhcyhlKT97dHlwZTohMX06cikpO2NvbnN0IGg9cy5hbmltYXRpb247QmUobCkmJihsLmFkZChlKSxoLnRoZW4oKCgpPT5sLnJlbW92ZShlKSkpKSx1LnB1c2goaCl9cmV0dXJuIHImJlByb21pc2UuYWxsKHUpLnRoZW4oKCgpPT57ciYmYnQodCxyKX0pKSx1fWZ1bmN0aW9uIEllKHQsZSxuPXt9KXtjb25zdCBzPXh0KHQsZSxuLmN1c3RvbSk7bGV0e3RyYW5zaXRpb246aT10LmdldERlZmF1bHRUcmFuc2l0aW9uKCl8fHt9fT1zfHx7fTtuLnRyYW5zaXRpb25PdmVycmlkZSYmKGk9bi50cmFuc2l0aW9uT3ZlcnJpZGUpO2NvbnN0IG89cz8oKT0+UHJvbWlzZS5hbGwoT2UodCxzLG4pKTooKT0+UHJvbWlzZS5yZXNvbHZlKCkscj10LnZhcmlhbnRDaGlsZHJlbiYmdC52YXJpYW50Q2hpbGRyZW4uc2l6ZT8ocz0wKT0+e2NvbnN0e2RlbGF5Q2hpbGRyZW46bz0wLHN0YWdnZXJDaGlsZHJlbjpyLHN0YWdnZXJEaXJlY3Rpb246YX09aTtyZXR1cm4gZnVuY3Rpb24odCxlLG49MCxzPTAsaT0xLG8pe2NvbnN0IHI9W10sYT0odC52YXJpYW50Q2hpbGRyZW4uc2l6ZS0xKSpzLGw9MT09PWk/KHQ9MCk9PnQqczoodD0wKT0+YS10KnM7cmV0dXJuIEFycmF5LmZyb20odC52YXJpYW50Q2hpbGRyZW4pLnNvcnQoVWUpLmZvckVhY2goKCh0LHMpPT57dC5ub3RpZnkoXCJBbmltYXRpb25TdGFydFwiLGUpLHIucHVzaChJZSh0LGUsey4uLm8sZGVsYXk6bitsKHMpfSkudGhlbigoKCk9PnQubm90aWZ5KFwiQW5pbWF0aW9uQ29tcGxldGVcIixlKSkpKX0pKSxQcm9taXNlLmFsbChyKX0odCxlLG8rcyxyLGEsbil9OigpPT5Qcm9taXNlLnJlc29sdmUoKSx7d2hlbjphfT1pO2lmKGEpe2NvbnN0W3QsZV09XCJiZWZvcmVDaGlsZHJlblwiPT09YT9bbyxyXTpbcixvXTtyZXR1cm4gdCgpLnRoZW4oKCgpPT5lKCkpKX1yZXR1cm4gUHJvbWlzZS5hbGwoW28oKSxyKG4uZGVsYXkpXSl9ZnVuY3Rpb24gVWUodCxlKXtyZXR1cm4gdC5zb3J0Tm9kZVBvc2l0aW9uKGUpfWZ1bmN0aW9uIE5lKHQsZSxuPXt9KXtsZXQgcztpZih0Lm5vdGlmeShcIkFuaW1hdGlvblN0YXJ0XCIsZSksQXJyYXkuaXNBcnJheShlKSl7Y29uc3QgaT1lLm1hcCgoZT0+SWUodCxlLG4pKSk7cz1Qcm9taXNlLmFsbChpKX1lbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXM9SWUodCxlLG4pO2Vsc2V7Y29uc3QgaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlP3h0KHQsZSxuLmN1c3RvbSk6ZTtzPVByb21pc2UuYWxsKE9lKHQsaSxuKSl9cmV0dXJuIHMudGhlbigoKCk9PnQubm90aWZ5KFwiQW5pbWF0aW9uQ29tcGxldGVcIixlKSkpfWZ1bmN0aW9uICRlKCl7bGV0IHQ9ITE7Y29uc3QgZT1uZXcgU2V0LG49e3N1YnNjcmliZTp0PT4oZS5hZGQodCksKCk9PntlLmRlbGV0ZSh0KX0pLHN0YXJ0KG4scyl7cih0LFwiY29udHJvbHMuc3RhcnQoKSBzaG91bGQgb25seSBiZSBjYWxsZWQgYWZ0ZXIgYSBjb21wb25lbnQgaGFzIG1vdW50ZWQuIENvbnNpZGVyIGNhbGxpbmcgd2l0aGluIGEgdXNlRWZmZWN0IGhvb2suXCIpO2NvbnN0IGk9W107cmV0dXJuIGUuZm9yRWFjaCgodD0+e2kucHVzaChOZSh0LG4se3RyYW5zaXRpb25PdmVycmlkZTpzfSkpfSkpLFByb21pc2UuYWxsKGkpfSxzZXQ6bj0+KHIodCxcImNvbnRyb2xzLnNldCgpIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBhZnRlciBhIGNvbXBvbmVudCBoYXMgbW91bnRlZC4gQ29uc2lkZXIgY2FsbGluZyB3aXRoaW4gYSB1c2VFZmZlY3QgaG9vay5cIiksZS5mb3JFYWNoKCh0PT57IWZ1bmN0aW9uKHQsZSl7QXJyYXkuaXNBcnJheShlKT9UdCh0LGUpOlwic3RyaW5nXCI9PXR5cGVvZiBlP1R0KHQsW2VdKTpidCh0LGUpfSh0LG4pfSkpKSxzdG9wKCl7ZS5mb3JFYWNoKCh0PT57IWZ1bmN0aW9uKHQpe3QudmFsdWVzLmZvckVhY2goKHQ9PnQuc3RvcCgpKSl9KHQpfSkpfSxtb3VudDooKT0+KHQ9ITAsKCk9Pnt0PSExLG4uc3RvcCgpfSl9O3JldHVybiBufWZ1bmN0aW9uIFdlKGUpe2NvbnN0IG49KDAsdC51c2VSZWYpKG51bGwpO3JldHVybiBudWxsPT09bi5jdXJyZW50JiYobi5jdXJyZW50PWUoKSksbi5jdXJyZW50fWNvbnN0IEhlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCx6ZT1IZT90LnVzZUxheW91dEVmZmVjdDp0LnVzZUVmZmVjdCxZZT0oMCx0LmNyZWF0ZUNvbnRleHQpKHt0cmFuc2Zvcm1QYWdlUG9pbnQ6dD0+dCxpc1N0YXRpYzohMSxyZWR1Y2VkTW90aW9uOlwibmV2ZXJcIn0pLFhlPSgwLHQuY3JlYXRlQ29udGV4dCkoe30pLEdlPSgwLHQuY3JlYXRlQ29udGV4dCkobnVsbCkscWU9KDAsdC5jcmVhdGVDb250ZXh0KSh7c3RyaWN0OiExfSk7ZnVuY3Rpb24gWmUodCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHQmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LFwiY3VycmVudFwiKX1mdW5jdGlvbiBLZSh0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdHx8QXJyYXkuaXNBcnJheSh0KX1mdW5jdGlvbiBfZSh0KXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC5zdGFydH1jb25zdCBKZT1bXCJhbmltYXRlXCIsXCJ3aGlsZUluVmlld1wiLFwid2hpbGVGb2N1c1wiLFwid2hpbGVIb3ZlclwiLFwid2hpbGVUYXBcIixcIndoaWxlRHJhZ1wiLFwiZXhpdFwiXSxRZT1bXCJpbml0aWFsXCIsLi4uSmVdO2Z1bmN0aW9uIHRuKHQpe3JldHVybiBfZSh0LmFuaW1hdGUpfHxRZS5zb21lKChlPT5LZSh0W2VdKSkpfWZ1bmN0aW9uIGVuKHQpe3JldHVybiBCb29sZWFuKHRuKHQpfHx0LnZhcmlhbnRzKX1mdW5jdGlvbiBubih0KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KT90LmpvaW4oXCIgXCIpOnR9Y29uc3Qgc249e2FuaW1hdGlvbjpbXCJhbmltYXRlXCIsXCJ2YXJpYW50c1wiLFwid2hpbGVIb3ZlclwiLFwid2hpbGVUYXBcIixcImV4aXRcIixcIndoaWxlSW5WaWV3XCIsXCJ3aGlsZUZvY3VzXCIsXCJ3aGlsZURyYWdcIl0sZXhpdDpbXCJleGl0XCJdLGRyYWc6W1wiZHJhZ1wiLFwiZHJhZ0NvbnRyb2xzXCJdLGZvY3VzOltcIndoaWxlRm9jdXNcIl0saG92ZXI6W1wid2hpbGVIb3ZlclwiLFwib25Ib3ZlclN0YXJ0XCIsXCJvbkhvdmVyRW5kXCJdLHRhcDpbXCJ3aGlsZVRhcFwiLFwib25UYXBcIixcIm9uVGFwU3RhcnRcIixcIm9uVGFwQ2FuY2VsXCJdLHBhbjpbXCJvblBhblwiLFwib25QYW5TdGFydFwiLFwib25QYW5TZXNzaW9uU3RhcnRcIixcIm9uUGFuRW5kXCJdLGluVmlldzpbXCJ3aGlsZUluVmlld1wiLFwib25WaWV3cG9ydEVudGVyXCIsXCJvblZpZXdwb3J0TGVhdmVcIl0sbGF5b3V0OltcImxheW91dFwiLFwibGF5b3V0SWRcIl19LG9uPXt9O2Zvcihjb25zdCB0IGluIHNuKW9uW3RdPXtpc0VuYWJsZWQ6ZT0+c25bdF0uc29tZSgodD0+ISFlW3RdKSl9O2NvbnN0IHJuPSgwLHQuY3JlYXRlQ29udGV4dCkoe30pLGFuPSgwLHQuY3JlYXRlQ29udGV4dCkoe30pLGxuPVN5bWJvbC5mb3IoXCJtb3Rpb25Db21wb25lbnRTeW1ib2xcIik7ZnVuY3Rpb24gdW4oe3ByZWxvYWRlZEZlYXR1cmVzOmUsY3JlYXRlVmlzdWFsRWxlbWVudDpuLHVzZVJlbmRlcjpzLHVzZVZpc3VhbFN0YXRlOmksQ29tcG9uZW50Om99KXtlJiZmdW5jdGlvbih0KXtmb3IoY29uc3QgZSBpbiB0KW9uW2VdPXsuLi5vbltlXSwuLi50W2VdfX0oZSk7Y29uc3Qgcj0oMCx0LmZvcndhcmRSZWYpKChmdW5jdGlvbihyLGEpe2xldCBsO2NvbnN0IHU9ey4uLigwLHQudXNlQ29udGV4dCkoWWUpLC4uLnIsbGF5b3V0SWQ6Y24ocil9LHtpc1N0YXRpYzpjfT11LGg9ZnVuY3Rpb24oZSl7Y29uc3R7aW5pdGlhbDpuLGFuaW1hdGU6c309ZnVuY3Rpb24odCxlKXtpZih0bih0KSl7Y29uc3R7aW5pdGlhbDplLGFuaW1hdGU6bn09dDtyZXR1cm57aW5pdGlhbDohMT09PWV8fEtlKGUpP2U6dm9pZCAwLGFuaW1hdGU6S2Uobik/bjp2b2lkIDB9fXJldHVybiExIT09dC5pbmhlcml0P2U6e319KGUsKDAsdC51c2VDb250ZXh0KShYZSkpO3JldHVybigwLHQudXNlTWVtbykoKCgpPT4oe2luaXRpYWw6bixhbmltYXRlOnN9KSksW25uKG4pLG5uKHMpXSl9KHIpLGQ9aShyLGMpO2lmKCFjJiZIZSl7aC52aXN1YWxFbGVtZW50PWZ1bmN0aW9uKGUsbixzLGkpe2NvbnN0e3Zpc3VhbEVsZW1lbnQ6b309KDAsdC51c2VDb250ZXh0KShYZSkscj0oMCx0LnVzZUNvbnRleHQpKHFlKSxhPSgwLHQudXNlQ29udGV4dCkoR2UpLGw9KDAsdC51c2VDb250ZXh0KShZZSkucmVkdWNlZE1vdGlvbix1PSgwLHQudXNlUmVmKSgpO2k9aXx8ci5yZW5kZXJlciwhdS5jdXJyZW50JiZpJiYodS5jdXJyZW50PWkoZSx7dmlzdWFsU3RhdGU6bixwYXJlbnQ6byxwcm9wczpzLHByZXNlbmNlQ29udGV4dDphLGJsb2NrSW5pdGlhbEFuaW1hdGlvbjohIWEmJiExPT09YS5pbml0aWFsLHJlZHVjZWRNb3Rpb25Db25maWc6bH0pKTtjb25zdCBjPXUuY3VycmVudDsoMCx0LnVzZUluc2VydGlvbkVmZmVjdCkoKCgpPT57YyYmYy51cGRhdGUocyxhKX0pKTtjb25zdCBoPSgwLHQudXNlUmVmKShCb29sZWFuKHdpbmRvdy5IYW5kb2ZmQXBwZWFyQW5pbWF0aW9ucykpO3JldHVybiB6ZSgoKCk9PntjJiYoYy5yZW5kZXIoKSxoLmN1cnJlbnQmJmMuYW5pbWF0aW9uU3RhdGUmJmMuYW5pbWF0aW9uU3RhdGUuYW5pbWF0ZUNoYW5nZXMoKSl9KSksKDAsdC51c2VFZmZlY3QpKCgoKT0+e2MmJihjLnVwZGF0ZUZlYXR1cmVzKCksIWguY3VycmVudCYmYy5hbmltYXRpb25TdGF0ZSYmYy5hbmltYXRpb25TdGF0ZS5hbmltYXRlQ2hhbmdlcygpLHdpbmRvdy5IYW5kb2ZmQXBwZWFyQW5pbWF0aW9ucz12b2lkIDAsaC5jdXJyZW50PSExKX0pKSxjfShvLGQsdSxuKTtjb25zdCBzPSgwLHQudXNlQ29udGV4dCkoYW4pLGk9KDAsdC51c2VDb250ZXh0KShxZSkuc3RyaWN0O2gudmlzdWFsRWxlbWVudCYmKGw9aC52aXN1YWxFbGVtZW50LmxvYWRGZWF0dXJlcyh1LGksZSxzKSl9cmV0dXJuIHQuY3JlYXRlRWxlbWVudChYZS5Qcm92aWRlcix7dmFsdWU6aH0sbCYmaC52aXN1YWxFbGVtZW50P3QuY3JlYXRlRWxlbWVudChsLHt2aXN1YWxFbGVtZW50OmgudmlzdWFsRWxlbWVudCwuLi51fSk6bnVsbCxzKG8scixmdW5jdGlvbihlLG4scyl7cmV0dXJuKDAsdC51c2VDYWxsYmFjaykoKHQ9Pnt0JiZlLm1vdW50JiZlLm1vdW50KHQpLG4mJih0P24ubW91bnQodCk6bi51bm1vdW50KCkpLHMmJihcImZ1bmN0aW9uXCI9PXR5cGVvZiBzP3ModCk6WmUocykmJihzLmN1cnJlbnQ9dCkpfSksW25dKX0oZCxoLnZpc3VhbEVsZW1lbnQsYSksZCxjLGgudmlzdWFsRWxlbWVudCkpfSkpO3JldHVybiByW2xuXT1vLHJ9ZnVuY3Rpb24gY24oe2xheW91dElkOmV9KXtjb25zdCBuPSgwLHQudXNlQ29udGV4dCkocm4pLmlkO3JldHVybiBuJiZ2b2lkIDAhPT1lP24rXCItXCIrZTplfWZ1bmN0aW9uIGhuKHQpe2Z1bmN0aW9uIGUoZSxuPXt9KXtyZXR1cm4gdW4odChlLG4pKX1pZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUHJveHkpcmV0dXJuIGU7Y29uc3Qgbj1uZXcgTWFwO3JldHVybiBuZXcgUHJveHkoZSx7Z2V0Oih0LHMpPT4obi5oYXMocyl8fG4uc2V0KHMsZShzKSksbi5nZXQocykpfSl9Y29uc3QgZG49W1wiYW5pbWF0ZVwiLFwiY2lyY2xlXCIsXCJkZWZzXCIsXCJkZXNjXCIsXCJlbGxpcHNlXCIsXCJnXCIsXCJpbWFnZVwiLFwibGluZVwiLFwiZmlsdGVyXCIsXCJtYXJrZXJcIixcIm1hc2tcIixcIm1ldGFkYXRhXCIsXCJwYXRoXCIsXCJwYXR0ZXJuXCIsXCJwb2x5Z29uXCIsXCJwb2x5bGluZVwiLFwicmVjdFwiLFwic3RvcFwiLFwic3dpdGNoXCIsXCJzeW1ib2xcIixcInN2Z1wiLFwidGV4dFwiLFwidHNwYW5cIixcInVzZVwiLFwidmlld1wiXTtmdW5jdGlvbiBtbih0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdCYmIXQuaW5jbHVkZXMoXCItXCIpJiYhIShkbi5pbmRleE9mKHQpPi0xfHwvW0EtWl0vLnRlc3QodCkpfWNvbnN0IHBuPXt9O2Z1bmN0aW9uIGZuKHQse2xheW91dDplLGxheW91dElkOm59KXtyZXR1cm4gRXQuaGFzKHQpfHx0LnN0YXJ0c1dpdGgoXCJvcmlnaW5cIil8fChlfHx2b2lkIDAhPT1uKSYmKCEhcG5bdF18fFwib3BhY2l0eVwiPT09dCl9Y29uc3QgZ249e3g6XCJ0cmFuc2xhdGVYXCIseTpcInRyYW5zbGF0ZVlcIix6OlwidHJhbnNsYXRlWlwiLHRyYW5zZm9ybVBlcnNwZWN0aXZlOlwicGVyc3BlY3RpdmVcIn0seW49d3QubGVuZ3RoLHZuPSh0LGUpPT5lJiZcIm51bWJlclwiPT10eXBlb2YgdD9lLnRyYW5zZm9ybSh0KTp0O2Z1bmN0aW9uIHhuKHQsZSxuLHMpe2NvbnN0e3N0eWxlOmksdmFyczpvLHRyYW5zZm9ybTpyLHRyYW5zZm9ybU9yaWdpbjphfT10O2xldCBsPSExLHU9ITEsYz0hMDtmb3IoY29uc3QgdCBpbiBlKXtjb25zdCBuPWVbdF07aWYoRSh0KSl7b1t0XT1uO2NvbnRpbnVlfWNvbnN0IHM9Y3RbdF0saD12bihuLHMpO2lmKEV0Lmhhcyh0KSl7aWYobD0hMCxyW3RdPWgsIWMpY29udGludWU7biE9PShzLmRlZmF1bHR8fDApJiYoYz0hMSl9ZWxzZSB0LnN0YXJ0c1dpdGgoXCJvcmlnaW5cIik/KHU9ITAsYVt0XT1oKTppW3RdPWh9aWYoZS50cmFuc2Zvcm18fChsfHxzP2kudHJhbnNmb3JtPWZ1bmN0aW9uKHQse2VuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOmU9ITAsYWxsb3dUcmFuc2Zvcm1Ob25lOm49ITB9LHMsaSl7bGV0IG89XCJcIjtmb3IobGV0IGU9MDtlPHluO2UrKyl7Y29uc3Qgbj13dFtlXTt2b2lkIDAhPT10W25dJiYobys9YCR7Z25bbl18fG59KCR7dFtuXX0pIGApfXJldHVybiBlJiYhdC56JiYobys9XCJ0cmFuc2xhdGVaKDApXCIpLG89by50cmltKCksaT9vPWkodCxzP1wiXCI6byk6biYmcyYmKG89XCJub25lXCIpLG99KHQudHJhbnNmb3JtLG4sYyxzKTppLnRyYW5zZm9ybSYmKGkudHJhbnNmb3JtPVwibm9uZVwiKSksdSl7Y29uc3R7b3JpZ2luWDp0PVwiNTAlXCIsb3JpZ2luWTplPVwiNTAlXCIsb3JpZ2luWjpuPTB9PWE7aS50cmFuc2Zvcm1PcmlnaW49YCR7dH0gJHtlfSAke259YH19ZnVuY3Rpb24gUG4odCxlLG4pe2Zvcihjb25zdCBzIGluIGUpamUoZVtzXSl8fGZuKHMsbil8fCh0W3NdPWVbc10pfWZ1bmN0aW9uIGJuKGUsbixzKXtjb25zdCBpPXt9LG89ZnVuY3Rpb24oZSxuLHMpe2NvbnN0IGk9e307cmV0dXJuIFBuKGksZS5zdHlsZXx8e30sZSksT2JqZWN0LmFzc2lnbihpLGZ1bmN0aW9uKHt0cmFuc2Zvcm1UZW1wbGF0ZTplfSxuLHMpe3JldHVybigwLHQudXNlTWVtbykoKCgpPT57Y29uc3QgdD17c3R5bGU6e30sdHJhbnNmb3JtOnt9LHRyYW5zZm9ybU9yaWdpbjp7fSx2YXJzOnt9fTtyZXR1cm4geG4odCxuLHtlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjohc30sZSksT2JqZWN0LmFzc2lnbih7fSx0LnZhcnMsdC5zdHlsZSl9KSxbbl0pfShlLG4scykpLGUudHJhbnNmb3JtVmFsdWVzP2UudHJhbnNmb3JtVmFsdWVzKGkpOml9KGUsbixzKTtyZXR1cm4gZS5kcmFnJiYhMSE9PWUuZHJhZ0xpc3RlbmVyJiYoaS5kcmFnZ2FibGU9ITEsby51c2VyU2VsZWN0PW8uV2Via2l0VXNlclNlbGVjdD1vLldlYmtpdFRvdWNoQ2FsbG91dD1cIm5vbmVcIixvLnRvdWNoQWN0aW9uPSEwPT09ZS5kcmFnP1wibm9uZVwiOlwicGFuLVwiKyhcInhcIj09PWUuZHJhZz9cInlcIjpcInhcIikpLHZvaWQgMD09PWUudGFiSW5kZXgmJihlLm9uVGFwfHxlLm9uVGFwU3RhcnR8fGUud2hpbGVUYXApJiYoaS50YWJJbmRleD0wKSxpLnN0eWxlPW8saX1jb25zdCBUbj1uZXcgU2V0KFtcImFuaW1hdGVcIixcImV4aXRcIixcInZhcmlhbnRzXCIsXCJpbml0aWFsXCIsXCJzdHlsZVwiLFwidmFsdWVzXCIsXCJ2YXJpYW50c1wiLFwidHJhbnNpdGlvblwiLFwidHJhbnNmb3JtVGVtcGxhdGVcIixcInRyYW5zZm9ybVZhbHVlc1wiLFwiY3VzdG9tXCIsXCJpbmhlcml0XCIsXCJvbkxheW91dEFuaW1hdGlvblN0YXJ0XCIsXCJvbkxheW91dEFuaW1hdGlvbkNvbXBsZXRlXCIsXCJvbkxheW91dE1lYXN1cmVcIixcIm9uQmVmb3JlTGF5b3V0TWVhc3VyZVwiLFwib25BbmltYXRpb25TdGFydFwiLFwib25BbmltYXRpb25Db21wbGV0ZVwiLFwib25VcGRhdGVcIixcIm9uRHJhZ1N0YXJ0XCIsXCJvbkRyYWdcIixcIm9uRHJhZ0VuZFwiLFwib25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzXCIsXCJvbkRpcmVjdGlvbkxvY2tcIixcIm9uRHJhZ1RyYW5zaXRpb25FbmRcIixcIl9kcmFnWFwiLFwiX2RyYWdZXCIsXCJvbkhvdmVyU3RhcnRcIixcIm9uSG92ZXJFbmRcIixcIm9uVmlld3BvcnRFbnRlclwiLFwib25WaWV3cG9ydExlYXZlXCIsXCJpZ25vcmVTdHJpY3RcIixcInZpZXdwb3J0XCJdKTtmdW5jdGlvbiBTbih0KXtyZXR1cm4gdC5zdGFydHNXaXRoKFwid2hpbGVcIil8fHQuc3RhcnRzV2l0aChcImRyYWdcIikmJlwiZHJhZ2dhYmxlXCIhPT10fHx0LnN0YXJ0c1dpdGgoXCJsYXlvdXRcIil8fHQuc3RhcnRzV2l0aChcIm9uVGFwXCIpfHx0LnN0YXJ0c1dpdGgoXCJvblBhblwiKXx8VG4uaGFzKHQpfWxldCB3bj10PT4hU24odCk7dHJ5eyhFbj1yZXF1aXJlKFwiQGVtb3Rpb24vaXMtcHJvcC12YWxpZFwiKS5kZWZhdWx0KSYmKHduPXQ9PnQuc3RhcnRzV2l0aChcIm9uXCIpPyFTbih0KTpFbih0KSl9Y2F0Y2godCl7fXZhciBFbjtmdW5jdGlvbiBBbih0LGUsbil7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQ/dDp6LnRyYW5zZm9ybShlK24qdCl9Y29uc3QgVm49e29mZnNldDpcInN0cm9rZS1kYXNob2Zmc2V0XCIsYXJyYXk6XCJzdHJva2UtZGFzaGFycmF5XCJ9LENuPXtvZmZzZXQ6XCJzdHJva2VEYXNob2Zmc2V0XCIsYXJyYXk6XCJzdHJva2VEYXNoYXJyYXlcIn07ZnVuY3Rpb24gTW4odCx7YXR0clg6ZSxhdHRyWTpuLGF0dHJTY2FsZTpzLG9yaWdpblg6aSxvcmlnaW5ZOm8scGF0aExlbmd0aDpyLHBhdGhTcGFjaW5nOmE9MSxwYXRoT2Zmc2V0Omw9MCwuLi51fSxjLGgsZCl7aWYoeG4odCx1LGMsZCksaClyZXR1cm4gdm9pZCh0LnN0eWxlLnZpZXdCb3gmJih0LmF0dHJzLnZpZXdCb3g9dC5zdHlsZS52aWV3Qm94KSk7dC5hdHRycz10LnN0eWxlLHQuc3R5bGU9e307Y29uc3R7YXR0cnM6bSxzdHlsZTpwLGRpbWVuc2lvbnM6Zn09dDttLnRyYW5zZm9ybSYmKGYmJihwLnRyYW5zZm9ybT1tLnRyYW5zZm9ybSksZGVsZXRlIG0udHJhbnNmb3JtKSxmJiYodm9pZCAwIT09aXx8dm9pZCAwIT09b3x8cC50cmFuc2Zvcm0pJiYocC50cmFuc2Zvcm1PcmlnaW49ZnVuY3Rpb24odCxlLG4pe3JldHVybmAke0FuKGUsdC54LHQud2lkdGgpfSAke0FuKG4sdC55LHQuaGVpZ2h0KX1gfShmLHZvaWQgMCE9PWk/aTouNSx2b2lkIDAhPT1vP286LjUpKSx2b2lkIDAhPT1lJiYobS54PWUpLHZvaWQgMCE9PW4mJihtLnk9biksdm9pZCAwIT09cyYmKG0uc2NhbGU9cyksdm9pZCAwIT09ciYmZnVuY3Rpb24odCxlLG49MSxzPTAsaT0hMCl7dC5wYXRoTGVuZ3RoPTE7Y29uc3Qgbz1pP1ZuOkNuO3Rbby5vZmZzZXRdPXoudHJhbnNmb3JtKC1zKTtjb25zdCByPXoudHJhbnNmb3JtKGUpLGE9ei50cmFuc2Zvcm0obik7dFtvLmFycmF5XT1gJHtyfSAke2F9YH0obSxyLGEsbCwhMSl9Y29uc3QgRG49dD0+XCJzdHJpbmdcIj09dHlwZW9mIHQmJlwic3ZnXCI9PT10LnRvTG93ZXJDYXNlKCk7ZnVuY3Rpb24ga24oZSxuLHMsaSl7Y29uc3Qgbz0oMCx0LnVzZU1lbW8pKCgoKT0+e2NvbnN0IHQ9e3N0eWxlOnt9LHRyYW5zZm9ybTp7fSx0cmFuc2Zvcm1PcmlnaW46e30sdmFyczp7fSxhdHRyczp7fX07cmV0dXJuIE1uKHQsbix7ZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246ITF9LERuKGkpLGUudHJhbnNmb3JtVGVtcGxhdGUpLHsuLi50LmF0dHJzLHN0eWxlOnsuLi50LnN0eWxlfX19KSxbbl0pO2lmKGUuc3R5bGUpe2NvbnN0IHQ9e307UG4odCxlLnN0eWxlLGUpLG8uc3R5bGU9ey4uLnQsLi4uby5zdHlsZX19cmV0dXJuIG99ZnVuY3Rpb24gUm4oZT0hMSl7cmV0dXJuKG4scyxpLHtsYXRlc3RWYWx1ZXM6b30scik9Pntjb25zdCBhPShtbihuKT9rbjpibikocyxvLHIsbiksbD17Li4uZnVuY3Rpb24odCxlLG4pe2NvbnN0IHM9e307Zm9yKGNvbnN0IGkgaW4gdClcInZhbHVlc1wiPT09aSYmXCJvYmplY3RcIj09dHlwZW9mIHQudmFsdWVzfHwod24oaSl8fCEwPT09biYmU24oaSl8fCFlJiYhU24oaSl8fHQuZHJhZ2dhYmxlJiZpLnN0YXJ0c1dpdGgoXCJvbkRyYWdcIikpJiYoc1tpXT10W2ldKTtyZXR1cm4gc30ocyxcInN0cmluZ1wiPT10eXBlb2YgbixlKSwuLi5hLHJlZjppfSx7Y2hpbGRyZW46dX09cyxjPSgwLHQudXNlTWVtbykoKCgpPT5qZSh1KT91LmdldCgpOnUpLFt1XSk7cmV0dXJuKDAsdC5jcmVhdGVFbGVtZW50KShuLHsuLi5sLGNoaWxkcmVuOmN9KX19ZnVuY3Rpb24gTG4odCx7c3R5bGU6ZSx2YXJzOm59LHMsaSl7T2JqZWN0LmFzc2lnbih0LnN0eWxlLGUsaSYmaS5nZXRQcm9qZWN0aW9uU3R5bGVzKHMpKTtmb3IoY29uc3QgZSBpbiBuKXQuc3R5bGUuc2V0UHJvcGVydHkoZSxuW2VdKX1jb25zdCBqbj1uZXcgU2V0KFtcImJhc2VGcmVxdWVuY3lcIixcImRpZmZ1c2VDb25zdGFudFwiLFwia2VybmVsTWF0cml4XCIsXCJrZXJuZWxVbml0TGVuZ3RoXCIsXCJrZXlTcGxpbmVzXCIsXCJrZXlUaW1lc1wiLFwibGltaXRpbmdDb25lQW5nbGVcIixcIm1hcmtlckhlaWdodFwiLFwibWFya2VyV2lkdGhcIixcIm51bU9jdGF2ZXNcIixcInRhcmdldFhcIixcInRhcmdldFlcIixcInN1cmZhY2VTY2FsZVwiLFwic3BlY3VsYXJDb25zdGFudFwiLFwic3BlY3VsYXJFeHBvbmVudFwiLFwic3RkRGV2aWF0aW9uXCIsXCJ0YWJsZVZhbHVlc1wiLFwidmlld0JveFwiLFwiZ3JhZGllbnRUcmFuc2Zvcm1cIixcInBhdGhMZW5ndGhcIixcInN0YXJ0T2Zmc2V0XCIsXCJ0ZXh0TGVuZ3RoXCIsXCJsZW5ndGhBZGp1c3RcIl0pO2Z1bmN0aW9uIEJuKHQsZSxuLHMpe0xuKHQsZSx2b2lkIDAscyk7Zm9yKGNvbnN0IG4gaW4gZS5hdHRycyl0LnNldEF0dHJpYnV0ZShqbi5oYXMobik/bjpBdChuKSxlLmF0dHJzW25dKX1mdW5jdGlvbiBGbih0LGUpe2NvbnN0e3N0eWxlOm59PXQscz17fTtmb3IoY29uc3QgaSBpbiBuKShqZShuW2ldKXx8ZS5zdHlsZSYmamUoZS5zdHlsZVtpXSl8fGZuKGksdCkpJiYoc1tpXT1uW2ldKTtyZXR1cm4gc31mdW5jdGlvbiBPbih0LGUpe2NvbnN0IG49Rm4odCxlKTtmb3IoY29uc3QgcyBpbiB0KShqZSh0W3NdKXx8amUoZVtzXSkpJiYoblstMSE9PXd0LmluZGV4T2Yocyk/XCJhdHRyXCIrcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStzLnN1YnN0cmluZygxKTpzXT10W3NdKTtyZXR1cm4gbn1mdW5jdGlvbiBJbih0KXtjb25zdCBlPWplKHQpP3QuZ2V0KCk6dDtyZXR1cm4gbj1lLEJvb2xlYW4obiYmXCJvYmplY3RcIj09dHlwZW9mIG4mJm4ubWl4JiZuLnRvVmFsdWUpP2UudG9WYWx1ZSgpOmU7dmFyIG59Y29uc3QgVW49ZT0+KG4scyk9Pntjb25zdCBpPSgwLHQudXNlQ29udGV4dCkoWGUpLG89KDAsdC51c2VDb250ZXh0KShHZSkscj0oKT0+ZnVuY3Rpb24oe3NjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczp0LGNyZWF0ZVJlbmRlclN0YXRlOmUsb25Nb3VudDpufSxzLGksbyl7Y29uc3Qgcj17bGF0ZXN0VmFsdWVzOk5uKHMsaSxvLHQpLHJlbmRlclN0YXRlOmUoKX07cmV0dXJuIG4mJihyLm1vdW50PXQ9Pm4ocyx0LHIpKSxyfShlLG4saSxvKTtyZXR1cm4gcz9yKCk6V2Uocil9O2Z1bmN0aW9uIE5uKHQsZSxuLHMpe2NvbnN0IGk9e30sbz1zKHQse30pO2Zvcihjb25zdCB0IGluIG8paVt0XT1JbihvW3RdKTtsZXR7aW5pdGlhbDpyLGFuaW1hdGU6YX09dDtjb25zdCBsPXRuKHQpLHU9ZW4odCk7ZSYmdSYmIWwmJiExIT09dC5pbmhlcml0JiYodm9pZCAwPT09ciYmKHI9ZS5pbml0aWFsKSx2b2lkIDA9PT1hJiYoYT1lLmFuaW1hdGUpKTtsZXQgYz0hIW4mJiExPT09bi5pbml0aWFsO2M9Y3x8ITE9PT1yO2NvbnN0IGg9Yz9hOnI7cmV0dXJuIGgmJlwiYm9vbGVhblwiIT10eXBlb2YgaCYmIV9lKGgpJiYoQXJyYXkuaXNBcnJheShoKT9oOltoXSkuZm9yRWFjaCgoZT0+e2NvbnN0IG49dnQodCxlKTtpZighbilyZXR1cm47Y29uc3R7dHJhbnNpdGlvbkVuZDpzLHRyYW5zaXRpb246bywuLi5yfT1uO2Zvcihjb25zdCB0IGluIHIpe2xldCBlPXJbdF07QXJyYXkuaXNBcnJheShlKSYmKGU9ZVtjP2UubGVuZ3RoLTE6MF0pLG51bGwhPT1lJiYoaVt0XT1lKX1mb3IoY29uc3QgdCBpbiBzKWlbdF09c1t0XX0pKSxpfWNvbnN0ICRuPXt1c2VWaXN1YWxTdGF0ZTpVbih7c2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOk9uLGNyZWF0ZVJlbmRlclN0YXRlOigpPT4oe3N0eWxlOnt9LHRyYW5zZm9ybTp7fSx0cmFuc2Zvcm1PcmlnaW46e30sdmFyczp7fSxhdHRyczp7fX0pLG9uTW91bnQ6KHQsZSx7cmVuZGVyU3RhdGU6bixsYXRlc3RWYWx1ZXM6c30pPT57eS5yZWFkKCgoKT0+e3RyeXtuLmRpbWVuc2lvbnM9XCJmdW5jdGlvblwiPT10eXBlb2YgZS5nZXRCQm94P2UuZ2V0QkJveCgpOmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCl9Y2F0Y2godCl7bi5kaW1lbnNpb25zPXt4OjAseTowLHdpZHRoOjAsaGVpZ2h0OjB9fX0pKSx5LnJlbmRlcigoKCk9PntNbihuLHMse2VuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiExfSxEbihlLnRhZ05hbWUpLHQudHJhbnNmb3JtVGVtcGxhdGUpLEJuKGUsbil9KSl9fSl9LFduPXt1c2VWaXN1YWxTdGF0ZTpVbih7c2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOkZuLGNyZWF0ZVJlbmRlclN0YXRlOigpPT4oe3N0eWxlOnt9LHRyYW5zZm9ybTp7fSx0cmFuc2Zvcm1PcmlnaW46e30sdmFyczp7fX0pfSl9O2Z1bmN0aW9uIEhuKHQsZSxuLHM9e3Bhc3NpdmU6ITB9KXtyZXR1cm4gdC5hZGRFdmVudExpc3RlbmVyKGUsbixzKSwoKT0+dC5yZW1vdmVFdmVudExpc3RlbmVyKGUsbil9Y29uc3Qgem49dD0+XCJtb3VzZVwiPT09dC5wb2ludGVyVHlwZT9cIm51bWJlclwiIT10eXBlb2YgdC5idXR0b258fHQuYnV0dG9uPD0wOiExIT09dC5pc1ByaW1hcnk7ZnVuY3Rpb24gWW4odCxlPVwicGFnZVwiKXtyZXR1cm57cG9pbnQ6e3g6dFtlK1wiWFwiXSx5OnRbZStcIllcIl19fX1mdW5jdGlvbiBYbih0LGUsbixzKXtyZXR1cm4gSG4odCxlLCh0PT5lPT56bihlKSYmdChlLFluKGUpKSkobikscyl9ZnVuY3Rpb24gR24odCl7bGV0IGU9bnVsbDtyZXR1cm4oKT0+bnVsbD09PWUmJihlPXQsKCk9PntlPW51bGx9KX1jb25zdCBxbj1HbihcImRyYWdIb3Jpem9udGFsXCIpLFpuPUduKFwiZHJhZ1ZlcnRpY2FsXCIpO2Z1bmN0aW9uIEtuKHQpe2xldCBlPSExO2lmKFwieVwiPT09dCllPVpuKCk7ZWxzZSBpZihcInhcIj09PXQpZT1xbigpO2Vsc2V7Y29uc3QgdD1xbigpLG49Wm4oKTt0JiZuP2U9KCk9Pnt0KCksbigpfToodCYmdCgpLG4mJm4oKSl9cmV0dXJuIGV9ZnVuY3Rpb24gX24oKXtjb25zdCB0PUtuKCEwKTtyZXR1cm4hdHx8KHQoKSwhMSl9Y2xhc3MgSm57Y29uc3RydWN0b3IodCl7dGhpcy5pc01vdW50ZWQ9ITEsdGhpcy5ub2RlPXR9dXBkYXRlKCl7fX1mdW5jdGlvbiBRbih0LGUpe2NvbnN0IG49XCJwb2ludGVyXCIrKGU/XCJlbnRlclwiOlwibGVhdmVcIikscz1cIm9uSG92ZXJcIisoZT9cIlN0YXJ0XCI6XCJFbmRcIik7cmV0dXJuIFhuKHQuY3VycmVudCxuLCgobixpKT0+e2lmKFwidG91Y2hcIj09PW4udHlwZXx8X24oKSlyZXR1cm47Y29uc3Qgbz10LmdldFByb3BzKCk7dC5hbmltYXRpb25TdGF0ZSYmby53aGlsZUhvdmVyJiZ0LmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShcIndoaWxlSG92ZXJcIixlKSxvW3NdJiZ5LnVwZGF0ZSgoKCk9Pm9bc10obixpKSkpfSkse3Bhc3NpdmU6IXQuZ2V0UHJvcHMoKVtzXX0pfWNvbnN0IHRzPSh0LGUpPT4hIWUmJih0PT09ZXx8dHModCxlLnBhcmVudEVsZW1lbnQpKTtmdW5jdGlvbiBlcyh0LGUpe2lmKCFlKXJldHVybjtjb25zdCBuPW5ldyBQb2ludGVyRXZlbnQoXCJwb2ludGVyXCIrdCk7ZShuLFluKG4pKX1jb25zdCBucz1uZXcgV2Vha01hcCxzcz1uZXcgV2Vha01hcCxpcz10PT57Y29uc3QgZT1ucy5nZXQodC50YXJnZXQpO2UmJmUodCl9LG9zPXQ9Pnt0LmZvckVhY2goaXMpfTtjb25zdCBycz17c29tZTowLGFsbDoxfSxhcz17aW5WaWV3OntGZWF0dXJlOmNsYXNzIGV4dGVuZHMgSm57Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuaGFzRW50ZXJlZFZpZXc9ITEsdGhpcy5pc0luVmlldz0hMX1zdGFydE9ic2VydmVyKCl7dGhpcy51bm1vdW50KCk7Y29uc3R7dmlld3BvcnQ6dD17fX09dGhpcy5ub2RlLmdldFByb3BzKCkse3Jvb3Q6ZSxtYXJnaW46bixhbW91bnQ6cz1cInNvbWVcIixvbmNlOml9PXQsbz17cm9vdDplP2UuY3VycmVudDp2b2lkIDAscm9vdE1hcmdpbjpuLHRocmVzaG9sZDpcIm51bWJlclwiPT10eXBlb2Ygcz9zOnJzW3NdfTtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe2NvbnN0IHM9ZnVuY3Rpb24oe3Jvb3Q6dCwuLi5lfSl7Y29uc3Qgbj10fHxkb2N1bWVudDtzcy5oYXMobil8fHNzLnNldChuLHt9KTtjb25zdCBzPXNzLmdldChuKSxpPUpTT04uc3RyaW5naWZ5KGUpO3JldHVybiBzW2ldfHwoc1tpXT1uZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIob3Mse3Jvb3Q6dCwuLi5lfSkpLHNbaV19KGUpO3JldHVybiBucy5zZXQodCxuKSxzLm9ic2VydmUodCksKCk9Pntucy5kZWxldGUodCkscy51bm9ic2VydmUodCl9fSh0aGlzLm5vZGUuY3VycmVudCxvLCh0PT57Y29uc3R7aXNJbnRlcnNlY3Rpbmc6ZX09dDtpZih0aGlzLmlzSW5WaWV3PT09ZSlyZXR1cm47aWYodGhpcy5pc0luVmlldz1lLGkmJiFlJiZ0aGlzLmhhc0VudGVyZWRWaWV3KXJldHVybjtlJiYodGhpcy5oYXNFbnRlcmVkVmlldz0hMCksdGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlJiZ0aGlzLm5vZGUuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKFwid2hpbGVJblZpZXdcIixlKTtjb25zdHtvblZpZXdwb3J0RW50ZXI6bixvblZpZXdwb3J0TGVhdmU6c309dGhpcy5ub2RlLmdldFByb3BzKCksbz1lP246cztvJiZvKHQpfSkpfW1vdW50KCl7dGhpcy5zdGFydE9ic2VydmVyKCl9dXBkYXRlKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyKXJldHVybjtjb25zdHtwcm9wczp0LHByZXZQcm9wczplfT10aGlzLm5vZGU7W1wiYW1vdW50XCIsXCJtYXJnaW5cIixcInJvb3RcIl0uc29tZShmdW5jdGlvbih7dmlld3BvcnQ6dD17fX0se3ZpZXdwb3J0OmU9e319PXt9KXtyZXR1cm4gbj0+dFtuXSE9PWVbbl19KHQsZSkpJiZ0aGlzLnN0YXJ0T2JzZXJ2ZXIoKX11bm1vdW50KCl7fX19LHRhcDp7RmVhdHVyZTpjbGFzcyBleHRlbmRzIEpue2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLnJlbW92ZVN0YXJ0TGlzdGVuZXJzPW4sdGhpcy5yZW1vdmVFbmRMaXN0ZW5lcnM9bix0aGlzLnJlbW92ZUFjY2Vzc2libGVMaXN0ZW5lcnM9bix0aGlzLnN0YXJ0UG9pbnRlclByZXNzPSh0LGUpPT57aWYodGhpcy5yZW1vdmVFbmRMaXN0ZW5lcnMoKSx0aGlzLmlzUHJlc3NpbmcpcmV0dXJuO2NvbnN0IG49dGhpcy5ub2RlLmdldFByb3BzKCkscz1Ybih3aW5kb3csXCJwb2ludGVydXBcIiwoKHQsZSk9PntpZighdGhpcy5jaGVja1ByZXNzRW5kKCkpcmV0dXJuO2NvbnN0e29uVGFwOm4sb25UYXBDYW5jZWw6c309dGhpcy5ub2RlLmdldFByb3BzKCk7eS51cGRhdGUoKCgpPT57dHModGhpcy5ub2RlLmN1cnJlbnQsdC50YXJnZXQpP24mJm4odCxlKTpzJiZzKHQsZSl9KSl9KSx7cGFzc2l2ZTohKG4ub25UYXB8fG4ub25Qb2ludGVyVXApfSksaT1Ybih3aW5kb3csXCJwb2ludGVyY2FuY2VsXCIsKCh0LGUpPT50aGlzLmNhbmNlbFByZXNzKHQsZSkpLHtwYXNzaXZlOiEobi5vblRhcENhbmNlbHx8bi5vblBvaW50ZXJDYW5jZWwpfSk7dGhpcy5yZW1vdmVFbmRMaXN0ZW5lcnM9c2UocyxpKSx0aGlzLnN0YXJ0UHJlc3ModCxlKX0sdGhpcy5zdGFydEFjY2Vzc2libGVQcmVzcz0oKT0+e2NvbnN0IHQ9SG4odGhpcy5ub2RlLmN1cnJlbnQsXCJrZXlkb3duXCIsKHQ9PntcIkVudGVyXCIhPT10LmtleXx8dGhpcy5pc1ByZXNzaW5nfHwodGhpcy5yZW1vdmVFbmRMaXN0ZW5lcnMoKSx0aGlzLnJlbW92ZUVuZExpc3RlbmVycz1Ibih0aGlzLm5vZGUuY3VycmVudCxcImtleXVwXCIsKHQ9PntcIkVudGVyXCI9PT10LmtleSYmdGhpcy5jaGVja1ByZXNzRW5kKCkmJmVzKFwidXBcIiwoKHQsZSk9Pntjb25zdHtvblRhcDpufT10aGlzLm5vZGUuZ2V0UHJvcHMoKTtuJiZ5LnVwZGF0ZSgoKCk9Pm4odCxlKSkpfSkpfSkpLGVzKFwiZG93blwiLCgodCxlKT0+e3RoaXMuc3RhcnRQcmVzcyh0LGUpfSkpKX0pKSxlPUhuKHRoaXMubm9kZS5jdXJyZW50LFwiYmx1clwiLCgoKT0+e3RoaXMuaXNQcmVzc2luZyYmZXMoXCJjYW5jZWxcIiwoKHQsZSk9PnRoaXMuY2FuY2VsUHJlc3ModCxlKSkpfSkpO3RoaXMucmVtb3ZlQWNjZXNzaWJsZUxpc3RlbmVycz1zZSh0LGUpfX1zdGFydFByZXNzKHQsZSl7dGhpcy5pc1ByZXNzaW5nPSEwO2NvbnN0e29uVGFwU3RhcnQ6bix3aGlsZVRhcDpzfT10aGlzLm5vZGUuZ2V0UHJvcHMoKTtzJiZ0aGlzLm5vZGUuYW5pbWF0aW9uU3RhdGUmJnRoaXMubm9kZS5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoXCJ3aGlsZVRhcFwiLCEwKSxuJiZ5LnVwZGF0ZSgoKCk9Pm4odCxlKSkpfWNoZWNrUHJlc3NFbmQoKXtyZXR1cm4gdGhpcy5yZW1vdmVFbmRMaXN0ZW5lcnMoKSx0aGlzLmlzUHJlc3Npbmc9ITEsdGhpcy5ub2RlLmdldFByb3BzKCkud2hpbGVUYXAmJnRoaXMubm9kZS5hbmltYXRpb25TdGF0ZSYmdGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShcIndoaWxlVGFwXCIsITEpLCFfbigpfWNhbmNlbFByZXNzKHQsZSl7aWYoIXRoaXMuY2hlY2tQcmVzc0VuZCgpKXJldHVybjtjb25zdHtvblRhcENhbmNlbDpufT10aGlzLm5vZGUuZ2V0UHJvcHMoKTtuJiZ5LnVwZGF0ZSgoKCk9Pm4odCxlKSkpfW1vdW50KCl7Y29uc3QgdD10aGlzLm5vZGUuZ2V0UHJvcHMoKSxlPVhuKHRoaXMubm9kZS5jdXJyZW50LFwicG9pbnRlcmRvd25cIix0aGlzLnN0YXJ0UG9pbnRlclByZXNzLHtwYXNzaXZlOiEodC5vblRhcFN0YXJ0fHx0Lm9uUG9pbnRlclN0YXJ0KX0pLG49SG4odGhpcy5ub2RlLmN1cnJlbnQsXCJmb2N1c1wiLHRoaXMuc3RhcnRBY2Nlc3NpYmxlUHJlc3MpO3RoaXMucmVtb3ZlU3RhcnRMaXN0ZW5lcnM9c2UoZSxuKX11bm1vdW50KCl7dGhpcy5yZW1vdmVTdGFydExpc3RlbmVycygpLHRoaXMucmVtb3ZlRW5kTGlzdGVuZXJzKCksdGhpcy5yZW1vdmVBY2Nlc3NpYmxlTGlzdGVuZXJzKCl9fX0sZm9jdXM6e0ZlYXR1cmU6Y2xhc3MgZXh0ZW5kcyBKbntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5pc0FjdGl2ZT0hMX1vbkZvY3VzKCl7bGV0IHQ9ITE7dHJ5e3Q9dGhpcy5ub2RlLmN1cnJlbnQubWF0Y2hlcyhcIjpmb2N1cy12aXNpYmxlXCIpfWNhdGNoKGUpe3Q9ITB9dCYmdGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlJiYodGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShcIndoaWxlRm9jdXNcIiwhMCksdGhpcy5pc0FjdGl2ZT0hMCl9b25CbHVyKCl7dGhpcy5pc0FjdGl2ZSYmdGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlJiYodGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShcIndoaWxlRm9jdXNcIiwhMSksdGhpcy5pc0FjdGl2ZT0hMSl9bW91bnQoKXt0aGlzLnVubW91bnQ9c2UoSG4odGhpcy5ub2RlLmN1cnJlbnQsXCJmb2N1c1wiLCgoKT0+dGhpcy5vbkZvY3VzKCkpKSxIbih0aGlzLm5vZGUuY3VycmVudCxcImJsdXJcIiwoKCk9PnRoaXMub25CbHVyKCkpKSl9dW5tb3VudCgpe319fSxob3Zlcjp7RmVhdHVyZTpjbGFzcyBleHRlbmRzIEpue21vdW50KCl7dGhpcy51bm1vdW50PXNlKFFuKHRoaXMubm9kZSwhMCksUW4odGhpcy5ub2RlLCExKSl9dW5tb3VudCgpe319fX07ZnVuY3Rpb24gbHModCxlKXtpZighQXJyYXkuaXNBcnJheShlKSlyZXR1cm4hMTtjb25zdCBuPWUubGVuZ3RoO2lmKG4hPT10Lmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IHM9MDtzPG47cysrKWlmKGVbc10hPT10W3NdKXJldHVybiExO3JldHVybiEwfWNvbnN0IHVzPVsuLi5KZV0ucmV2ZXJzZSgpLGNzPUplLmxlbmd0aDtmdW5jdGlvbiBocyh0PSExKXtyZXR1cm57aXNBY3RpdmU6dCxwcm90ZWN0ZWRLZXlzOnt9LG5lZWRzQW5pbWF0aW5nOnt9LHByZXZSZXNvbHZlZFZhbHVlczp7fX19bGV0IGRzPTA7Y29uc3QgbXM9e2FuaW1hdGlvbjp7RmVhdHVyZTpjbGFzcyBleHRlbmRzIEpue2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHQuYW5pbWF0aW9uU3RhdGV8fCh0LmFuaW1hdGlvblN0YXRlPWZ1bmN0aW9uKHQpe2xldCBlPWZ1bmN0aW9uKHQpe3JldHVybiBlPT5Qcm9taXNlLmFsbChlLm1hcCgoKHthbmltYXRpb246ZSxvcHRpb25zOm59KT0+TmUodCxlLG4pKSkpfSh0KTtjb25zdCBuPXthbmltYXRlOmhzKCEwKSx3aGlsZUluVmlldzpocygpLHdoaWxlSG92ZXI6aHMoKSx3aGlsZVRhcDpocygpLHdoaWxlRHJhZzpocygpLHdoaWxlRm9jdXM6aHMoKSxleGl0OmhzKCl9O2xldCBzPSEwO2NvbnN0IGk9KGUsbik9Pntjb25zdCBzPXh0KHQsbik7aWYocyl7Y29uc3R7dHJhbnNpdGlvbjp0LHRyYW5zaXRpb25FbmQ6biwuLi5pfT1zO2U9ey4uLmUsLi4uaSwuLi5ufX1yZXR1cm4gZX07ZnVuY3Rpb24gbyhvLHIpe2NvbnN0IGE9dC5nZXRQcm9wcygpLGw9dC5nZXRWYXJpYW50Q29udGV4dCghMCl8fHt9LHU9W10saD1uZXcgU2V0O2xldCBkPXt9LG09MS8wO2ZvcihsZXQgZT0wO2U8Y3M7ZSsrKXtjb25zdCBnPXVzW2VdLHk9bltnXSx2PXZvaWQgMCE9PWFbZ10/YVtnXTpsW2ddLHg9S2UodiksUD1nPT09cj95LmlzQWN0aXZlOm51bGw7ITE9PT1QJiYobT1lKTtsZXQgYj12PT09bFtnXSYmdiE9PWFbZ10mJng7aWYoYiYmcyYmdC5tYW51YWxseUFuaW1hdGVPbk1vdW50JiYoYj0hMSkseS5wcm90ZWN0ZWRLZXlzPXsuLi5kfSwheS5pc0FjdGl2ZSYmbnVsbD09PVB8fCF2JiYheS5wcmV2UHJvcHx8X2Uodil8fFwiYm9vbGVhblwiPT10eXBlb2Ygdiljb250aW51ZTtjb25zdCBUPShwPXkucHJldlByb3AsXCJzdHJpbmdcIj09dHlwZW9mKGY9dik/ZiE9PXA6ISFBcnJheS5pc0FycmF5KGYpJiYhbHMoZixwKSk7bGV0IFM9VHx8Zz09PXImJnkuaXNBY3RpdmUmJiFiJiZ4fHxlPm0mJng7Y29uc3Qgdz1BcnJheS5pc0FycmF5KHYpP3Y6W3ZdO2xldCBFPXcucmVkdWNlKGkse30pOyExPT09UCYmKEU9e30pO2NvbnN0e3ByZXZSZXNvbHZlZFZhbHVlczpBPXt9fT15LFY9ey4uLkEsLi4uRX0sQz10PT57Uz0hMCxoLmRlbGV0ZSh0KSx5Lm5lZWRzQW5pbWF0aW5nW3RdPSEwfTtmb3IoY29uc3QgdCBpbiBWKXtjb25zdCBlPUVbdF0sbj1BW3RdO2QuaGFzT3duUHJvcGVydHkodCl8fChlIT09bj9jKGUpJiZjKG4pPyFscyhlLG4pfHxUP0ModCk6eS5wcm90ZWN0ZWRLZXlzW3RdPSEwOnZvaWQgMCE9PWU/Qyh0KTpoLmFkZCh0KTp2b2lkIDAhPT1lJiZoLmhhcyh0KT9DKHQpOnkucHJvdGVjdGVkS2V5c1t0XT0hMCl9eS5wcmV2UHJvcD12LHkucHJldlJlc29sdmVkVmFsdWVzPUUseS5pc0FjdGl2ZSYmKGQ9ey4uLmQsLi4uRX0pLHMmJnQuYmxvY2tJbml0aWFsQW5pbWF0aW9uJiYoUz0hMSksUyYmIWImJnUucHVzaCguLi53Lm1hcCgodD0+KHthbmltYXRpb246dCxvcHRpb25zOnt0eXBlOmcsLi4ub319KSkpKX12YXIgcCxmO2lmKGguc2l6ZSl7Y29uc3QgZT17fTtoLmZvckVhY2goKG49Pntjb25zdCBzPXQuZ2V0QmFzZVRhcmdldChuKTt2b2lkIDAhPT1zJiYoZVtuXT1zKX0pKSx1LnB1c2goe2FuaW1hdGlvbjplfSl9bGV0IGc9Qm9vbGVhbih1Lmxlbmd0aCk7cmV0dXJuIHMmJiExPT09YS5pbml0aWFsJiYhdC5tYW51YWxseUFuaW1hdGVPbk1vdW50JiYoZz0hMSkscz0hMSxnP2UodSk6UHJvbWlzZS5yZXNvbHZlKCl9cmV0dXJue2FuaW1hdGVDaGFuZ2VzOm8sc2V0QWN0aXZlOmZ1bmN0aW9uKGUscyxpKXt2YXIgcjtpZihuW2VdLmlzQWN0aXZlPT09cylyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7bnVsbD09PShyPXQudmFyaWFudENoaWxkcmVuKXx8dm9pZCAwPT09cnx8ci5mb3JFYWNoKCh0PT57dmFyIG47cmV0dXJuIG51bGw9PT0obj10LmFuaW1hdGlvblN0YXRlKXx8dm9pZCAwPT09bj92b2lkIDA6bi5zZXRBY3RpdmUoZSxzKX0pKSxuW2VdLmlzQWN0aXZlPXM7Y29uc3QgYT1vKGksZSk7Zm9yKGNvbnN0IHQgaW4gbiluW3RdLnByb3RlY3RlZEtleXM9e307cmV0dXJuIGF9LHNldEFuaW1hdGVGdW5jdGlvbjpmdW5jdGlvbihuKXtlPW4odCl9LGdldFN0YXRlOigpPT5ufX0odCkpfXVwZGF0ZUFuaW1hdGlvbkNvbnRyb2xzU3Vic2NyaXB0aW9uKCl7Y29uc3R7YW5pbWF0ZTp0fT10aGlzLm5vZGUuZ2V0UHJvcHMoKTt0aGlzLnVubW91bnQoKSxfZSh0KSYmKHRoaXMudW5tb3VudD10LnN1YnNjcmliZSh0aGlzLm5vZGUpKX1tb3VudCgpe3RoaXMudXBkYXRlQW5pbWF0aW9uQ29udHJvbHNTdWJzY3JpcHRpb24oKX11cGRhdGUoKXtjb25zdHthbmltYXRlOnR9PXRoaXMubm9kZS5nZXRQcm9wcygpLHthbmltYXRlOmV9PXRoaXMubm9kZS5wcmV2UHJvcHN8fHt9O3QhPT1lJiZ0aGlzLnVwZGF0ZUFuaW1hdGlvbkNvbnRyb2xzU3Vic2NyaXB0aW9uKCl9dW5tb3VudCgpe319fSxleGl0OntGZWF0dXJlOmNsYXNzIGV4dGVuZHMgSm57Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuaWQ9ZHMrK311cGRhdGUoKXtpZighdGhpcy5ub2RlLnByZXNlbmNlQ29udGV4dClyZXR1cm47Y29uc3R7aXNQcmVzZW50OnQsb25FeGl0Q29tcGxldGU6ZSxjdXN0b206bn09dGhpcy5ub2RlLnByZXNlbmNlQ29udGV4dCx7aXNQcmVzZW50OnN9PXRoaXMubm9kZS5wcmV2UHJlc2VuY2VDb250ZXh0fHx7fTtpZighdGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlfHx0PT09cylyZXR1cm47Y29uc3QgaT10aGlzLm5vZGUuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKFwiZXhpdFwiLCF0LHtjdXN0b206bnVsbCE9bj9uOnRoaXMubm9kZS5nZXRQcm9wcygpLmN1c3RvbX0pO2UmJiF0JiZpLnRoZW4oKCgpPT5lKHRoaXMuaWQpKSl9bW91bnQoKXtjb25zdHtyZWdpc3Rlcjp0fT10aGlzLm5vZGUucHJlc2VuY2VDb250ZXh0fHx7fTt0JiYodGhpcy51bm1vdW50PXQodGhpcy5pZCkpfXVubW91bnQoKXt9fX19LHBzPSh0LGUpPT5NYXRoLmFicyh0LWUpO2NsYXNzIGZze2NvbnN0cnVjdG9yKHQsZSx7dHJhbnNmb3JtUGFnZVBvaW50Om59PXt9KXtpZih0aGlzLnN0YXJ0RXZlbnQ9bnVsbCx0aGlzLmxhc3RNb3ZlRXZlbnQ9bnVsbCx0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvPW51bGwsdGhpcy5oYW5kbGVycz17fSx0aGlzLnVwZGF0ZVBvaW50PSgpPT57aWYoIXRoaXMubGFzdE1vdmVFdmVudHx8IXRoaXMubGFzdE1vdmVFdmVudEluZm8pcmV0dXJuO2NvbnN0IHQ9dnModGhpcy5sYXN0TW92ZUV2ZW50SW5mbyx0aGlzLmhpc3RvcnkpLGU9bnVsbCE9PXRoaXMuc3RhcnRFdmVudCxuPWZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj1wcyh0LngsZS54KSxzPXBzKHQueSxlLnkpO3JldHVybiBNYXRoLnNxcnQobioqMitzKioyKX0odC5vZmZzZXQse3g6MCx5OjB9KT49MztpZighZSYmIW4pcmV0dXJuO2NvbnN0e3BvaW50OnN9PXQse3RpbWVzdGFtcDppfT14O3RoaXMuaGlzdG9yeS5wdXNoKHsuLi5zLHRpbWVzdGFtcDppfSk7Y29uc3R7b25TdGFydDpvLG9uTW92ZTpyfT10aGlzLmhhbmRsZXJzO2V8fChvJiZvKHRoaXMubGFzdE1vdmVFdmVudCx0KSx0aGlzLnN0YXJ0RXZlbnQ9dGhpcy5sYXN0TW92ZUV2ZW50KSxyJiZyKHRoaXMubGFzdE1vdmVFdmVudCx0KX0sdGhpcy5oYW5kbGVQb2ludGVyTW92ZT0odCxlKT0+e3RoaXMubGFzdE1vdmVFdmVudD10LHRoaXMubGFzdE1vdmVFdmVudEluZm89Z3MoZSx0aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCkseS51cGRhdGUodGhpcy51cGRhdGVQb2ludCwhMCl9LHRoaXMuaGFuZGxlUG9pbnRlclVwPSh0LGUpPT57aWYodGhpcy5lbmQoKSwhdGhpcy5sYXN0TW92ZUV2ZW50fHwhdGhpcy5sYXN0TW92ZUV2ZW50SW5mbylyZXR1cm47Y29uc3R7b25FbmQ6bixvblNlc3Npb25FbmQ6c309dGhpcy5oYW5kbGVycyxpPXZzKFwicG9pbnRlcmNhbmNlbFwiPT09dC50eXBlP3RoaXMubGFzdE1vdmVFdmVudEluZm86Z3MoZSx0aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCksdGhpcy5oaXN0b3J5KTt0aGlzLnN0YXJ0RXZlbnQmJm4mJm4odCxpKSxzJiZzKHQsaSl9LCF6bih0KSlyZXR1cm47dGhpcy5oYW5kbGVycz1lLHRoaXMudHJhbnNmb3JtUGFnZVBvaW50PW47Y29uc3Qgcz1ncyhZbih0KSx0aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCkse3BvaW50Oml9PXMse3RpbWVzdGFtcDpvfT14O3RoaXMuaGlzdG9yeT1bey4uLmksdGltZXN0YW1wOm99XTtjb25zdHtvblNlc3Npb25TdGFydDpyfT1lO3ImJnIodCx2cyhzLHRoaXMuaGlzdG9yeSkpLHRoaXMucmVtb3ZlTGlzdGVuZXJzPXNlKFhuKHdpbmRvdyxcInBvaW50ZXJtb3ZlXCIsdGhpcy5oYW5kbGVQb2ludGVyTW92ZSksWG4od2luZG93LFwicG9pbnRlcnVwXCIsdGhpcy5oYW5kbGVQb2ludGVyVXApLFhuKHdpbmRvdyxcInBvaW50ZXJjYW5jZWxcIix0aGlzLmhhbmRsZVBvaW50ZXJVcCkpfXVwZGF0ZUhhbmRsZXJzKHQpe3RoaXMuaGFuZGxlcnM9dH1lbmQoKXt0aGlzLnJlbW92ZUxpc3RlbmVycyYmdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKSx2KHRoaXMudXBkYXRlUG9pbnQpfX1mdW5jdGlvbiBncyh0LGUpe3JldHVybiBlP3twb2ludDplKHQucG9pbnQpfTp0fWZ1bmN0aW9uIHlzKHQsZSl7cmV0dXJue3g6dC54LWUueCx5OnQueS1lLnl9fWZ1bmN0aW9uIHZzKHtwb2ludDp0fSxlKXtyZXR1cm57cG9pbnQ6dCxkZWx0YTp5cyh0LFBzKGUpKSxvZmZzZXQ6eXModCx4cyhlKSksdmVsb2NpdHk6YnMoZSwuMSl9fWZ1bmN0aW9uIHhzKHQpe3JldHVybiB0WzBdfWZ1bmN0aW9uIFBzKHQpe3JldHVybiB0W3QubGVuZ3RoLTFdfWZ1bmN0aW9uIGJzKHQsZSl7aWYodC5sZW5ndGg8MilyZXR1cm57eDowLHk6MH07bGV0IG49dC5sZW5ndGgtMSxzPW51bGw7Y29uc3QgaT1Qcyh0KTtmb3IoO24+PTAmJihzPXRbbl0sIShpLnRpbWVzdGFtcC1zLnRpbWVzdGFtcD5DdChlKSkpOyluLS07aWYoIXMpcmV0dXJue3g6MCx5OjB9O2NvbnN0IG89TXQoaS50aW1lc3RhbXAtcy50aW1lc3RhbXApO2lmKDA9PT1vKXJldHVybnt4OjAseTowfTtjb25zdCByPXt4OihpLngtcy54KS9vLHk6KGkueS1zLnkpL299O3JldHVybiByLng9PT0xLzAmJihyLng9MCksci55PT09MS8wJiYoci55PTApLHJ9ZnVuY3Rpb24gVHModCl7cmV0dXJuIHQubWF4LXQubWlufWZ1bmN0aW9uIFNzKHQsZT0wLG49LjAxKXtyZXR1cm4gTWF0aC5hYnModC1lKTw9bn1mdW5jdGlvbiB3cyh0LGUsbixzPS41KXt0Lm9yaWdpbj1zLHQub3JpZ2luUG9pbnQ9S3QoZS5taW4sZS5tYXgsdC5vcmlnaW4pLHQuc2NhbGU9VHMobikvVHMoZSksKFNzKHQuc2NhbGUsMSwxZS00KXx8aXNOYU4odC5zY2FsZSkpJiYodC5zY2FsZT0xKSx0LnRyYW5zbGF0ZT1LdChuLm1pbixuLm1heCx0Lm9yaWdpbiktdC5vcmlnaW5Qb2ludCwoU3ModC50cmFuc2xhdGUpfHxpc05hTih0LnRyYW5zbGF0ZSkpJiYodC50cmFuc2xhdGU9MCl9ZnVuY3Rpb24gRXModCxlLG4scyl7d3ModC54LGUueCxuLngscz9zLm9yaWdpblg6dm9pZCAwKSx3cyh0LnksZS55LG4ueSxzP3Mub3JpZ2luWTp2b2lkIDApfWZ1bmN0aW9uIEFzKHQsZSxuKXt0Lm1pbj1uLm1pbitlLm1pbix0Lm1heD10Lm1pbitUcyhlKX1mdW5jdGlvbiBWcyh0LGUsbil7dC5taW49ZS5taW4tbi5taW4sdC5tYXg9dC5taW4rVHMoZSl9ZnVuY3Rpb24gQ3ModCxlLG4pe1ZzKHQueCxlLngsbi54KSxWcyh0LnksZS55LG4ueSl9ZnVuY3Rpb24gTXModCxlLG4pe3JldHVybnttaW46dm9pZCAwIT09ZT90Lm1pbitlOnZvaWQgMCxtYXg6dm9pZCAwIT09bj90Lm1heCtuLSh0Lm1heC10Lm1pbik6dm9pZCAwfX1mdW5jdGlvbiBEcyh0LGUpe2xldCBuPWUubWluLXQubWluLHM9ZS5tYXgtdC5tYXg7cmV0dXJuIGUubWF4LWUubWluPHQubWF4LXQubWluJiYoW24sc109W3Msbl0pLHttaW46bixtYXg6c319Y29uc3Qga3M9LjM1O2Z1bmN0aW9uIFJzKHQsZSxuKXtyZXR1cm57bWluOkxzKHQsZSksbWF4OkxzKHQsbil9fWZ1bmN0aW9uIExzKHQsZSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/dDp0W2VdfHwwfWZ1bmN0aW9uIGpzKHQpe3JldHVyblt0KFwieFwiKSx0KFwieVwiKV19ZnVuY3Rpb24gQnMoe3RvcDp0LGxlZnQ6ZSxyaWdodDpuLGJvdHRvbTpzfSl7cmV0dXJue3g6e21pbjplLG1heDpufSx5OnttaW46dCxtYXg6c319fWZ1bmN0aW9uIEZzKHQpe3JldHVybiB2b2lkIDA9PT10fHwxPT09dH1mdW5jdGlvbiBPcyh7c2NhbGU6dCxzY2FsZVg6ZSxzY2FsZVk6bn0pe3JldHVybiFGcyh0KXx8IUZzKGUpfHwhRnMobil9ZnVuY3Rpb24gSXModCl7cmV0dXJuIE9zKHQpfHxVcyh0KXx8dC56fHx0LnJvdGF0ZXx8dC5yb3RhdGVYfHx0LnJvdGF0ZVl9ZnVuY3Rpb24gVXModCl7cmV0dXJuIE5zKHQueCl8fE5zKHQueSl9ZnVuY3Rpb24gTnModCl7cmV0dXJuIHQmJlwiMCVcIiE9PXR9ZnVuY3Rpb24gJHModCxlLG4pe3JldHVybiBuK2UqKHQtbil9ZnVuY3Rpb24gV3ModCxlLG4scyxpKXtyZXR1cm4gdm9pZCAwIT09aSYmKHQ9JHModCxpLHMpKSwkcyh0LG4scykrZX1mdW5jdGlvbiBIcyh0LGU9MCxuPTEscyxpKXt0Lm1pbj1Xcyh0Lm1pbixlLG4scyxpKSx0Lm1heD1Xcyh0Lm1heCxlLG4scyxpKX1mdW5jdGlvbiB6cyh0LHt4OmUseTpufSl7SHModC54LGUudHJhbnNsYXRlLGUuc2NhbGUsZS5vcmlnaW5Qb2ludCksSHModC55LG4udHJhbnNsYXRlLG4uc2NhbGUsbi5vcmlnaW5Qb2ludCl9ZnVuY3Rpb24gWXModCl7cmV0dXJuIE51bWJlci5pc0ludGVnZXIodCl8fHQ+MS4wMDAwMDAwMDAwMDAxfHx0PC45OTk5OTk5OTk5OTk/dDoxfWZ1bmN0aW9uIFhzKHQsZSl7dC5taW49dC5taW4rZSx0Lm1heD10Lm1heCtlfWZ1bmN0aW9uIEdzKHQsZSxbbixzLGldKXtjb25zdCBvPXZvaWQgMCE9PWVbaV0/ZVtpXTouNSxyPUt0KHQubWluLHQubWF4LG8pO0hzKHQsZVtuXSxlW3NdLHIsZS5zY2FsZSl9Y29uc3QgcXM9W1wieFwiLFwic2NhbGVYXCIsXCJvcmlnaW5YXCJdLFpzPVtcInlcIixcInNjYWxlWVwiLFwib3JpZ2luWVwiXTtmdW5jdGlvbiBLcyh0LGUpe0dzKHQueCxlLHFzKSxHcyh0LnksZSxacyl9ZnVuY3Rpb24gX3ModCxlKXtyZXR1cm4gQnMoZnVuY3Rpb24odCxlKXtpZighZSlyZXR1cm4gdDtjb25zdCBuPWUoe3g6dC5sZWZ0LHk6dC50b3B9KSxzPWUoe3g6dC5yaWdodCx5OnQuYm90dG9tfSk7cmV0dXJue3RvcDpuLnksbGVmdDpuLngsYm90dG9tOnMueSxyaWdodDpzLnh9fSh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGUpKX1jb25zdCBKcz1uZXcgV2Vha01hcDtjbGFzcyBRc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLm9wZW5HbG9iYWxMb2NrPW51bGwsdGhpcy5pc0RyYWdnaW5nPSExLHRoaXMuY3VycmVudERpcmVjdGlvbj1udWxsLHRoaXMub3JpZ2luUG9pbnQ9e3g6MCx5OjB9LHRoaXMuY29uc3RyYWludHM9ITEsdGhpcy5oYXNNdXRhdGVkQ29uc3RyYWludHM9ITEsdGhpcy5lbGFzdGljPXt4OnttaW46MCxtYXg6MH0seTp7bWluOjAsbWF4OjB9fSx0aGlzLnZpc3VhbEVsZW1lbnQ9dH1zdGFydCh0LHtzbmFwVG9DdXJzb3I6ZT0hMX09e30pe2NvbnN0e3ByZXNlbmNlQ29udGV4dDpufT10aGlzLnZpc3VhbEVsZW1lbnQ7biYmITE9PT1uLmlzUHJlc2VudHx8KHRoaXMucGFuU2Vzc2lvbj1uZXcgZnModCx7b25TZXNzaW9uU3RhcnQ6dD0+e3RoaXMuc3RvcEFuaW1hdGlvbigpLGUmJnRoaXMuc25hcFRvQ3Vyc29yKFluKHQsXCJwYWdlXCIpLnBvaW50KX0sb25TdGFydDoodCxlKT0+e2NvbnN0e2RyYWc6bixkcmFnUHJvcGFnYXRpb246cyxvbkRyYWdTdGFydDppfT10aGlzLmdldFByb3BzKCk7aWYobiYmIXMmJih0aGlzLm9wZW5HbG9iYWxMb2NrJiZ0aGlzLm9wZW5HbG9iYWxMb2NrKCksdGhpcy5vcGVuR2xvYmFsTG9jaz1LbihuKSwhdGhpcy5vcGVuR2xvYmFsTG9jaykpcmV0dXJuO3RoaXMuaXNEcmFnZ2luZz0hMCx0aGlzLmN1cnJlbnREaXJlY3Rpb249bnVsbCx0aGlzLnJlc29sdmVDb25zdHJhaW50cygpLHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uJiYodGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24uaXNBbmltYXRpb25CbG9ja2VkPSEwLHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLnRhcmdldD12b2lkIDApLGpzKCh0PT57bGV0IGU9dGhpcy5nZXRBeGlzTW90aW9uVmFsdWUodCkuZ2V0KCl8fDA7aWYoSC50ZXN0KGUpKXtjb25zdHtwcm9qZWN0aW9uOm59PXRoaXMudmlzdWFsRWxlbWVudDtpZihuJiZuLmxheW91dCl7Y29uc3Qgcz1uLmxheW91dC5sYXlvdXRCb3hbdF07cyYmKGU9VHMocykqKHBhcnNlRmxvYXQoZSkvMTAwKSl9fXRoaXMub3JpZ2luUG9pbnRbdF09ZX0pKSxpJiZ5LnVwZGF0ZSgoKCk9PmkodCxlKSksITEsITApO2NvbnN0e2FuaW1hdGlvblN0YXRlOm99PXRoaXMudmlzdWFsRWxlbWVudDtvJiZvLnNldEFjdGl2ZShcIndoaWxlRHJhZ1wiLCEwKX0sb25Nb3ZlOih0LGUpPT57Y29uc3R7ZHJhZ1Byb3BhZ2F0aW9uOm4sZHJhZ0RpcmVjdGlvbkxvY2s6cyxvbkRpcmVjdGlvbkxvY2s6aSxvbkRyYWc6b309dGhpcy5nZXRQcm9wcygpO2lmKCFuJiYhdGhpcy5vcGVuR2xvYmFsTG9jaylyZXR1cm47Y29uc3R7b2Zmc2V0OnJ9PWU7aWYocyYmbnVsbD09PXRoaXMuY3VycmVudERpcmVjdGlvbilyZXR1cm4gdGhpcy5jdXJyZW50RGlyZWN0aW9uPWZ1bmN0aW9uKHQsZT0xMCl7bGV0IG49bnVsbDtyZXR1cm4gTWF0aC5hYnModC55KT5lP249XCJ5XCI6TWF0aC5hYnModC54KT5lJiYobj1cInhcIiksbn0ociksdm9pZChudWxsIT09dGhpcy5jdXJyZW50RGlyZWN0aW9uJiZpJiZpKHRoaXMuY3VycmVudERpcmVjdGlvbikpO3RoaXMudXBkYXRlQXhpcyhcInhcIixlLnBvaW50LHIpLHRoaXMudXBkYXRlQXhpcyhcInlcIixlLnBvaW50LHIpLHRoaXMudmlzdWFsRWxlbWVudC5yZW5kZXIoKSxvJiZvKHQsZSl9LG9uU2Vzc2lvbkVuZDoodCxlKT0+dGhpcy5zdG9wKHQsZSl9LHt0cmFuc2Zvcm1QYWdlUG9pbnQ6dGhpcy52aXN1YWxFbGVtZW50LmdldFRyYW5zZm9ybVBhZ2VQb2ludCgpfSkpfXN0b3AodCxlKXtjb25zdCBuPXRoaXMuaXNEcmFnZ2luZztpZih0aGlzLmNhbmNlbCgpLCFuKXJldHVybjtjb25zdHt2ZWxvY2l0eTpzfT1lO3RoaXMuc3RhcnRBbmltYXRpb24ocyk7Y29uc3R7b25EcmFnRW5kOml9PXRoaXMuZ2V0UHJvcHMoKTtpJiZ5LnVwZGF0ZSgoKCk9PmkodCxlKSkpfWNhbmNlbCgpe3RoaXMuaXNEcmFnZ2luZz0hMTtjb25zdHtwcm9qZWN0aW9uOnQsYW5pbWF0aW9uU3RhdGU6ZX09dGhpcy52aXN1YWxFbGVtZW50O3QmJih0LmlzQW5pbWF0aW9uQmxvY2tlZD0hMSksdGhpcy5wYW5TZXNzaW9uJiZ0aGlzLnBhblNlc3Npb24uZW5kKCksdGhpcy5wYW5TZXNzaW9uPXZvaWQgMDtjb25zdHtkcmFnUHJvcGFnYXRpb246bn09dGhpcy5nZXRQcm9wcygpOyFuJiZ0aGlzLm9wZW5HbG9iYWxMb2NrJiYodGhpcy5vcGVuR2xvYmFsTG9jaygpLHRoaXMub3Blbkdsb2JhbExvY2s9bnVsbCksZSYmZS5zZXRBY3RpdmUoXCJ3aGlsZURyYWdcIiwhMSl9dXBkYXRlQXhpcyh0LGUsbil7Y29uc3R7ZHJhZzpzfT10aGlzLmdldFByb3BzKCk7aWYoIW58fCF0aSh0LHMsdGhpcy5jdXJyZW50RGlyZWN0aW9uKSlyZXR1cm47Y29uc3QgaT10aGlzLmdldEF4aXNNb3Rpb25WYWx1ZSh0KTtsZXQgbz10aGlzLm9yaWdpblBvaW50W3RdK25bdF07dGhpcy5jb25zdHJhaW50cyYmdGhpcy5jb25zdHJhaW50c1t0XSYmKG89ZnVuY3Rpb24odCx7bWluOmUsbWF4Om59LHMpe3JldHVybiB2b2lkIDAhPT1lJiZ0PGU/dD1zP0t0KGUsdCxzLm1pbik6TWF0aC5tYXgodCxlKTp2b2lkIDAhPT1uJiZ0Pm4mJih0PXM/S3Qobix0LHMubWF4KTpNYXRoLm1pbih0LG4pKSx0fShvLHRoaXMuY29uc3RyYWludHNbdF0sdGhpcy5lbGFzdGljW3RdKSksaS5zZXQobyl9cmVzb2x2ZUNvbnN0cmFpbnRzKCl7Y29uc3R7ZHJhZ0NvbnN0cmFpbnRzOnQsZHJhZ0VsYXN0aWM6ZX09dGhpcy5nZXRQcm9wcygpLHtsYXlvdXQ6bn09dGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb258fHt9LHM9dGhpcy5jb25zdHJhaW50czt0JiZaZSh0KT90aGlzLmNvbnN0cmFpbnRzfHwodGhpcy5jb25zdHJhaW50cz10aGlzLnJlc29sdmVSZWZDb25zdHJhaW50cygpKTp0aGlzLmNvbnN0cmFpbnRzPSEoIXR8fCFuKSYmZnVuY3Rpb24odCx7dG9wOmUsbGVmdDpuLGJvdHRvbTpzLHJpZ2h0Oml9KXtyZXR1cm57eDpNcyh0LngsbixpKSx5Ok1zKHQueSxlLHMpfX0obi5sYXlvdXRCb3gsdCksdGhpcy5lbGFzdGljPWZ1bmN0aW9uKHQ9a3Mpe3JldHVybiExPT09dD90PTA6ITA9PT10JiYodD1rcykse3g6UnModCxcImxlZnRcIixcInJpZ2h0XCIpLHk6UnModCxcInRvcFwiLFwiYm90dG9tXCIpfX0oZSkscyE9PXRoaXMuY29uc3RyYWludHMmJm4mJnRoaXMuY29uc3RyYWludHMmJiF0aGlzLmhhc011dGF0ZWRDb25zdHJhaW50cyYmanMoKHQ9Pnt0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZSh0KSYmKHRoaXMuY29uc3RyYWludHNbdF09ZnVuY3Rpb24odCxlKXtjb25zdCBuPXt9O3JldHVybiB2b2lkIDAhPT1lLm1pbiYmKG4ubWluPWUubWluLXQubWluKSx2b2lkIDAhPT1lLm1heCYmKG4ubWF4PWUubWF4LXQubWluKSxufShuLmxheW91dEJveFt0XSx0aGlzLmNvbnN0cmFpbnRzW3RdKSl9KSl9cmVzb2x2ZVJlZkNvbnN0cmFpbnRzKCl7Y29uc3R7ZHJhZ0NvbnN0cmFpbnRzOnQsb25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzOmV9PXRoaXMuZ2V0UHJvcHMoKTtpZighdHx8IVplKHQpKXJldHVybiExO2NvbnN0IG49dC5jdXJyZW50O3IobnVsbCE9PW4sXCJJZiBgZHJhZ0NvbnN0cmFpbnRzYCBpcyBzZXQgYXMgYSBSZWFjdCByZWYsIHRoYXQgcmVmIG11c3QgYmUgcGFzc2VkIHRvIGFub3RoZXIgY29tcG9uZW50J3MgYHJlZmAgcHJvcC5cIik7Y29uc3R7cHJvamVjdGlvbjpzfT10aGlzLnZpc3VhbEVsZW1lbnQ7aWYoIXN8fCFzLmxheW91dClyZXR1cm4hMTtjb25zdCBpPWZ1bmN0aW9uKHQsZSxuKXtjb25zdCBzPV9zKHQsbikse3Njcm9sbDppfT1lO3JldHVybiBpJiYoWHMocy54LGkub2Zmc2V0LngpLFhzKHMueSxpLm9mZnNldC55KSksc30obixzLnJvb3QsdGhpcy52aXN1YWxFbGVtZW50LmdldFRyYW5zZm9ybVBhZ2VQb2ludCgpKTtsZXQgbz1mdW5jdGlvbih0LGUpe3JldHVybnt4OkRzKHQueCxlLngpLHk6RHModC55LGUueSl9fShzLmxheW91dC5sYXlvdXRCb3gsaSk7aWYoZSl7Y29uc3QgdD1lKGZ1bmN0aW9uKHt4OnQseTplfSl7cmV0dXJue3RvcDplLm1pbixyaWdodDp0Lm1heCxib3R0b206ZS5tYXgsbGVmdDp0Lm1pbn19KG8pKTt0aGlzLmhhc011dGF0ZWRDb25zdHJhaW50cz0hIXQsdCYmKG89QnModCkpfXJldHVybiBvfXN0YXJ0QW5pbWF0aW9uKHQpe2NvbnN0e2RyYWc6ZSxkcmFnTW9tZW50dW06bixkcmFnRWxhc3RpYzpzLGRyYWdUcmFuc2l0aW9uOmksZHJhZ1NuYXBUb09yaWdpbjpvLG9uRHJhZ1RyYW5zaXRpb25FbmQ6cn09dGhpcy5nZXRQcm9wcygpLGE9dGhpcy5jb25zdHJhaW50c3x8e30sbD1qcygocj0+e2lmKCF0aShyLGUsdGhpcy5jdXJyZW50RGlyZWN0aW9uKSlyZXR1cm47bGV0IGw9YSYmYVtyXXx8e307byYmKGw9e21pbjowLG1heDowfSk7Y29uc3QgdT1zPzIwMDoxZTYsYz1zPzQwOjFlNyxoPXt0eXBlOlwiaW5lcnRpYVwiLHZlbG9jaXR5Om4/dFtyXTowLGJvdW5jZVN0aWZmbmVzczp1LGJvdW5jZURhbXBpbmc6Yyx0aW1lQ29uc3RhbnQ6NzUwLHJlc3REZWx0YToxLHJlc3RTcGVlZDoxMCwuLi5pLC4uLmx9O3JldHVybiB0aGlzLnN0YXJ0QXhpc1ZhbHVlQW5pbWF0aW9uKHIsaCl9KSk7cmV0dXJuIFByb21pc2UuYWxsKGwpLnRoZW4ocil9c3RhcnRBeGlzVmFsdWVBbmltYXRpb24odCxlKXtjb25zdCBuPXRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKHQpO3JldHVybiBuLnN0YXJ0KExlKHQsbiwwLGUpKX1zdG9wQW5pbWF0aW9uKCl7anMoKHQ9PnRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKHQpLnN0b3AoKSkpfWdldEF4aXNNb3Rpb25WYWx1ZSh0KXtjb25zdCBlPVwiX2RyYWdcIit0LnRvVXBwZXJDYXNlKCksbj10aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtyZXR1cm4gbltlXXx8dGhpcy52aXN1YWxFbGVtZW50LmdldFZhbHVlKHQsKG4uaW5pdGlhbD9uLmluaXRpYWxbdF06dm9pZCAwKXx8MCl9c25hcFRvQ3Vyc29yKHQpe2pzKChlPT57Y29uc3R7ZHJhZzpufT10aGlzLmdldFByb3BzKCk7aWYoIXRpKGUsbix0aGlzLmN1cnJlbnREaXJlY3Rpb24pKXJldHVybjtjb25zdHtwcm9qZWN0aW9uOnN9PXRoaXMudmlzdWFsRWxlbWVudCxpPXRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGUpO2lmKHMmJnMubGF5b3V0KXtjb25zdHttaW46bixtYXg6b309cy5sYXlvdXQubGF5b3V0Qm94W2VdO2kuc2V0KHRbZV0tS3QobixvLC41KSl9fSkpfXNjYWxlUG9zaXRpb25XaXRoaW5Db25zdHJhaW50cygpe2lmKCF0aGlzLnZpc3VhbEVsZW1lbnQuY3VycmVudClyZXR1cm47Y29uc3R7ZHJhZzp0LGRyYWdDb25zdHJhaW50czplfT10aGlzLmdldFByb3BzKCkse3Byb2plY3Rpb246bn09dGhpcy52aXN1YWxFbGVtZW50O2lmKCFaZShlKXx8IW58fCF0aGlzLmNvbnN0cmFpbnRzKXJldHVybjt0aGlzLnN0b3BBbmltYXRpb24oKTtjb25zdCBzPXt4OjAseTowfTtqcygodD0+e2NvbnN0IGU9dGhpcy5nZXRBeGlzTW90aW9uVmFsdWUodCk7aWYoZSl7Y29uc3Qgbj1lLmdldCgpO3NbdF09ZnVuY3Rpb24odCxlKXtsZXQgbj0uNTtjb25zdCBzPVRzKHQpLGk9VHMoZSk7cmV0dXJuIGk+cz9uPXVlKGUubWluLGUubWF4LXMsdC5taW4pOnM+aSYmKG49dWUodC5taW4sdC5tYXgtaSxlLm1pbikpLFIoMCwxLG4pfSh7bWluOm4sbWF4Om59LHRoaXMuY29uc3RyYWludHNbdF0pfX0pKTtjb25zdHt0cmFuc2Zvcm1UZW1wbGF0ZTppfT10aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTt0aGlzLnZpc3VhbEVsZW1lbnQuY3VycmVudC5zdHlsZS50cmFuc2Zvcm09aT9pKHt9LFwiXCIpOlwibm9uZVwiLG4ucm9vdCYmbi5yb290LnVwZGF0ZVNjcm9sbCgpLG4udXBkYXRlTGF5b3V0KCksdGhpcy5yZXNvbHZlQ29uc3RyYWludHMoKSxqcygoZT0+e2lmKCF0aShlLHQsbnVsbCkpcmV0dXJuO2NvbnN0IG49dGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoZSkse21pbjppLG1heDpvfT10aGlzLmNvbnN0cmFpbnRzW2VdO24uc2V0KEt0KGksbyxzW2VdKSl9KSl9YWRkTGlzdGVuZXJzKCl7aWYoIXRoaXMudmlzdWFsRWxlbWVudC5jdXJyZW50KXJldHVybjtKcy5zZXQodGhpcy52aXN1YWxFbGVtZW50LHRoaXMpO2NvbnN0IHQ9WG4odGhpcy52aXN1YWxFbGVtZW50LmN1cnJlbnQsXCJwb2ludGVyZG93blwiLCh0PT57Y29uc3R7ZHJhZzplLGRyYWdMaXN0ZW5lcjpuPSEwfT10aGlzLmdldFByb3BzKCk7ZSYmbiYmdGhpcy5zdGFydCh0KX0pKSxlPSgpPT57Y29uc3R7ZHJhZ0NvbnN0cmFpbnRzOnR9PXRoaXMuZ2V0UHJvcHMoKTtaZSh0KSYmKHRoaXMuY29uc3RyYWludHM9dGhpcy5yZXNvbHZlUmVmQ29uc3RyYWludHMoKSl9LHtwcm9qZWN0aW9uOm59PXRoaXMudmlzdWFsRWxlbWVudCxzPW4uYWRkRXZlbnRMaXN0ZW5lcihcIm1lYXN1cmVcIixlKTtuJiYhbi5sYXlvdXQmJihuLnJvb3QmJm4ucm9vdC51cGRhdGVTY3JvbGwoKSxuLnVwZGF0ZUxheW91dCgpKSxlKCk7Y29uc3QgaT1Ibih3aW5kb3csXCJyZXNpemVcIiwoKCk9PnRoaXMuc2NhbGVQb3NpdGlvbldpdGhpbkNvbnN0cmFpbnRzKCkpKSxvPW4uYWRkRXZlbnRMaXN0ZW5lcihcImRpZFVwZGF0ZVwiLCgoe2RlbHRhOnQsaGFzTGF5b3V0Q2hhbmdlZDplfSk9Pnt0aGlzLmlzRHJhZ2dpbmcmJmUmJihqcygoZT0+e2NvbnN0IG49dGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoZSk7biYmKHRoaXMub3JpZ2luUG9pbnRbZV0rPXRbZV0udHJhbnNsYXRlLG4uc2V0KG4uZ2V0KCkrdFtlXS50cmFuc2xhdGUpKX0pKSx0aGlzLnZpc3VhbEVsZW1lbnQucmVuZGVyKCkpfSkpO3JldHVybigpPT57aSgpLHQoKSxzKCksbyYmbygpfX1nZXRQcm9wcygpe2NvbnN0IHQ9dGhpcy52aXN1YWxFbGVtZW50LmdldFByb3BzKCkse2RyYWc6ZT0hMSxkcmFnRGlyZWN0aW9uTG9jazpuPSExLGRyYWdQcm9wYWdhdGlvbjpzPSExLGRyYWdDb25zdHJhaW50czppPSExLGRyYWdFbGFzdGljOm89a3MsZHJhZ01vbWVudHVtOnI9ITB9PXQ7cmV0dXJuey4uLnQsZHJhZzplLGRyYWdEaXJlY3Rpb25Mb2NrOm4sZHJhZ1Byb3BhZ2F0aW9uOnMsZHJhZ0NvbnN0cmFpbnRzOmksZHJhZ0VsYXN0aWM6byxkcmFnTW9tZW50dW06cn19fWZ1bmN0aW9uIHRpKHQsZSxuKXtyZXR1cm4hKCEwIT09ZSYmZSE9PXR8fG51bGwhPT1uJiZuIT09dCl9Y29uc3QgZWk9dD0+KGUsbik9Pnt0JiZ5LnVwZGF0ZSgoKCk9PnQoZSxuKSkpfSxuaT17aGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZTohMCxoYXNFdmVyVXBkYXRlZDohMX07ZnVuY3Rpb24gc2kodCxlKXtyZXR1cm4gZS5tYXg9PT1lLm1pbj8wOnQvKGUubWF4LWUubWluKSoxMDB9Y29uc3QgaWk9e2NvcnJlY3Q6KHQsZSk9PntpZighZS50YXJnZXQpcmV0dXJuIHQ7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe2lmKCF6LnRlc3QodCkpcmV0dXJuIHQ7dD1wYXJzZUZsb2F0KHQpfXJldHVybmAke3NpKHQsZS50YXJnZXQueCl9JSAke3NpKHQsZS50YXJnZXQueSl9JWB9fSxvaT17Y29ycmVjdDoodCx7dHJlZVNjYWxlOmUscHJvamVjdGlvbkRlbHRhOm59KT0+e2NvbnN0IHM9dCxpPWl0LnBhcnNlKHQpO2lmKGkubGVuZ3RoPjUpcmV0dXJuIHM7Y29uc3Qgbz1pdC5jcmVhdGVUcmFuc2Zvcm1lcih0KSxyPVwibnVtYmVyXCIhPXR5cGVvZiBpWzBdPzE6MCxhPW4ueC5zY2FsZSplLngsbD1uLnkuc2NhbGUqZS55O2lbMCtyXS89YSxpWzErcl0vPWw7Y29uc3QgdT1LdChhLGwsLjUpO3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBpWzIrcl0mJihpWzIrcl0vPXUpLFwibnVtYmVyXCI9PXR5cGVvZiBpWzMrcl0mJihpWzMrcl0vPXUpLG8oaSl9fTtjbGFzcyByaSBleHRlbmRzIHQuQ29tcG9uZW50e2NvbXBvbmVudERpZE1vdW50KCl7Y29uc3R7dmlzdWFsRWxlbWVudDp0LGxheW91dEdyb3VwOmUsc3dpdGNoTGF5b3V0R3JvdXA6bixsYXlvdXRJZDpzfT10aGlzLnByb3BzLHtwcm9qZWN0aW9uOml9PXQ7dmFyIG87bz1saSxPYmplY3QuYXNzaWduKHBuLG8pLGkmJihlLmdyb3VwJiZlLmdyb3VwLmFkZChpKSxuJiZuLnJlZ2lzdGVyJiZzJiZuLnJlZ2lzdGVyKGkpLGkucm9vdC5kaWRVcGRhdGUoKSxpLmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25Db21wbGV0ZVwiLCgoKT0+e3RoaXMuc2FmZVRvUmVtb3ZlKCl9KSksaS5zZXRPcHRpb25zKHsuLi5pLm9wdGlvbnMsb25FeGl0Q29tcGxldGU6KCk9PnRoaXMuc2FmZVRvUmVtb3ZlKCl9KSksbmkuaGFzRXZlclVwZGF0ZWQ9ITB9Z2V0U25hcHNob3RCZWZvcmVVcGRhdGUodCl7Y29uc3R7bGF5b3V0RGVwZW5kZW5jeTplLHZpc3VhbEVsZW1lbnQ6bixkcmFnOnMsaXNQcmVzZW50Oml9PXRoaXMucHJvcHMsbz1uLnByb2plY3Rpb247cmV0dXJuIG8/KG8uaXNQcmVzZW50PWksc3x8dC5sYXlvdXREZXBlbmRlbmN5IT09ZXx8dm9pZCAwPT09ZT9vLndpbGxVcGRhdGUoKTp0aGlzLnNhZmVUb1JlbW92ZSgpLHQuaXNQcmVzZW50IT09aSYmKGk/by5wcm9tb3RlKCk6by5yZWxlZ2F0ZSgpfHx5LnBvc3RSZW5kZXIoKCgpPT57Y29uc3QgdD1vLmdldFN0YWNrKCk7dCYmdC5tZW1iZXJzLmxlbmd0aHx8dGhpcy5zYWZlVG9SZW1vdmUoKX0pKSksbnVsbCk6bnVsbH1jb21wb25lbnREaWRVcGRhdGUoKXtjb25zdHtwcm9qZWN0aW9uOnR9PXRoaXMucHJvcHMudmlzdWFsRWxlbWVudDt0JiYodC5yb290LmRpZFVwZGF0ZSgpLHF1ZXVlTWljcm90YXNrKCgoKT0+eyF0LmN1cnJlbnRBbmltYXRpb24mJnQuaXNMZWFkKCkmJnRoaXMuc2FmZVRvUmVtb3ZlKCl9KSkpfWNvbXBvbmVudFdpbGxVbm1vdW50KCl7Y29uc3R7dmlzdWFsRWxlbWVudDp0LGxheW91dEdyb3VwOmUsc3dpdGNoTGF5b3V0R3JvdXA6bn09dGhpcy5wcm9wcyx7cHJvamVjdGlvbjpzfT10O3MmJihzLnNjaGVkdWxlQ2hlY2tBZnRlclVubW91bnQoKSxlJiZlLmdyb3VwJiZlLmdyb3VwLnJlbW92ZShzKSxuJiZuLmRlcmVnaXN0ZXImJm4uZGVyZWdpc3RlcihzKSl9c2FmZVRvUmVtb3ZlKCl7Y29uc3R7c2FmZVRvUmVtb3ZlOnR9PXRoaXMucHJvcHM7dCYmdCgpfXJlbmRlcigpe3JldHVybiBudWxsfX1mdW5jdGlvbiBhaShlKXtjb25zdFtuLHNdPWZ1bmN0aW9uKCl7Y29uc3QgZT0oMCx0LnVzZUNvbnRleHQpKEdlKTtpZihudWxsPT09ZSlyZXR1cm5bITAsbnVsbF07Y29uc3R7aXNQcmVzZW50Om4sb25FeGl0Q29tcGxldGU6cyxyZWdpc3RlcjppfT1lLG89KDAsdC51c2VJZCkoKTtyZXR1cm4oMCx0LnVzZUVmZmVjdCkoKCgpPT5pKG8pKSxbXSksIW4mJnM/WyExLCgpPT5zJiZzKG8pXTpbITBdfSgpLGk9KDAsdC51c2VDb250ZXh0KShybik7cmV0dXJuIHQuY3JlYXRlRWxlbWVudChyaSx7Li4uZSxsYXlvdXRHcm91cDppLHN3aXRjaExheW91dEdyb3VwOigwLHQudXNlQ29udGV4dCkoYW4pLGlzUHJlc2VudDpuLHNhZmVUb1JlbW92ZTpzfSl9Y29uc3QgbGk9e2JvcmRlclJhZGl1czp7Li4uaWksYXBwbHlUbzpbXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCIsXCJib3JkZXJUb3BSaWdodFJhZGl1c1wiLFwiYm9yZGVyQm90dG9tTGVmdFJhZGl1c1wiLFwiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcIl19LGJvcmRlclRvcExlZnRSYWRpdXM6aWksYm9yZGVyVG9wUmlnaHRSYWRpdXM6aWksYm9yZGVyQm90dG9tTGVmdFJhZGl1czppaSxib3JkZXJCb3R0b21SaWdodFJhZGl1czppaSxib3hTaGFkb3c6b2l9LHVpPVtcIlRvcExlZnRcIixcIlRvcFJpZ2h0XCIsXCJCb3R0b21MZWZ0XCIsXCJCb3R0b21SaWdodFwiXSxjaT11aS5sZW5ndGgsaGk9dD0+XCJzdHJpbmdcIj09dHlwZW9mIHQ/cGFyc2VGbG9hdCh0KTp0LGRpPXQ9PlwibnVtYmVyXCI9PXR5cGVvZiB0fHx6LnRlc3QodCk7ZnVuY3Rpb24gbWkodCxlKXtyZXR1cm4gdm9pZCAwIT09dFtlXT90W2VdOnQuYm9yZGVyUmFkaXVzfWNvbnN0IHBpPWdpKDAsLjUsSHQpLGZpPWdpKC41LC45NSxuKTtmdW5jdGlvbiBnaSh0LGUsbil7cmV0dXJuIHM9PnM8dD8wOnM+ZT8xOm4odWUodCxlLHMpKX1mdW5jdGlvbiB5aSh0LGUpe3QubWluPWUubWluLHQubWF4PWUubWF4fWZ1bmN0aW9uIHZpKHQsZSl7eWkodC54LGUueCkseWkodC55LGUueSl9ZnVuY3Rpb24geGkodCxlLG4scyxpKXtyZXR1cm4gdD0kcyh0LT1lLDEvbixzKSx2b2lkIDAhPT1pJiYodD0kcyh0LDEvaSxzKSksdH1mdW5jdGlvbiBQaSh0LGUsW24scyxpXSxvLHIpeyFmdW5jdGlvbih0LGU9MCxuPTEscz0uNSxpLG89dCxyPXQpe2lmKEgudGVzdChlKSYmKGU9cGFyc2VGbG9hdChlKSxlPUt0KHIubWluLHIubWF4LGUvMTAwKS1yLm1pbiksXCJudW1iZXJcIiE9dHlwZW9mIGUpcmV0dXJuO2xldCBhPUt0KG8ubWluLG8ubWF4LHMpO3Q9PT1vJiYoYS09ZSksdC5taW49eGkodC5taW4sZSxuLGEsaSksdC5tYXg9eGkodC5tYXgsZSxuLGEsaSl9KHQsZVtuXSxlW3NdLGVbaV0sZS5zY2FsZSxvLHIpfWNvbnN0IGJpPVtcInhcIixcInNjYWxlWFwiLFwib3JpZ2luWFwiXSxUaT1bXCJ5XCIsXCJzY2FsZVlcIixcIm9yaWdpbllcIl07ZnVuY3Rpb24gU2kodCxlLG4scyl7UGkodC54LGUsYmksbj9uLng6dm9pZCAwLHM/cy54OnZvaWQgMCksUGkodC55LGUsVGksbj9uLnk6dm9pZCAwLHM/cy55OnZvaWQgMCl9ZnVuY3Rpb24gd2kodCl7cmV0dXJuIDA9PT10LnRyYW5zbGF0ZSYmMT09PXQuc2NhbGV9ZnVuY3Rpb24gRWkodCl7cmV0dXJuIHdpKHQueCkmJndpKHQueSl9ZnVuY3Rpb24gQWkodCxlKXtyZXR1cm4gTWF0aC5yb3VuZCh0LngubWluKT09PU1hdGgucm91bmQoZS54Lm1pbikmJk1hdGgucm91bmQodC54Lm1heCk9PT1NYXRoLnJvdW5kKGUueC5tYXgpJiZNYXRoLnJvdW5kKHQueS5taW4pPT09TWF0aC5yb3VuZChlLnkubWluKSYmTWF0aC5yb3VuZCh0LnkubWF4KT09PU1hdGgucm91bmQoZS55Lm1heCl9ZnVuY3Rpb24gVmkodCl7cmV0dXJuIFRzKHQueCkvVHModC55KX1jbGFzcyBDaXtjb25zdHJ1Y3Rvcigpe3RoaXMubWVtYmVycz1bXX1hZGQodCl7aCh0aGlzLm1lbWJlcnMsdCksdC5zY2hlZHVsZVJlbmRlcigpfXJlbW92ZSh0KXtpZihkKHRoaXMubWVtYmVycyx0KSx0PT09dGhpcy5wcmV2TGVhZCYmKHRoaXMucHJldkxlYWQ9dm9pZCAwKSx0PT09dGhpcy5sZWFkKXtjb25zdCB0PXRoaXMubWVtYmVyc1t0aGlzLm1lbWJlcnMubGVuZ3RoLTFdO3QmJnRoaXMucHJvbW90ZSh0KX19cmVsZWdhdGUodCl7Y29uc3QgZT10aGlzLm1lbWJlcnMuZmluZEluZGV4KChlPT50PT09ZSkpO2lmKDA9PT1lKXJldHVybiExO2xldCBuO2ZvcihsZXQgdD1lO3Q+PTA7dC0tKXtjb25zdCBlPXRoaXMubWVtYmVyc1t0XTtpZighMSE9PWUuaXNQcmVzZW50KXtuPWU7YnJlYWt9fXJldHVybiEhbiYmKHRoaXMucHJvbW90ZShuKSwhMCl9cHJvbW90ZSh0LGUpe2NvbnN0IG49dGhpcy5sZWFkO2lmKHQhPT1uJiYodGhpcy5wcmV2TGVhZD1uLHRoaXMubGVhZD10LHQuc2hvdygpLG4pKXtuLmluc3RhbmNlJiZuLnNjaGVkdWxlUmVuZGVyKCksdC5zY2hlZHVsZVJlbmRlcigpLHQucmVzdW1lRnJvbT1uLGUmJih0LnJlc3VtZUZyb20ucHJlc2VydmVPcGFjaXR5PSEwKSxuLnNuYXBzaG90JiYodC5zbmFwc2hvdD1uLnNuYXBzaG90LHQuc25hcHNob3QubGF0ZXN0VmFsdWVzPW4uYW5pbWF0aW9uVmFsdWVzfHxuLmxhdGVzdFZhbHVlcyksdC5yb290JiZ0LnJvb3QuaXNVcGRhdGluZyYmKHQuaXNMYXlvdXREaXJ0eT0hMCk7Y29uc3R7Y3Jvc3NmYWRlOnN9PXQub3B0aW9uczshMT09PXMmJm4uaGlkZSgpfX1leGl0QW5pbWF0aW9uQ29tcGxldGUoKXt0aGlzLm1lbWJlcnMuZm9yRWFjaCgodD0+e2NvbnN0e29wdGlvbnM6ZSxyZXN1bWluZ0Zyb206bn09dDtlLm9uRXhpdENvbXBsZXRlJiZlLm9uRXhpdENvbXBsZXRlKCksbiYmbi5vcHRpb25zLm9uRXhpdENvbXBsZXRlJiZuLm9wdGlvbnMub25FeGl0Q29tcGxldGUoKX0pKX1zY2hlZHVsZVJlbmRlcigpe3RoaXMubWVtYmVycy5mb3JFYWNoKCh0PT57dC5pbnN0YW5jZSYmdC5zY2hlZHVsZVJlbmRlcighMSl9KSl9cmVtb3ZlTGVhZFNuYXBzaG90KCl7dGhpcy5sZWFkJiZ0aGlzLmxlYWQuc25hcHNob3QmJih0aGlzLmxlYWQuc25hcHNob3Q9dm9pZCAwKX19ZnVuY3Rpb24gTWkodCxlLG4pe2xldCBzPVwiXCI7Y29uc3QgaT10LngudHJhbnNsYXRlL2UueCxvPXQueS50cmFuc2xhdGUvZS55O2lmKChpfHxvKSYmKHM9YHRyYW5zbGF0ZTNkKCR7aX1weCwgJHtvfXB4LCAwKSBgKSwxPT09ZS54JiYxPT09ZS55fHwocys9YHNjYWxlKCR7MS9lLnh9LCAkezEvZS55fSkgYCksbil7Y29uc3R7cm90YXRlOnQscm90YXRlWDplLHJvdGF0ZVk6aX09bjt0JiYocys9YHJvdGF0ZSgke3R9ZGVnKSBgKSxlJiYocys9YHJvdGF0ZVgoJHtlfWRlZykgYCksaSYmKHMrPWByb3RhdGVZKCR7aX1kZWcpIGApfWNvbnN0IHI9dC54LnNjYWxlKmUueCxhPXQueS5zY2FsZSplLnk7cmV0dXJuIDE9PT1yJiYxPT09YXx8KHMrPWBzY2FsZSgke3J9LCAke2F9KWApLHN8fFwibm9uZVwifWNvbnN0IERpPSh0LGUpPT50LmRlcHRoLWUuZGVwdGg7Y2xhc3Mga2l7Y29uc3RydWN0b3IoKXt0aGlzLmNoaWxkcmVuPVtdLHRoaXMuaXNEaXJ0eT0hMX1hZGQodCl7aCh0aGlzLmNoaWxkcmVuLHQpLHRoaXMuaXNEaXJ0eT0hMH1yZW1vdmUodCl7ZCh0aGlzLmNoaWxkcmVuLHQpLHRoaXMuaXNEaXJ0eT0hMH1mb3JFYWNoKHQpe3RoaXMuaXNEaXJ0eSYmdGhpcy5jaGlsZHJlbi5zb3J0KERpKSx0aGlzLmlzRGlydHk9ITEsdGhpcy5jaGlsZHJlbi5mb3JFYWNoKHQpfX1jb25zdCBSaT1bXCJcIixcIlhcIixcIllcIixcIlpcIl07bGV0IExpPTA7Y29uc3Qgamk9e3R5cGU6XCJwcm9qZWN0aW9uRnJhbWVcIix0b3RhbE5vZGVzOjAscmVzb2x2ZWRUYXJnZXREZWx0YXM6MCxyZWNhbGN1bGF0ZWRQcm9qZWN0aW9uOjB9O2Z1bmN0aW9uIEJpKHthdHRhY2hSZXNpemVMaXN0ZW5lcjp0LGRlZmF1bHRQYXJlbnQ6ZSxtZWFzdXJlU2Nyb2xsOm4sY2hlY2tJc1Njcm9sbFJvb3Q6cyxyZXNldFRyYW5zZm9ybTppfSl7cmV0dXJuIGNsYXNze2NvbnN0cnVjdG9yKHQ9e30sbj0obnVsbD09ZT92b2lkIDA6ZSgpKSl7dGhpcy5pZD1MaSsrLHRoaXMuYW5pbWF0aW9uSWQ9MCx0aGlzLmNoaWxkcmVuPW5ldyBTZXQsdGhpcy5vcHRpb25zPXt9LHRoaXMuaXNUcmVlQW5pbWF0aW5nPSExLHRoaXMuaXNBbmltYXRpb25CbG9ja2VkPSExLHRoaXMuaXNMYXlvdXREaXJ0eT0hMSx0aGlzLmlzUHJvamVjdGlvbkRpcnR5PSExLHRoaXMuaXNTaGFyZWRQcm9qZWN0aW9uRGlydHk9ITEsdGhpcy5pc1RyYW5zZm9ybURpcnR5PSExLHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkPSExLHRoaXMudXBkYXRlQmxvY2tlZEJ5UmVzaXplPSExLHRoaXMuaXNVcGRhdGluZz0hMSx0aGlzLmlzU1ZHPSExLHRoaXMubmVlZHNSZXNldD0hMSx0aGlzLnNob3VsZFJlc2V0VHJhbnNmb3JtPSExLHRoaXMudHJlZVNjYWxlPXt4OjEseToxfSx0aGlzLmV2ZW50SGFuZGxlcnM9bmV3IE1hcCx0aGlzLmhhc1RyZWVBbmltYXRlZD0hMSx0aGlzLnVwZGF0ZVNjaGVkdWxlZD0hMSx0aGlzLmNoZWNrVXBkYXRlRmFpbGVkPSgpPT57dGhpcy5pc1VwZGF0aW5nJiYodGhpcy5pc1VwZGF0aW5nPSExLHRoaXMuY2xlYXJBbGxTbmFwc2hvdHMoKSl9LHRoaXMudXBkYXRlUHJvamVjdGlvbj0oKT0+e3ZhciB0O2ppLnRvdGFsTm9kZXM9amkucmVzb2x2ZWRUYXJnZXREZWx0YXM9amkucmVjYWxjdWxhdGVkUHJvamVjdGlvbj0wLHRoaXMubm9kZXMuZm9yRWFjaChJaSksdGhpcy5ub2Rlcy5mb3JFYWNoKFlpKSx0aGlzLm5vZGVzLmZvckVhY2goWGkpLHRoaXMubm9kZXMuZm9yRWFjaChVaSksdD1qaSx3aW5kb3cuTW90aW9uRGVidWcmJndpbmRvdy5Nb3Rpb25EZWJ1Zy5yZWNvcmQodCl9LHRoaXMuaGFzUHJvamVjdGVkPSExLHRoaXMuaXNWaXNpYmxlPSEwLHRoaXMuYW5pbWF0aW9uUHJvZ3Jlc3M9MCx0aGlzLnNoYXJlZE5vZGVzPW5ldyBNYXAsdGhpcy5sYXRlc3RWYWx1ZXM9dCx0aGlzLnJvb3Q9bj9uLnJvb3R8fG46dGhpcyx0aGlzLnBhdGg9bj9bLi4ubi5wYXRoLG5dOltdLHRoaXMucGFyZW50PW4sdGhpcy5kZXB0aD1uP24uZGVwdGgrMTowO2ZvcihsZXQgdD0wO3Q8dGhpcy5wYXRoLmxlbmd0aDt0KyspdGhpcy5wYXRoW3RdLnNob3VsZFJlc2V0VHJhbnNmb3JtPSEwO3RoaXMucm9vdD09PXRoaXMmJih0aGlzLm5vZGVzPW5ldyBraSl9YWRkRXZlbnRMaXN0ZW5lcih0LGUpe3JldHVybiB0aGlzLmV2ZW50SGFuZGxlcnMuaGFzKHQpfHx0aGlzLmV2ZW50SGFuZGxlcnMuc2V0KHQsbmV3IG0pLHRoaXMuZXZlbnRIYW5kbGVycy5nZXQodCkuYWRkKGUpfW5vdGlmeUxpc3RlbmVycyh0LC4uLmUpe2NvbnN0IG49dGhpcy5ldmVudEhhbmRsZXJzLmdldCh0KTtuJiZuLm5vdGlmeSguLi5lKX1oYXNMaXN0ZW5lcnModCl7cmV0dXJuIHRoaXMuZXZlbnRIYW5kbGVycy5oYXModCl9bW91bnQoZSxuPXRoaXMucm9vdC5oYXNUcmVlQW5pbWF0ZWQpe2lmKHRoaXMuaW5zdGFuY2UpcmV0dXJuO3ZhciBzO3RoaXMuaXNTVkc9KHM9ZSlpbnN0YW5jZW9mIFNWR0VsZW1lbnQmJlwic3ZnXCIhPT1zLnRhZ05hbWUsdGhpcy5pbnN0YW5jZT1lO2NvbnN0e2xheW91dElkOmksbGF5b3V0Om8sdmlzdWFsRWxlbWVudDpyfT10aGlzLm9wdGlvbnM7aWYociYmIXIuY3VycmVudCYmci5tb3VudChlKSx0aGlzLnJvb3Qubm9kZXMuYWRkKHRoaXMpLHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5jaGlsZHJlbi5hZGQodGhpcyksbiYmKG98fGkpJiYodGhpcy5pc0xheW91dERpcnR5PSEwKSx0KXtsZXQgbjtjb25zdCBzPSgpPT50aGlzLnJvb3QudXBkYXRlQmxvY2tlZEJ5UmVzaXplPSExO3QoZSwoKCk9Pnt0aGlzLnJvb3QudXBkYXRlQmxvY2tlZEJ5UmVzaXplPSEwLG4mJm4oKSxuPWZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj1wZXJmb3JtYW5jZS5ub3coKSxzPSh7dGltZXN0YW1wOmV9KT0+e2NvbnN0IGk9ZS1uO2k+PTI1MCYmKHYocyksdChpLTI1MCkpfTtyZXR1cm4geS5yZWFkKHMsITApLCgpPT52KHMpfShzKSxuaS5oYXNBbmltYXRlZFNpbmNlUmVzaXplJiYobmkuaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZT0hMSx0aGlzLm5vZGVzLmZvckVhY2goemkpKX0pKX1pJiZ0aGlzLnJvb3QucmVnaXN0ZXJTaGFyZWROb2RlKGksdGhpcyksITEhPT10aGlzLm9wdGlvbnMuYW5pbWF0ZSYmciYmKGl8fG8pJiZ0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJkaWRVcGRhdGVcIiwoKHtkZWx0YTp0LGhhc0xheW91dENoYW5nZWQ6ZSxoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQ6bixsYXlvdXQ6c30pPT57aWYodGhpcy5pc1RyZWVBbmltYXRpb25CbG9ja2VkKCkpcmV0dXJuIHRoaXMudGFyZ2V0PXZvaWQgMCx2b2lkKHRoaXMucmVsYXRpdmVUYXJnZXQ9dm9pZCAwKTtjb25zdCBpPXRoaXMub3B0aW9ucy50cmFuc2l0aW9ufHxyLmdldERlZmF1bHRUcmFuc2l0aW9uKCl8fEppLHtvbkxheW91dEFuaW1hdGlvblN0YXJ0Om8sb25MYXlvdXRBbmltYXRpb25Db21wbGV0ZTphfT1yLmdldFByb3BzKCksbD0hdGhpcy50YXJnZXRMYXlvdXR8fCFBaSh0aGlzLnRhcmdldExheW91dCxzKXx8bix1PSFlJiZuO2lmKHRoaXMub3B0aW9ucy5sYXlvdXRSb290fHx0aGlzLnJlc3VtZUZyb20mJnRoaXMucmVzdW1lRnJvbS5pbnN0YW5jZXx8dXx8ZSYmKGx8fCF0aGlzLmN1cnJlbnRBbmltYXRpb24pKXt0aGlzLnJlc3VtZUZyb20mJih0aGlzLnJlc3VtaW5nRnJvbT10aGlzLnJlc3VtZUZyb20sdGhpcy5yZXN1bWluZ0Zyb20ucmVzdW1pbmdGcm9tPXZvaWQgMCksdGhpcy5zZXRBbmltYXRpb25PcmlnaW4odCx1KTtjb25zdCBlPXsuLi5SZShpLFwibGF5b3V0XCIpLG9uUGxheTpvLG9uQ29tcGxldGU6YX07KHIuc2hvdWxkUmVkdWNlTW90aW9ufHx0aGlzLm9wdGlvbnMubGF5b3V0Um9vdCkmJihlLmRlbGF5PTAsZS50eXBlPSExKSx0aGlzLnN0YXJ0QW5pbWF0aW9uKGUpfWVsc2UgZXx8emkodGhpcyksdGhpcy5pc0xlYWQoKSYmdGhpcy5vcHRpb25zLm9uRXhpdENvbXBsZXRlJiZ0aGlzLm9wdGlvbnMub25FeGl0Q29tcGxldGUoKTt0aGlzLnRhcmdldExheW91dD1zfSkpfXVubW91bnQoKXt0aGlzLm9wdGlvbnMubGF5b3V0SWQmJnRoaXMud2lsbFVwZGF0ZSgpLHRoaXMucm9vdC5ub2Rlcy5yZW1vdmUodGhpcyk7Y29uc3QgdD10aGlzLmdldFN0YWNrKCk7dCYmdC5yZW1vdmUodGhpcyksdGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LmNoaWxkcmVuLmRlbGV0ZSh0aGlzKSx0aGlzLmluc3RhbmNlPXZvaWQgMCx2KHRoaXMudXBkYXRlUHJvamVjdGlvbil9YmxvY2tVcGRhdGUoKXt0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZD0hMH11bmJsb2NrVXBkYXRlKCl7dGhpcy51cGRhdGVNYW51YWxseUJsb2NrZWQ9ITF9aXNVcGRhdGVCbG9ja2VkKCl7cmV0dXJuIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkfHx0aGlzLnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZX1pc1RyZWVBbmltYXRpb25CbG9ja2VkKCl7cmV0dXJuIHRoaXMuaXNBbmltYXRpb25CbG9ja2VkfHx0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuaXNUcmVlQW5pbWF0aW9uQmxvY2tlZCgpfHwhMX1zdGFydFVwZGF0ZSgpe3RoaXMuaXNVcGRhdGVCbG9ja2VkKCl8fCh0aGlzLmlzVXBkYXRpbmc9ITAsdGhpcy5ub2RlcyYmdGhpcy5ub2Rlcy5mb3JFYWNoKEdpKSx0aGlzLmFuaW1hdGlvbklkKyspfWdldFRyYW5zZm9ybVRlbXBsYXRlKCl7Y29uc3R7dmlzdWFsRWxlbWVudDp0fT10aGlzLm9wdGlvbnM7cmV0dXJuIHQmJnQuZ2V0UHJvcHMoKS50cmFuc2Zvcm1UZW1wbGF0ZX13aWxsVXBkYXRlKHQ9ITApe2lmKHRoaXMucm9vdC5oYXNUcmVlQW5pbWF0ZWQ9ITAsdGhpcy5yb290LmlzVXBkYXRlQmxvY2tlZCgpKXJldHVybiB2b2lkKHRoaXMub3B0aW9ucy5vbkV4aXRDb21wbGV0ZSYmdGhpcy5vcHRpb25zLm9uRXhpdENvbXBsZXRlKCkpO2lmKCF0aGlzLnJvb3QuaXNVcGRhdGluZyYmdGhpcy5yb290LnN0YXJ0VXBkYXRlKCksdGhpcy5pc0xheW91dERpcnR5KXJldHVybjt0aGlzLmlzTGF5b3V0RGlydHk9ITA7Zm9yKGxldCB0PTA7dDx0aGlzLnBhdGgubGVuZ3RoO3QrKyl7Y29uc3QgZT10aGlzLnBhdGhbdF07ZS5zaG91bGRSZXNldFRyYW5zZm9ybT0hMCxlLnVwZGF0ZVNjcm9sbChcInNuYXBzaG90XCIpLGUub3B0aW9ucy5sYXlvdXRSb290JiZlLndpbGxVcGRhdGUoITEpfWNvbnN0e2xheW91dElkOmUsbGF5b3V0Om59PXRoaXMub3B0aW9ucztpZih2b2lkIDA9PT1lJiYhbilyZXR1cm47Y29uc3Qgcz10aGlzLmdldFRyYW5zZm9ybVRlbXBsYXRlKCk7dGhpcy5wcmV2VHJhbnNmb3JtVGVtcGxhdGVWYWx1ZT1zP3ModGhpcy5sYXRlc3RWYWx1ZXMsXCJcIik6dm9pZCAwLHRoaXMudXBkYXRlU25hcHNob3QoKSx0JiZ0aGlzLm5vdGlmeUxpc3RlbmVycyhcIndpbGxVcGRhdGVcIil9dXBkYXRlKCl7aWYodGhpcy51cGRhdGVTY2hlZHVsZWQ9ITEsdGhpcy5pc1VwZGF0ZUJsb2NrZWQoKSlyZXR1cm4gdGhpcy51bmJsb2NrVXBkYXRlKCksdGhpcy5jbGVhckFsbFNuYXBzaG90cygpLHZvaWQgdGhpcy5ub2Rlcy5mb3JFYWNoKCRpKTt0aGlzLmlzVXBkYXRpbmd8fHRoaXMubm9kZXMuZm9yRWFjaChXaSksdGhpcy5pc1VwZGF0aW5nPSExLHRoaXMubm9kZXMuZm9yRWFjaChIaSksdGhpcy5ub2Rlcy5mb3JFYWNoKEZpKSx0aGlzLm5vZGVzLmZvckVhY2goT2kpLHRoaXMuY2xlYXJBbGxTbmFwc2hvdHMoKTtjb25zdCB0PXBlcmZvcm1hbmNlLm5vdygpO3guZGVsdGE9UigwLDFlMy82MCx0LXgudGltZXN0YW1wKSx4LnRpbWVzdGFtcD10LHguaXNQcm9jZXNzaW5nPSEwLFAudXBkYXRlLnByb2Nlc3MoeCksUC5wcmVSZW5kZXIucHJvY2Vzcyh4KSxQLnJlbmRlci5wcm9jZXNzKHgpLHguaXNQcm9jZXNzaW5nPSExfWRpZFVwZGF0ZSgpe3RoaXMudXBkYXRlU2NoZWR1bGVkfHwodGhpcy51cGRhdGVTY2hlZHVsZWQ9ITAscXVldWVNaWNyb3Rhc2soKCgpPT50aGlzLnVwZGF0ZSgpKSkpfWNsZWFyQWxsU25hcHNob3RzKCl7dGhpcy5ub2Rlcy5mb3JFYWNoKE5pKSx0aGlzLnNoYXJlZE5vZGVzLmZvckVhY2gocWkpfXNjaGVkdWxlVXBkYXRlUHJvamVjdGlvbigpe3kucHJlUmVuZGVyKHRoaXMudXBkYXRlUHJvamVjdGlvbiwhMSwhMCl9c2NoZWR1bGVDaGVja0FmdGVyVW5tb3VudCgpe3kucG9zdFJlbmRlcigoKCk9Pnt0aGlzLmlzTGF5b3V0RGlydHk/dGhpcy5yb290LmRpZFVwZGF0ZSgpOnRoaXMucm9vdC5jaGVja1VwZGF0ZUZhaWxlZCgpfSkpfXVwZGF0ZVNuYXBzaG90KCl7IXRoaXMuc25hcHNob3QmJnRoaXMuaW5zdGFuY2UmJih0aGlzLnNuYXBzaG90PXRoaXMubWVhc3VyZSgpKX11cGRhdGVMYXlvdXQoKXtpZighdGhpcy5pbnN0YW5jZSlyZXR1cm47aWYodGhpcy51cGRhdGVTY3JvbGwoKSwhKHRoaXMub3B0aW9ucy5hbHdheXNNZWFzdXJlTGF5b3V0JiZ0aGlzLmlzTGVhZCgpfHx0aGlzLmlzTGF5b3V0RGlydHkpKXJldHVybjtpZih0aGlzLnJlc3VtZUZyb20mJiF0aGlzLnJlc3VtZUZyb20uaW5zdGFuY2UpZm9yKGxldCB0PTA7dDx0aGlzLnBhdGgubGVuZ3RoO3QrKyl0aGlzLnBhdGhbdF0udXBkYXRlU2Nyb2xsKCk7Y29uc3QgdD10aGlzLmxheW91dDt0aGlzLmxheW91dD10aGlzLm1lYXN1cmUoITEpLHRoaXMubGF5b3V0Q29ycmVjdGVkPXt4OnttaW46MCxtYXg6MH0seTp7bWluOjAsbWF4OjB9fSx0aGlzLmlzTGF5b3V0RGlydHk9ITEsdGhpcy5wcm9qZWN0aW9uRGVsdGE9dm9pZCAwLHRoaXMubm90aWZ5TGlzdGVuZXJzKFwibWVhc3VyZVwiLHRoaXMubGF5b3V0LmxheW91dEJveCk7Y29uc3R7dmlzdWFsRWxlbWVudDplfT10aGlzLm9wdGlvbnM7ZSYmZS5ub3RpZnkoXCJMYXlvdXRNZWFzdXJlXCIsdGhpcy5sYXlvdXQubGF5b3V0Qm94LHQ/dC5sYXlvdXRCb3g6dm9pZCAwKX11cGRhdGVTY3JvbGwodD1cIm1lYXN1cmVcIil7bGV0IGU9Qm9vbGVhbih0aGlzLm9wdGlvbnMubGF5b3V0U2Nyb2xsJiZ0aGlzLmluc3RhbmNlKTt0aGlzLnNjcm9sbCYmdGhpcy5zY3JvbGwuYW5pbWF0aW9uSWQ9PT10aGlzLnJvb3QuYW5pbWF0aW9uSWQmJnRoaXMuc2Nyb2xsLnBoYXNlPT09dCYmKGU9ITEpLGUmJih0aGlzLnNjcm9sbD17YW5pbWF0aW9uSWQ6dGhpcy5yb290LmFuaW1hdGlvbklkLHBoYXNlOnQsaXNSb290OnModGhpcy5pbnN0YW5jZSksb2Zmc2V0Om4odGhpcy5pbnN0YW5jZSl9KX1yZXNldFRyYW5zZm9ybSgpe2lmKCFpKXJldHVybjtjb25zdCB0PXRoaXMuaXNMYXlvdXREaXJ0eXx8dGhpcy5zaG91bGRSZXNldFRyYW5zZm9ybSxlPXRoaXMucHJvamVjdGlvbkRlbHRhJiYhRWkodGhpcy5wcm9qZWN0aW9uRGVsdGEpLG49dGhpcy5nZXRUcmFuc2Zvcm1UZW1wbGF0ZSgpLHM9bj9uKHRoaXMubGF0ZXN0VmFsdWVzLFwiXCIpOnZvaWQgMCxvPXMhPT10aGlzLnByZXZUcmFuc2Zvcm1UZW1wbGF0ZVZhbHVlO3QmJihlfHxJcyh0aGlzLmxhdGVzdFZhbHVlcyl8fG8pJiYoaSh0aGlzLmluc3RhbmNlLHMpLHRoaXMuc2hvdWxkUmVzZXRUcmFuc2Zvcm09ITEsdGhpcy5zY2hlZHVsZVJlbmRlcigpKX1tZWFzdXJlKHQ9ITApe2NvbnN0IGU9dGhpcy5tZWFzdXJlUGFnZUJveCgpO2xldCBuPXRoaXMucmVtb3ZlRWxlbWVudFNjcm9sbChlKTt2YXIgcztyZXR1cm4gdCYmKG49dGhpcy5yZW1vdmVUcmFuc2Zvcm0obikpLGVvKChzPW4pLngpLGVvKHMueSkse2FuaW1hdGlvbklkOnRoaXMucm9vdC5hbmltYXRpb25JZCxtZWFzdXJlZEJveDplLGxheW91dEJveDpuLGxhdGVzdFZhbHVlczp7fSxzb3VyY2U6dGhpcy5pZH19bWVhc3VyZVBhZ2VCb3goKXtjb25zdHt2aXN1YWxFbGVtZW50OnR9PXRoaXMub3B0aW9ucztpZighdClyZXR1cm57eDp7bWluOjAsbWF4OjB9LHk6e21pbjowLG1heDowfX07Y29uc3QgZT10Lm1lYXN1cmVWaWV3cG9ydEJveCgpLHtzY3JvbGw6bn09dGhpcy5yb290O3JldHVybiBuJiYoWHMoZS54LG4ub2Zmc2V0LngpLFhzKGUueSxuLm9mZnNldC55KSksZX1yZW1vdmVFbGVtZW50U2Nyb2xsKHQpe2NvbnN0IGU9e3g6e21pbjowLG1heDowfSx5OnttaW46MCxtYXg6MH19O3ZpKGUsdCk7Zm9yKGxldCBuPTA7bjx0aGlzLnBhdGgubGVuZ3RoO24rKyl7Y29uc3Qgcz10aGlzLnBhdGhbbl0se3Njcm9sbDppLG9wdGlvbnM6b309cztpZihzIT09dGhpcy5yb290JiZpJiZvLmxheW91dFNjcm9sbCl7aWYoaS5pc1Jvb3Qpe3ZpKGUsdCk7Y29uc3R7c2Nyb2xsOm59PXRoaXMucm9vdDtuJiYoWHMoZS54LC1uLm9mZnNldC54KSxYcyhlLnksLW4ub2Zmc2V0LnkpKX1YcyhlLngsaS5vZmZzZXQueCksWHMoZS55LGkub2Zmc2V0LnkpfX1yZXR1cm4gZX1hcHBseVRyYW5zZm9ybSh0LGU9ITEpe2NvbnN0IG49e3g6e21pbjowLG1heDowfSx5OnttaW46MCxtYXg6MH19O3ZpKG4sdCk7Zm9yKGxldCB0PTA7dDx0aGlzLnBhdGgubGVuZ3RoO3QrKyl7Y29uc3Qgcz10aGlzLnBhdGhbdF07IWUmJnMub3B0aW9ucy5sYXlvdXRTY3JvbGwmJnMuc2Nyb2xsJiZzIT09cy5yb290JiZLcyhuLHt4Oi1zLnNjcm9sbC5vZmZzZXQueCx5Oi1zLnNjcm9sbC5vZmZzZXQueX0pLElzKHMubGF0ZXN0VmFsdWVzKSYmS3MobixzLmxhdGVzdFZhbHVlcyl9cmV0dXJuIElzKHRoaXMubGF0ZXN0VmFsdWVzKSYmS3Mobix0aGlzLmxhdGVzdFZhbHVlcyksbn1yZW1vdmVUcmFuc2Zvcm0odCl7Y29uc3QgZT17eDp7bWluOjAsbWF4OjB9LHk6e21pbjowLG1heDowfX07dmkoZSx0KTtmb3IobGV0IHQ9MDt0PHRoaXMucGF0aC5sZW5ndGg7dCsrKXtjb25zdCBuPXRoaXMucGF0aFt0XTtpZighbi5pbnN0YW5jZSljb250aW51ZTtpZighSXMobi5sYXRlc3RWYWx1ZXMpKWNvbnRpbnVlO09zKG4ubGF0ZXN0VmFsdWVzKSYmbi51cGRhdGVTbmFwc2hvdCgpO2NvbnN0IHM9e3g6e21pbjowLG1heDowfSx5OnttaW46MCxtYXg6MH19O3ZpKHMsbi5tZWFzdXJlUGFnZUJveCgpKSxTaShlLG4ubGF0ZXN0VmFsdWVzLG4uc25hcHNob3Q/bi5zbmFwc2hvdC5sYXlvdXRCb3g6dm9pZCAwLHMpfXJldHVybiBJcyh0aGlzLmxhdGVzdFZhbHVlcykmJlNpKGUsdGhpcy5sYXRlc3RWYWx1ZXMpLGV9c2V0VGFyZ2V0RGVsdGEodCl7dGhpcy50YXJnZXREZWx0YT10LHRoaXMucm9vdC5zY2hlZHVsZVVwZGF0ZVByb2plY3Rpb24oKSx0aGlzLmlzUHJvamVjdGlvbkRpcnR5PSEwfXNldE9wdGlvbnModCl7dGhpcy5vcHRpb25zPXsuLi50aGlzLm9wdGlvbnMsLi4udCxjcm9zc2ZhZGU6dm9pZCAwPT09dC5jcm9zc2ZhZGV8fHQuY3Jvc3NmYWRlfX1jbGVhck1lYXN1cmVtZW50cygpe3RoaXMuc2Nyb2xsPXZvaWQgMCx0aGlzLmxheW91dD12b2lkIDAsdGhpcy5zbmFwc2hvdD12b2lkIDAsdGhpcy5wcmV2VHJhbnNmb3JtVGVtcGxhdGVWYWx1ZT12b2lkIDAsdGhpcy50YXJnZXREZWx0YT12b2lkIDAsdGhpcy50YXJnZXQ9dm9pZCAwLHRoaXMuaXNMYXlvdXREaXJ0eT0hMX1mb3JjZVJlbGF0aXZlUGFyZW50VG9SZXNvbHZlVGFyZ2V0KCl7dGhpcy5yZWxhdGl2ZVBhcmVudCYmdGhpcy5yZWxhdGl2ZVBhcmVudC5yZXNvbHZlZFJlbGF0aXZlVGFyZ2V0QXQhPT14LnRpbWVzdGFtcCYmdGhpcy5yZWxhdGl2ZVBhcmVudC5yZXNvbHZlVGFyZ2V0RGVsdGEoITApfXJlc29sdmVUYXJnZXREZWx0YSh0PSExKXt2YXIgZTtjb25zdCBuPXRoaXMuZ2V0TGVhZCgpO3RoaXMuaXNQcm9qZWN0aW9uRGlydHl8fCh0aGlzLmlzUHJvamVjdGlvbkRpcnR5PW4uaXNQcm9qZWN0aW9uRGlydHkpLHRoaXMuaXNUcmFuc2Zvcm1EaXJ0eXx8KHRoaXMuaXNUcmFuc2Zvcm1EaXJ0eT1uLmlzVHJhbnNmb3JtRGlydHkpLHRoaXMuaXNTaGFyZWRQcm9qZWN0aW9uRGlydHl8fCh0aGlzLmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5PW4uaXNTaGFyZWRQcm9qZWN0aW9uRGlydHkpO2NvbnN0IHM9Qm9vbGVhbih0aGlzLnJlc3VtaW5nRnJvbSl8fHRoaXMhPT1uO2lmKCEodHx8cyYmdGhpcy5pc1NoYXJlZFByb2plY3Rpb25EaXJ0eXx8dGhpcy5pc1Byb2plY3Rpb25EaXJ0eXx8KG51bGw9PT0oZT10aGlzLnBhcmVudCl8fHZvaWQgMD09PWU/dm9pZCAwOmUuaXNQcm9qZWN0aW9uRGlydHkpfHx0aGlzLmF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldCkpcmV0dXJuO2NvbnN0e2xheW91dDppLGxheW91dElkOm99PXRoaXMub3B0aW9ucztpZih0aGlzLmxheW91dCYmKGl8fG8pKXtpZih0aGlzLnJlc29sdmVkUmVsYXRpdmVUYXJnZXRBdD14LnRpbWVzdGFtcCwhdGhpcy50YXJnZXREZWx0YSYmIXRoaXMucmVsYXRpdmVUYXJnZXQpe2NvbnN0IHQ9dGhpcy5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO3QmJnQubGF5b3V0JiYxIT09dGhpcy5hbmltYXRpb25Qcm9ncmVzcz8odGhpcy5yZWxhdGl2ZVBhcmVudD10LHRoaXMuZm9yY2VSZWxhdGl2ZVBhcmVudFRvUmVzb2x2ZVRhcmdldCgpLHRoaXMucmVsYXRpdmVUYXJnZXQ9e3g6e21pbjowLG1heDowfSx5OnttaW46MCxtYXg6MH19LHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW49e3g6e21pbjowLG1heDowfSx5OnttaW46MCxtYXg6MH19LENzKHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4sdGhpcy5sYXlvdXQubGF5b3V0Qm94LHQubGF5b3V0LmxheW91dEJveCksdmkodGhpcy5yZWxhdGl2ZVRhcmdldCx0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luKSk6dGhpcy5yZWxhdGl2ZVBhcmVudD10aGlzLnJlbGF0aXZlVGFyZ2V0PXZvaWQgMH1pZih0aGlzLnJlbGF0aXZlVGFyZ2V0fHx0aGlzLnRhcmdldERlbHRhKXt2YXIgcixhLGw7aWYodGhpcy50YXJnZXR8fCh0aGlzLnRhcmdldD17eDp7bWluOjAsbWF4OjB9LHk6e21pbjowLG1heDowfX0sdGhpcy50YXJnZXRXaXRoVHJhbnNmb3Jtcz17eDp7bWluOjAsbWF4OjB9LHk6e21pbjowLG1heDowfX0pLHRoaXMucmVsYXRpdmVUYXJnZXQmJnRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4mJnRoaXMucmVsYXRpdmVQYXJlbnQmJnRoaXMucmVsYXRpdmVQYXJlbnQudGFyZ2V0Pyh0aGlzLmZvcmNlUmVsYXRpdmVQYXJlbnRUb1Jlc29sdmVUYXJnZXQoKSxyPXRoaXMudGFyZ2V0LGE9dGhpcy5yZWxhdGl2ZVRhcmdldCxsPXRoaXMucmVsYXRpdmVQYXJlbnQudGFyZ2V0LEFzKHIueCxhLngsbC54KSxBcyhyLnksYS55LGwueSkpOnRoaXMudGFyZ2V0RGVsdGE/KEJvb2xlYW4odGhpcy5yZXN1bWluZ0Zyb20pP3RoaXMudGFyZ2V0PXRoaXMuYXBwbHlUcmFuc2Zvcm0odGhpcy5sYXlvdXQubGF5b3V0Qm94KTp2aSh0aGlzLnRhcmdldCx0aGlzLmxheW91dC5sYXlvdXRCb3gpLHpzKHRoaXMudGFyZ2V0LHRoaXMudGFyZ2V0RGVsdGEpKTp2aSh0aGlzLnRhcmdldCx0aGlzLmxheW91dC5sYXlvdXRCb3gpLHRoaXMuYXR0ZW1wdFRvUmVzb2x2ZVJlbGF0aXZlVGFyZ2V0KXt0aGlzLmF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldD0hMTtjb25zdCB0PXRoaXMuZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKTt0JiZCb29sZWFuKHQucmVzdW1pbmdGcm9tKT09PUJvb2xlYW4odGhpcy5yZXN1bWluZ0Zyb20pJiYhdC5vcHRpb25zLmxheW91dFNjcm9sbCYmdC50YXJnZXQmJjEhPT10aGlzLmFuaW1hdGlvblByb2dyZXNzPyh0aGlzLnJlbGF0aXZlUGFyZW50PXQsdGhpcy5mb3JjZVJlbGF0aXZlUGFyZW50VG9SZXNvbHZlVGFyZ2V0KCksdGhpcy5yZWxhdGl2ZVRhcmdldD17eDp7bWluOjAsbWF4OjB9LHk6e21pbjowLG1heDowfX0sdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbj17eDp7bWluOjAsbWF4OjB9LHk6e21pbjowLG1heDowfX0sQ3ModGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbix0aGlzLnRhcmdldCx0LnRhcmdldCksdmkodGhpcy5yZWxhdGl2ZVRhcmdldCx0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luKSk6dGhpcy5yZWxhdGl2ZVBhcmVudD10aGlzLnJlbGF0aXZlVGFyZ2V0PXZvaWQgMH1qaS5yZXNvbHZlZFRhcmdldERlbHRhcysrfX19Z2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKXtpZih0aGlzLnBhcmVudCYmIU9zKHRoaXMucGFyZW50LmxhdGVzdFZhbHVlcykmJiFVcyh0aGlzLnBhcmVudC5sYXRlc3RWYWx1ZXMpKXJldHVybiB0aGlzLnBhcmVudC5pc1Byb2plY3RpbmcoKT90aGlzLnBhcmVudDp0aGlzLnBhcmVudC5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpfWlzUHJvamVjdGluZygpe3JldHVybiBCb29sZWFuKCh0aGlzLnJlbGF0aXZlVGFyZ2V0fHx0aGlzLnRhcmdldERlbHRhfHx0aGlzLm9wdGlvbnMubGF5b3V0Um9vdCkmJnRoaXMubGF5b3V0KX1jYWxjUHJvamVjdGlvbigpe3ZhciB0O2NvbnN0IGU9dGhpcy5nZXRMZWFkKCksbj1Cb29sZWFuKHRoaXMucmVzdW1pbmdGcm9tKXx8dGhpcyE9PWU7bGV0IHM9ITA7aWYoKHRoaXMuaXNQcm9qZWN0aW9uRGlydHl8fChudWxsPT09KHQ9dGhpcy5wYXJlbnQpfHx2b2lkIDA9PT10P3ZvaWQgMDp0LmlzUHJvamVjdGlvbkRpcnR5KSkmJihzPSExKSxuJiYodGhpcy5pc1NoYXJlZFByb2plY3Rpb25EaXJ0eXx8dGhpcy5pc1RyYW5zZm9ybURpcnR5KSYmKHM9ITEpLHRoaXMucmVzb2x2ZWRSZWxhdGl2ZVRhcmdldEF0PT09eC50aW1lc3RhbXAmJihzPSExKSxzKXJldHVybjtjb25zdHtsYXlvdXQ6aSxsYXlvdXRJZDpvfT10aGlzLm9wdGlvbnM7aWYodGhpcy5pc1RyZWVBbmltYXRpbmc9Qm9vbGVhbih0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuaXNUcmVlQW5pbWF0aW5nfHx0aGlzLmN1cnJlbnRBbmltYXRpb258fHRoaXMucGVuZGluZ0FuaW1hdGlvbiksdGhpcy5pc1RyZWVBbmltYXRpbmd8fCh0aGlzLnRhcmdldERlbHRhPXRoaXMucmVsYXRpdmVUYXJnZXQ9dm9pZCAwKSwhdGhpcy5sYXlvdXR8fCFpJiYhbylyZXR1cm47dmkodGhpcy5sYXlvdXRDb3JyZWN0ZWQsdGhpcy5sYXlvdXQubGF5b3V0Qm94KTtjb25zdCByPXRoaXMudHJlZVNjYWxlLngsYT10aGlzLnRyZWVTY2FsZS55OyFmdW5jdGlvbih0LGUsbixzPSExKXtjb25zdCBpPW4ubGVuZ3RoO2lmKCFpKXJldHVybjtsZXQgbyxyO2UueD1lLnk9MTtmb3IobGV0IGE9MDthPGk7YSsrKXtvPW5bYV0scj1vLnByb2plY3Rpb25EZWx0YTtjb25zdCBpPW8uaW5zdGFuY2U7aSYmaS5zdHlsZSYmXCJjb250ZW50c1wiPT09aS5zdHlsZS5kaXNwbGF5fHwocyYmby5vcHRpb25zLmxheW91dFNjcm9sbCYmby5zY3JvbGwmJm8hPT1vLnJvb3QmJktzKHQse3g6LW8uc2Nyb2xsLm9mZnNldC54LHk6LW8uc2Nyb2xsLm9mZnNldC55fSksciYmKGUueCo9ci54LnNjYWxlLGUueSo9ci55LnNjYWxlLHpzKHQscikpLHMmJklzKG8ubGF0ZXN0VmFsdWVzKSYmS3ModCxvLmxhdGVzdFZhbHVlcykpfWUueD1ZcyhlLngpLGUueT1ZcyhlLnkpfSh0aGlzLmxheW91dENvcnJlY3RlZCx0aGlzLnRyZWVTY2FsZSx0aGlzLnBhdGgsbiksIWUubGF5b3V0fHxlLnRhcmdldHx8MT09PXRoaXMudHJlZVNjYWxlLngmJjE9PT10aGlzLnRyZWVTY2FsZS55fHwoZS50YXJnZXQ9ZS5sYXlvdXQubGF5b3V0Qm94KTtjb25zdHt0YXJnZXQ6bH09ZTtpZighbClyZXR1cm4gdm9pZCh0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm0mJih0aGlzLnByb2plY3Rpb25EZWx0YT17eDp7dHJhbnNsYXRlOjAsc2NhbGU6MSxvcmlnaW46MCxvcmlnaW5Qb2ludDowfSx5Ont0cmFuc2xhdGU6MCxzY2FsZToxLG9yaWdpbjowLG9yaWdpblBvaW50OjB9fSx0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm09XCJub25lXCIsdGhpcy5zY2hlZHVsZVJlbmRlcigpKSk7dGhpcy5wcm9qZWN0aW9uRGVsdGF8fCh0aGlzLnByb2plY3Rpb25EZWx0YT17eDp7dHJhbnNsYXRlOjAsc2NhbGU6MSxvcmlnaW46MCxvcmlnaW5Qb2ludDowfSx5Ont0cmFuc2xhdGU6MCxzY2FsZToxLG9yaWdpbjowLG9yaWdpblBvaW50OjB9fSx0aGlzLnByb2plY3Rpb25EZWx0YVdpdGhUcmFuc2Zvcm09e3g6e3RyYW5zbGF0ZTowLHNjYWxlOjEsb3JpZ2luOjAsb3JpZ2luUG9pbnQ6MH0seTp7dHJhbnNsYXRlOjAsc2NhbGU6MSxvcmlnaW46MCxvcmlnaW5Qb2ludDowfX0pO2NvbnN0IHU9dGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtO0VzKHRoaXMucHJvamVjdGlvbkRlbHRhLHRoaXMubGF5b3V0Q29ycmVjdGVkLGwsdGhpcy5sYXRlc3RWYWx1ZXMpLHRoaXMucHJvamVjdGlvblRyYW5zZm9ybT1NaSh0aGlzLnByb2plY3Rpb25EZWx0YSx0aGlzLnRyZWVTY2FsZSksdGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtPT09dSYmdGhpcy50cmVlU2NhbGUueD09PXImJnRoaXMudHJlZVNjYWxlLnk9PT1hfHwodGhpcy5oYXNQcm9qZWN0ZWQ9ITAsdGhpcy5zY2hlZHVsZVJlbmRlcigpLHRoaXMubm90aWZ5TGlzdGVuZXJzKFwicHJvamVjdGlvblVwZGF0ZVwiLGwpKSxqaS5yZWNhbGN1bGF0ZWRQcm9qZWN0aW9uKyt9aGlkZSgpe3RoaXMuaXNWaXNpYmxlPSExfXNob3coKXt0aGlzLmlzVmlzaWJsZT0hMH1zY2hlZHVsZVJlbmRlcih0PSEwKXtpZih0aGlzLm9wdGlvbnMuc2NoZWR1bGVSZW5kZXImJnRoaXMub3B0aW9ucy5zY2hlZHVsZVJlbmRlcigpLHQpe2NvbnN0IHQ9dGhpcy5nZXRTdGFjaygpO3QmJnQuc2NoZWR1bGVSZW5kZXIoKX10aGlzLnJlc3VtaW5nRnJvbSYmIXRoaXMucmVzdW1pbmdGcm9tLmluc3RhbmNlJiYodGhpcy5yZXN1bWluZ0Zyb209dm9pZCAwKX1zZXRBbmltYXRpb25PcmlnaW4odCxlPSExKXtjb25zdCBuPXRoaXMuc25hcHNob3Qscz1uP24ubGF0ZXN0VmFsdWVzOnt9LGk9ey4uLnRoaXMubGF0ZXN0VmFsdWVzfSxvPXt4Ont0cmFuc2xhdGU6MCxzY2FsZToxLG9yaWdpbjowLG9yaWdpblBvaW50OjB9LHk6e3RyYW5zbGF0ZTowLHNjYWxlOjEsb3JpZ2luOjAsb3JpZ2luUG9pbnQ6MH19O3RoaXMucmVsYXRpdmVQYXJlbnQmJnRoaXMucmVsYXRpdmVQYXJlbnQub3B0aW9ucy5sYXlvdXRSb290fHwodGhpcy5yZWxhdGl2ZVRhcmdldD10aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luPXZvaWQgMCksdGhpcy5hdHRlbXB0VG9SZXNvbHZlUmVsYXRpdmVUYXJnZXQ9IWU7Y29uc3Qgcj17eDp7bWluOjAsbWF4OjB9LHk6e21pbjowLG1heDowfX0sYT0obj9uLnNvdXJjZTp2b2lkIDApIT09KHRoaXMubGF5b3V0P3RoaXMubGF5b3V0LnNvdXJjZTp2b2lkIDApLGw9dGhpcy5nZXRTdGFjaygpLHU9IWx8fGwubWVtYmVycy5sZW5ndGg8PTEsYz1Cb29sZWFuKGEmJiF1JiYhMD09PXRoaXMub3B0aW9ucy5jcm9zc2ZhZGUmJiF0aGlzLnBhdGguc29tZShfaSkpO2xldCBoO3RoaXMuYW5pbWF0aW9uUHJvZ3Jlc3M9MCx0aGlzLm1peFRhcmdldERlbHRhPWU9Pntjb25zdCBuPWUvMWUzO3ZhciBsLGQsbSxwLGYsZztaaShvLngsdC54LG4pLFppKG8ueSx0LnksbiksdGhpcy5zZXRUYXJnZXREZWx0YShvKSx0aGlzLnJlbGF0aXZlVGFyZ2V0JiZ0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luJiZ0aGlzLmxheW91dCYmdGhpcy5yZWxhdGl2ZVBhcmVudCYmdGhpcy5yZWxhdGl2ZVBhcmVudC5sYXlvdXQmJihDcyhyLHRoaXMubGF5b3V0LmxheW91dEJveCx0aGlzLnJlbGF0aXZlUGFyZW50LmxheW91dC5sYXlvdXRCb3gpLG09dGhpcy5yZWxhdGl2ZVRhcmdldCxwPXRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4sZj1yLGc9bixLaShtLngscC54LGYueCxnKSxLaShtLnkscC55LGYueSxnKSxoJiYobD10aGlzLnJlbGF0aXZlVGFyZ2V0LGQ9aCxsLngubWluPT09ZC54Lm1pbiYmbC54Lm1heD09PWQueC5tYXgmJmwueS5taW49PT1kLnkubWluJiZsLnkubWF4PT09ZC55Lm1heCkmJih0aGlzLmlzUHJvamVjdGlvbkRpcnR5PSExKSxofHwoaD17eDp7bWluOjAsbWF4OjB9LHk6e21pbjowLG1heDowfX0pLHZpKGgsdGhpcy5yZWxhdGl2ZVRhcmdldCkpLGEmJih0aGlzLmFuaW1hdGlvblZhbHVlcz1pLGZ1bmN0aW9uKHQsZSxuLHMsaSxvKXtpPyh0Lm9wYWNpdHk9S3QoMCx2b2lkIDAhPT1uLm9wYWNpdHk/bi5vcGFjaXR5OjEscGkocykpLHQub3BhY2l0eUV4aXQ9S3Qodm9pZCAwIT09ZS5vcGFjaXR5P2Uub3BhY2l0eToxLDAsZmkocykpKTpvJiYodC5vcGFjaXR5PUt0KHZvaWQgMCE9PWUub3BhY2l0eT9lLm9wYWNpdHk6MSx2b2lkIDAhPT1uLm9wYWNpdHk/bi5vcGFjaXR5OjEscykpO2ZvcihsZXQgaT0wO2k8Y2k7aSsrKXtjb25zdCBvPWBib3JkZXIke3VpW2ldfVJhZGl1c2A7bGV0IHI9bWkoZSxvKSxhPW1pKG4sbyk7dm9pZCAwPT09ciYmdm9pZCAwPT09YXx8KHJ8fChyPTApLGF8fChhPTApLDA9PT1yfHwwPT09YXx8ZGkocik9PT1kaShhKT8odFtvXT1NYXRoLm1heChLdChoaShyKSxoaShhKSxzKSwwKSwoSC50ZXN0KGEpfHxILnRlc3QocikpJiYodFtvXSs9XCIlXCIpKTp0W29dPWEpfShlLnJvdGF0ZXx8bi5yb3RhdGUpJiYodC5yb3RhdGU9S3QoZS5yb3RhdGV8fDAsbi5yb3RhdGV8fDAscykpfShpLHMsdGhpcy5sYXRlc3RWYWx1ZXMsbixjLHUpKSx0aGlzLnJvb3Quc2NoZWR1bGVVcGRhdGVQcm9qZWN0aW9uKCksdGhpcy5zY2hlZHVsZVJlbmRlcigpLHRoaXMuYW5pbWF0aW9uUHJvZ3Jlc3M9bn0sdGhpcy5taXhUYXJnZXREZWx0YSh0aGlzLm9wdGlvbnMubGF5b3V0Um9vdD8xZTM6MCl9c3RhcnRBbmltYXRpb24odCl7dGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJhbmltYXRpb25TdGFydFwiKSx0aGlzLmN1cnJlbnRBbmltYXRpb24mJnRoaXMuY3VycmVudEFuaW1hdGlvbi5zdG9wKCksdGhpcy5yZXN1bWluZ0Zyb20mJnRoaXMucmVzdW1pbmdGcm9tLmN1cnJlbnRBbmltYXRpb24mJnRoaXMucmVzdW1pbmdGcm9tLmN1cnJlbnRBbmltYXRpb24uc3RvcCgpLHRoaXMucGVuZGluZ0FuaW1hdGlvbiYmKHYodGhpcy5wZW5kaW5nQW5pbWF0aW9uKSx0aGlzLnBlbmRpbmdBbmltYXRpb249dm9pZCAwKSx0aGlzLnBlbmRpbmdBbmltYXRpb249eS51cGRhdGUoKCgpPT57bmkuaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZT0hMCx0aGlzLmN1cnJlbnRBbmltYXRpb249ZnVuY3Rpb24odCxlLG4pe2NvbnN0IHM9amUoMCk/MDpTKDApO3JldHVybiBzLnN0YXJ0KExlKFwiXCIscywxZTMsbikpLHMuYW5pbWF0aW9ufSgwLDAsey4uLnQsb25VcGRhdGU6ZT0+e3RoaXMubWl4VGFyZ2V0RGVsdGEoZSksdC5vblVwZGF0ZSYmdC5vblVwZGF0ZShlKX0sb25Db21wbGV0ZTooKT0+e3Qub25Db21wbGV0ZSYmdC5vbkNvbXBsZXRlKCksdGhpcy5jb21wbGV0ZUFuaW1hdGlvbigpfX0pLHRoaXMucmVzdW1pbmdGcm9tJiYodGhpcy5yZXN1bWluZ0Zyb20uY3VycmVudEFuaW1hdGlvbj10aGlzLmN1cnJlbnRBbmltYXRpb24pLHRoaXMucGVuZGluZ0FuaW1hdGlvbj12b2lkIDB9KSl9Y29tcGxldGVBbmltYXRpb24oKXt0aGlzLnJlc3VtaW5nRnJvbSYmKHRoaXMucmVzdW1pbmdGcm9tLmN1cnJlbnRBbmltYXRpb249dm9pZCAwLHRoaXMucmVzdW1pbmdGcm9tLnByZXNlcnZlT3BhY2l0eT12b2lkIDApO2NvbnN0IHQ9dGhpcy5nZXRTdGFjaygpO3QmJnQuZXhpdEFuaW1hdGlvbkNvbXBsZXRlKCksdGhpcy5yZXN1bWluZ0Zyb209dGhpcy5jdXJyZW50QW5pbWF0aW9uPXRoaXMuYW5pbWF0aW9uVmFsdWVzPXZvaWQgMCx0aGlzLm5vdGlmeUxpc3RlbmVycyhcImFuaW1hdGlvbkNvbXBsZXRlXCIpfWZpbmlzaEFuaW1hdGlvbigpe3RoaXMuY3VycmVudEFuaW1hdGlvbiYmKHRoaXMubWl4VGFyZ2V0RGVsdGEmJnRoaXMubWl4VGFyZ2V0RGVsdGEoMWUzKSx0aGlzLmN1cnJlbnRBbmltYXRpb24uc3RvcCgpKSx0aGlzLmNvbXBsZXRlQW5pbWF0aW9uKCl9YXBwbHlUcmFuc2Zvcm1zVG9UYXJnZXQoKXtjb25zdCB0PXRoaXMuZ2V0TGVhZCgpO2xldHt0YXJnZXRXaXRoVHJhbnNmb3JtczplLHRhcmdldDpuLGxheW91dDpzLGxhdGVzdFZhbHVlczppfT10O2lmKGUmJm4mJnMpe2lmKHRoaXMhPT10JiZ0aGlzLmxheW91dCYmcyYmbm8odGhpcy5vcHRpb25zLmFuaW1hdGlvblR5cGUsdGhpcy5sYXlvdXQubGF5b3V0Qm94LHMubGF5b3V0Qm94KSl7bj10aGlzLnRhcmdldHx8e3g6e21pbjowLG1heDowfSx5OnttaW46MCxtYXg6MH19O2NvbnN0IGU9VHModGhpcy5sYXlvdXQubGF5b3V0Qm94LngpO24ueC5taW49dC50YXJnZXQueC5taW4sbi54Lm1heD1uLngubWluK2U7Y29uc3Qgcz1Ucyh0aGlzLmxheW91dC5sYXlvdXRCb3gueSk7bi55Lm1pbj10LnRhcmdldC55Lm1pbixuLnkubWF4PW4ueS5taW4rc312aShlLG4pLEtzKGUsaSksRXModGhpcy5wcm9qZWN0aW9uRGVsdGFXaXRoVHJhbnNmb3JtLHRoaXMubGF5b3V0Q29ycmVjdGVkLGUsaSl9fXJlZ2lzdGVyU2hhcmVkTm9kZSh0LGUpe3RoaXMuc2hhcmVkTm9kZXMuaGFzKHQpfHx0aGlzLnNoYXJlZE5vZGVzLnNldCh0LG5ldyBDaSksdGhpcy5zaGFyZWROb2Rlcy5nZXQodCkuYWRkKGUpO2NvbnN0IG49ZS5vcHRpb25zLmluaXRpYWxQcm9tb3Rpb25Db25maWc7ZS5wcm9tb3RlKHt0cmFuc2l0aW9uOm4/bi50cmFuc2l0aW9uOnZvaWQgMCxwcmVzZXJ2ZUZvbGxvd09wYWNpdHk6biYmbi5zaG91bGRQcmVzZXJ2ZUZvbGxvd09wYWNpdHk/bi5zaG91bGRQcmVzZXJ2ZUZvbGxvd09wYWNpdHkoZSk6dm9pZCAwfSl9aXNMZWFkKCl7Y29uc3QgdD10aGlzLmdldFN0YWNrKCk7cmV0dXJuIXR8fHQubGVhZD09PXRoaXN9Z2V0TGVhZCgpe3ZhciB0O2NvbnN0e2xheW91dElkOmV9PXRoaXMub3B0aW9ucztyZXR1cm4gZSYmKG51bGw9PT0odD10aGlzLmdldFN0YWNrKCkpfHx2b2lkIDA9PT10P3ZvaWQgMDp0LmxlYWQpfHx0aGlzfWdldFByZXZMZWFkKCl7dmFyIHQ7Y29uc3R7bGF5b3V0SWQ6ZX09dGhpcy5vcHRpb25zO3JldHVybiBlP251bGw9PT0odD10aGlzLmdldFN0YWNrKCkpfHx2b2lkIDA9PT10P3ZvaWQgMDp0LnByZXZMZWFkOnZvaWQgMH1nZXRTdGFjaygpe2NvbnN0e2xheW91dElkOnR9PXRoaXMub3B0aW9ucztpZih0KXJldHVybiB0aGlzLnJvb3Quc2hhcmVkTm9kZXMuZ2V0KHQpfXByb21vdGUoe25lZWRzUmVzZXQ6dCx0cmFuc2l0aW9uOmUscHJlc2VydmVGb2xsb3dPcGFjaXR5Om59PXt9KXtjb25zdCBzPXRoaXMuZ2V0U3RhY2soKTtzJiZzLnByb21vdGUodGhpcyxuKSx0JiYodGhpcy5wcm9qZWN0aW9uRGVsdGE9dm9pZCAwLHRoaXMubmVlZHNSZXNldD0hMCksZSYmdGhpcy5zZXRPcHRpb25zKHt0cmFuc2l0aW9uOmV9KX1yZWxlZ2F0ZSgpe2NvbnN0IHQ9dGhpcy5nZXRTdGFjaygpO3JldHVybiEhdCYmdC5yZWxlZ2F0ZSh0aGlzKX1yZXNldFJvdGF0aW9uKCl7Y29uc3R7dmlzdWFsRWxlbWVudDp0fT10aGlzLm9wdGlvbnM7aWYoIXQpcmV0dXJuO2xldCBlPSExO2NvbnN0e2xhdGVzdFZhbHVlczpufT10O2lmKChuLnJvdGF0ZXx8bi5yb3RhdGVYfHxuLnJvdGF0ZVl8fG4ucm90YXRlWikmJihlPSEwKSwhZSlyZXR1cm47Y29uc3Qgcz17fTtmb3IobGV0IGU9MDtlPFJpLmxlbmd0aDtlKyspe2NvbnN0IGk9XCJyb3RhdGVcIitSaVtlXTtuW2ldJiYoc1tpXT1uW2ldLHQuc2V0U3RhdGljVmFsdWUoaSwwKSl9dC5yZW5kZXIoKTtmb3IoY29uc3QgZSBpbiBzKXQuc2V0U3RhdGljVmFsdWUoZSxzW2VdKTt0LnNjaGVkdWxlUmVuZGVyKCl9Z2V0UHJvamVjdGlvblN0eWxlcyh0PXt9KXt2YXIgZSxuO2NvbnN0IHM9e307aWYoIXRoaXMuaW5zdGFuY2V8fHRoaXMuaXNTVkcpcmV0dXJuIHM7aWYoIXRoaXMuaXNWaXNpYmxlKXJldHVybnt2aXNpYmlsaXR5OlwiaGlkZGVuXCJ9O3MudmlzaWJpbGl0eT1cIlwiO2NvbnN0IGk9dGhpcy5nZXRUcmFuc2Zvcm1UZW1wbGF0ZSgpO2lmKHRoaXMubmVlZHNSZXNldClyZXR1cm4gdGhpcy5uZWVkc1Jlc2V0PSExLHMub3BhY2l0eT1cIlwiLHMucG9pbnRlckV2ZW50cz1Jbih0LnBvaW50ZXJFdmVudHMpfHxcIlwiLHMudHJhbnNmb3JtPWk/aSh0aGlzLmxhdGVzdFZhbHVlcyxcIlwiKTpcIm5vbmVcIixzO2NvbnN0IG89dGhpcy5nZXRMZWFkKCk7aWYoIXRoaXMucHJvamVjdGlvbkRlbHRhfHwhdGhpcy5sYXlvdXR8fCFvLnRhcmdldCl7Y29uc3QgZT17fTtyZXR1cm4gdGhpcy5vcHRpb25zLmxheW91dElkJiYoZS5vcGFjaXR5PXZvaWQgMCE9PXRoaXMubGF0ZXN0VmFsdWVzLm9wYWNpdHk/dGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eToxLGUucG9pbnRlckV2ZW50cz1Jbih0LnBvaW50ZXJFdmVudHMpfHxcIlwiKSx0aGlzLmhhc1Byb2plY3RlZCYmIUlzKHRoaXMubGF0ZXN0VmFsdWVzKSYmKGUudHJhbnNmb3JtPWk/aSh7fSxcIlwiKTpcIm5vbmVcIix0aGlzLmhhc1Byb2plY3RlZD0hMSksZX1jb25zdCByPW8uYW5pbWF0aW9uVmFsdWVzfHxvLmxhdGVzdFZhbHVlczt0aGlzLmFwcGx5VHJhbnNmb3Jtc1RvVGFyZ2V0KCkscy50cmFuc2Zvcm09TWkodGhpcy5wcm9qZWN0aW9uRGVsdGFXaXRoVHJhbnNmb3JtLHRoaXMudHJlZVNjYWxlLHIpLGkmJihzLnRyYW5zZm9ybT1pKHIscy50cmFuc2Zvcm0pKTtjb25zdHt4OmEseTpsfT10aGlzLnByb2plY3Rpb25EZWx0YTtzLnRyYW5zZm9ybU9yaWdpbj1gJHsxMDAqYS5vcmlnaW59JSAkezEwMCpsLm9yaWdpbn0lIDBgLG8uYW5pbWF0aW9uVmFsdWVzP3Mub3BhY2l0eT1vPT09dGhpcz9udWxsIT09KG49bnVsbCE9PShlPXIub3BhY2l0eSkmJnZvaWQgMCE9PWU/ZTp0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5KSYmdm9pZCAwIT09bj9uOjE6dGhpcy5wcmVzZXJ2ZU9wYWNpdHk/dGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eTpyLm9wYWNpdHlFeGl0OnMub3BhY2l0eT1vPT09dGhpcz92b2lkIDAhPT1yLm9wYWNpdHk/ci5vcGFjaXR5OlwiXCI6dm9pZCAwIT09ci5vcGFjaXR5RXhpdD9yLm9wYWNpdHlFeGl0OjA7Zm9yKGNvbnN0IHQgaW4gcG4pe2lmKHZvaWQgMD09PXJbdF0pY29udGludWU7Y29uc3R7Y29ycmVjdDplLGFwcGx5VG86bn09cG5bdF0saT1cIm5vbmVcIj09PXMudHJhbnNmb3JtP3JbdF06ZShyW3RdLG8pO2lmKG4pe2NvbnN0IHQ9bi5sZW5ndGg7Zm9yKGxldCBlPTA7ZTx0O2UrKylzW25bZV1dPWl9ZWxzZSBzW3RdPWl9cmV0dXJuIHRoaXMub3B0aW9ucy5sYXlvdXRJZCYmKHMucG9pbnRlckV2ZW50cz1vPT09dGhpcz9Jbih0LnBvaW50ZXJFdmVudHMpfHxcIlwiOlwibm9uZVwiKSxzfWNsZWFyU25hcHNob3QoKXt0aGlzLnJlc3VtZUZyb209dGhpcy5zbmFwc2hvdD12b2lkIDB9cmVzZXRUcmVlKCl7dGhpcy5yb290Lm5vZGVzLmZvckVhY2goKHQ9Pnt2YXIgZTtyZXR1cm4gbnVsbD09PShlPXQuY3VycmVudEFuaW1hdGlvbil8fHZvaWQgMD09PWU/dm9pZCAwOmUuc3RvcCgpfSkpLHRoaXMucm9vdC5ub2Rlcy5mb3JFYWNoKCRpKSx0aGlzLnJvb3Quc2hhcmVkTm9kZXMuY2xlYXIoKX19fWZ1bmN0aW9uIEZpKHQpe3QudXBkYXRlTGF5b3V0KCl9ZnVuY3Rpb24gT2kodCl7dmFyIGU7Y29uc3Qgbj0obnVsbD09PShlPXQucmVzdW1lRnJvbSl8fHZvaWQgMD09PWU/dm9pZCAwOmUuc25hcHNob3QpfHx0LnNuYXBzaG90O2lmKHQuaXNMZWFkKCkmJnQubGF5b3V0JiZuJiZ0Lmhhc0xpc3RlbmVycyhcImRpZFVwZGF0ZVwiKSl7Y29uc3R7bGF5b3V0Qm94OmUsbWVhc3VyZWRCb3g6c309dC5sYXlvdXQse2FuaW1hdGlvblR5cGU6aX09dC5vcHRpb25zLG89bi5zb3VyY2UhPT10LmxheW91dC5zb3VyY2U7XCJzaXplXCI9PT1pP2pzKCh0PT57Y29uc3Qgcz1vP24ubWVhc3VyZWRCb3hbdF06bi5sYXlvdXRCb3hbdF0saT1UcyhzKTtzLm1pbj1lW3RdLm1pbixzLm1heD1zLm1pbitpfSkpOm5vKGksbi5sYXlvdXRCb3gsZSkmJmpzKChzPT57Y29uc3QgaT1vP24ubWVhc3VyZWRCb3hbc106bi5sYXlvdXRCb3hbc10scj1UcyhlW3NdKTtpLm1heD1pLm1pbityLHQucmVsYXRpdmVUYXJnZXQmJiF0LmN1cnJlbnRBbmltYXRpb24mJih0LmlzUHJvamVjdGlvbkRpcnR5PSEwLHQucmVsYXRpdmVUYXJnZXRbc10ubWF4PXQucmVsYXRpdmVUYXJnZXRbc10ubWluK3IpfSkpO2NvbnN0IHI9e3g6e3RyYW5zbGF0ZTowLHNjYWxlOjEsb3JpZ2luOjAsb3JpZ2luUG9pbnQ6MH0seTp7dHJhbnNsYXRlOjAsc2NhbGU6MSxvcmlnaW46MCxvcmlnaW5Qb2ludDowfX07RXMocixlLG4ubGF5b3V0Qm94KTtjb25zdCBhPXt4Ont0cmFuc2xhdGU6MCxzY2FsZToxLG9yaWdpbjowLG9yaWdpblBvaW50OjB9LHk6e3RyYW5zbGF0ZTowLHNjYWxlOjEsb3JpZ2luOjAsb3JpZ2luUG9pbnQ6MH19O28/RXMoYSx0LmFwcGx5VHJhbnNmb3JtKHMsITApLG4ubWVhc3VyZWRCb3gpOkVzKGEsZSxuLmxheW91dEJveCk7Y29uc3QgbD0hRWkocik7bGV0IHU9ITE7aWYoIXQucmVzdW1lRnJvbSl7Y29uc3Qgcz10LmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCk7aWYocyYmIXMucmVzdW1lRnJvbSl7Y29uc3R7c25hcHNob3Q6aSxsYXlvdXQ6b309cztpZihpJiZvKXtjb25zdCByPXt4OnttaW46MCxtYXg6MH0seTp7bWluOjAsbWF4OjB9fTtDcyhyLG4ubGF5b3V0Qm94LGkubGF5b3V0Qm94KTtjb25zdCBhPXt4OnttaW46MCxtYXg6MH0seTp7bWluOjAsbWF4OjB9fTtDcyhhLGUsby5sYXlvdXRCb3gpLEFpKHIsYSl8fCh1PSEwKSxzLm9wdGlvbnMubGF5b3V0Um9vdCYmKHQucmVsYXRpdmVUYXJnZXQ9YSx0LnJlbGF0aXZlVGFyZ2V0T3JpZ2luPXIsdC5yZWxhdGl2ZVBhcmVudD1zKX19fXQubm90aWZ5TGlzdGVuZXJzKFwiZGlkVXBkYXRlXCIse2xheW91dDplLHNuYXBzaG90Om4sZGVsdGE6YSxsYXlvdXREZWx0YTpyLGhhc0xheW91dENoYW5nZWQ6bCxoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQ6dX0pfWVsc2UgaWYodC5pc0xlYWQoKSl7Y29uc3R7b25FeGl0Q29tcGxldGU6ZX09dC5vcHRpb25zO2UmJmUoKX10Lm9wdGlvbnMudHJhbnNpdGlvbj12b2lkIDB9ZnVuY3Rpb24gSWkodCl7amkudG90YWxOb2RlcysrLHQucGFyZW50JiYodC5pc1Byb2plY3RpbmcoKXx8KHQuaXNQcm9qZWN0aW9uRGlydHk9dC5wYXJlbnQuaXNQcm9qZWN0aW9uRGlydHkpLHQuaXNTaGFyZWRQcm9qZWN0aW9uRGlydHl8fCh0LmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5PUJvb2xlYW4odC5pc1Byb2plY3Rpb25EaXJ0eXx8dC5wYXJlbnQuaXNQcm9qZWN0aW9uRGlydHl8fHQucGFyZW50LmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5KSksdC5pc1RyYW5zZm9ybURpcnR5fHwodC5pc1RyYW5zZm9ybURpcnR5PXQucGFyZW50LmlzVHJhbnNmb3JtRGlydHkpKX1mdW5jdGlvbiBVaSh0KXt0LmlzUHJvamVjdGlvbkRpcnR5PXQuaXNTaGFyZWRQcm9qZWN0aW9uRGlydHk9dC5pc1RyYW5zZm9ybURpcnR5PSExfWZ1bmN0aW9uIE5pKHQpe3QuY2xlYXJTbmFwc2hvdCgpfWZ1bmN0aW9uICRpKHQpe3QuY2xlYXJNZWFzdXJlbWVudHMoKX1mdW5jdGlvbiBXaSh0KXt0LmlzTGF5b3V0RGlydHk9ITF9ZnVuY3Rpb24gSGkodCl7Y29uc3R7dmlzdWFsRWxlbWVudDplfT10Lm9wdGlvbnM7ZSYmZS5nZXRQcm9wcygpLm9uQmVmb3JlTGF5b3V0TWVhc3VyZSYmZS5ub3RpZnkoXCJCZWZvcmVMYXlvdXRNZWFzdXJlXCIpLHQucmVzZXRUcmFuc2Zvcm0oKX1mdW5jdGlvbiB6aSh0KXt0LmZpbmlzaEFuaW1hdGlvbigpLHQudGFyZ2V0RGVsdGE9dC5yZWxhdGl2ZVRhcmdldD10LnRhcmdldD12b2lkIDAsdC5pc1Byb2plY3Rpb25EaXJ0eT0hMH1mdW5jdGlvbiBZaSh0KXt0LnJlc29sdmVUYXJnZXREZWx0YSgpfWZ1bmN0aW9uIFhpKHQpe3QuY2FsY1Byb2plY3Rpb24oKX1mdW5jdGlvbiBHaSh0KXt0LnJlc2V0Um90YXRpb24oKX1mdW5jdGlvbiBxaSh0KXt0LnJlbW92ZUxlYWRTbmFwc2hvdCgpfWZ1bmN0aW9uIFppKHQsZSxuKXt0LnRyYW5zbGF0ZT1LdChlLnRyYW5zbGF0ZSwwLG4pLHQuc2NhbGU9S3QoZS5zY2FsZSwxLG4pLHQub3JpZ2luPWUub3JpZ2luLHQub3JpZ2luUG9pbnQ9ZS5vcmlnaW5Qb2ludH1mdW5jdGlvbiBLaSh0LGUsbixzKXt0Lm1pbj1LdChlLm1pbixuLm1pbixzKSx0Lm1heD1LdChlLm1heCxuLm1heCxzKX1mdW5jdGlvbiBfaSh0KXtyZXR1cm4gdC5hbmltYXRpb25WYWx1ZXMmJnZvaWQgMCE9PXQuYW5pbWF0aW9uVmFsdWVzLm9wYWNpdHlFeGl0fWNvbnN0IEppPXtkdXJhdGlvbjouNDUsZWFzZTpbLjQsMCwuMSwxXX0sUWk9dD0+XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHQpLHRvPVFpKFwiYXBwbGV3ZWJraXQvXCIpJiYhUWkoXCJjaHJvbWUvXCIpP01hdGgucm91bmQ6bjtmdW5jdGlvbiBlbyh0KXt0Lm1pbj10byh0Lm1pbiksdC5tYXg9dG8odC5tYXgpfWZ1bmN0aW9uIG5vKHQsZSxuKXtyZXR1cm5cInBvc2l0aW9uXCI9PT10fHxcInByZXNlcnZlLWFzcGVjdFwiPT09dCYmIVNzKFZpKGUpLFZpKG4pLC4yKX1jb25zdCBzbz1CaSh7YXR0YWNoUmVzaXplTGlzdGVuZXI6KHQsZSk9PkhuKHQsXCJyZXNpemVcIixlKSxtZWFzdXJlU2Nyb2xsOigpPT4oe3g6ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnR8fGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCx5OmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3B8fGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wfSksY2hlY2tJc1Njcm9sbFJvb3Q6KCk9PiEwfSksaW89e2N1cnJlbnQ6dm9pZCAwfSxvbz1CaSh7bWVhc3VyZVNjcm9sbDp0PT4oe3g6dC5zY3JvbGxMZWZ0LHk6dC5zY3JvbGxUb3B9KSxkZWZhdWx0UGFyZW50OigpPT57aWYoIWlvLmN1cnJlbnQpe2NvbnN0IHQ9bmV3IHNvKHt9KTt0Lm1vdW50KHdpbmRvdyksdC5zZXRPcHRpb25zKHtsYXlvdXRTY3JvbGw6ITB9KSxpby5jdXJyZW50PXR9cmV0dXJuIGlvLmN1cnJlbnR9LHJlc2V0VHJhbnNmb3JtOih0LGUpPT57dC5zdHlsZS50cmFuc2Zvcm09dm9pZCAwIT09ZT9lOlwibm9uZVwifSxjaGVja0lzU2Nyb2xsUm9vdDp0PT5Cb29sZWFuKFwiZml4ZWRcIj09PXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQpLnBvc2l0aW9uKX0pLHJvPXtwYW46e0ZlYXR1cmU6Y2xhc3MgZXh0ZW5kcyBKbntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5yZW1vdmVQb2ludGVyRG93bkxpc3RlbmVyPW59b25Qb2ludGVyRG93bih0KXt0aGlzLnNlc3Npb249bmV3IGZzKHQsdGhpcy5jcmVhdGVQYW5IYW5kbGVycygpLHt0cmFuc2Zvcm1QYWdlUG9pbnQ6dGhpcy5ub2RlLmdldFRyYW5zZm9ybVBhZ2VQb2ludCgpfSl9Y3JlYXRlUGFuSGFuZGxlcnMoKXtjb25zdHtvblBhblNlc3Npb25TdGFydDp0LG9uUGFuU3RhcnQ6ZSxvblBhbjpuLG9uUGFuRW5kOnN9PXRoaXMubm9kZS5nZXRQcm9wcygpO3JldHVybntvblNlc3Npb25TdGFydDplaSh0KSxvblN0YXJ0OmVpKGUpLG9uTW92ZTpuLG9uRW5kOih0LGUpPT57ZGVsZXRlIHRoaXMuc2Vzc2lvbixzJiZ5LnVwZGF0ZSgoKCk9PnModCxlKSkpfX19bW91bnQoKXt0aGlzLnJlbW92ZVBvaW50ZXJEb3duTGlzdGVuZXI9WG4odGhpcy5ub2RlLmN1cnJlbnQsXCJwb2ludGVyZG93blwiLCh0PT50aGlzLm9uUG9pbnRlckRvd24odCkpKX11cGRhdGUoKXt0aGlzLnNlc3Npb24mJnRoaXMuc2Vzc2lvbi51cGRhdGVIYW5kbGVycyh0aGlzLmNyZWF0ZVBhbkhhbmRsZXJzKCkpfXVubW91bnQoKXt0aGlzLnJlbW92ZVBvaW50ZXJEb3duTGlzdGVuZXIoKSx0aGlzLnNlc3Npb24mJnRoaXMuc2Vzc2lvbi5lbmQoKX19fSxkcmFnOntGZWF0dXJlOmNsYXNzIGV4dGVuZHMgSm57Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy5yZW1vdmVHcm91cENvbnRyb2xzPW4sdGhpcy5yZW1vdmVMaXN0ZW5lcnM9bix0aGlzLmNvbnRyb2xzPW5ldyBRcyh0KX1tb3VudCgpe2NvbnN0e2RyYWdDb250cm9sczp0fT10aGlzLm5vZGUuZ2V0UHJvcHMoKTt0JiYodGhpcy5yZW1vdmVHcm91cENvbnRyb2xzPXQuc3Vic2NyaWJlKHRoaXMuY29udHJvbHMpKSx0aGlzLnJlbW92ZUxpc3RlbmVycz10aGlzLmNvbnRyb2xzLmFkZExpc3RlbmVycygpfHxufXVubW91bnQoKXt0aGlzLnJlbW92ZUdyb3VwQ29udHJvbHMoKSx0aGlzLnJlbW92ZUxpc3RlbmVycygpfX0sUHJvamVjdGlvbk5vZGU6b28sTWVhc3VyZUxheW91dDphaX19LGFvPS92YXJcXCgoLS1bYS16QS1aMC05LV9dKyksPyA/KFthLXpBLVowLTkgKCklIy4sLV0rKT9cXCkvO2Z1bmN0aW9uIGxvKHQsZSxuPTEpe3Iobjw9NCxgTWF4IENTUyB2YXJpYWJsZSBmYWxsYmFjayBkZXB0aCBkZXRlY3RlZCBpbiBwcm9wZXJ0eSBcIiR7dH1cIi4gVGhpcyBtYXkgaW5kaWNhdGUgYSBjaXJjdWxhciBmYWxsYmFjayBkZXBlbmRlbmN5LmApO2NvbnN0W3MsaV09ZnVuY3Rpb24odCl7Y29uc3QgZT1hby5leGVjKHQpO2lmKCFlKXJldHVyblssXTtjb25zdFssbixzXT1lO3JldHVybltuLHNdfSh0KTtpZighcylyZXR1cm47Y29uc3Qgbz13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlKS5nZXRQcm9wZXJ0eVZhbHVlKHMpO2lmKG8pe2NvbnN0IHQ9by50cmltKCk7cmV0dXJuIGwodCk/cGFyc2VGbG9hdCh0KTp0fXJldHVybiBBKGkpP2xvKGksZSxuKzEpOml9Y29uc3QgdW89bmV3IFNldChbXCJ3aWR0aFwiLFwiaGVpZ2h0XCIsXCJ0b3BcIixcImxlZnRcIixcInJpZ2h0XCIsXCJib3R0b21cIixcInhcIixcInlcIixcInRyYW5zbGF0ZVhcIixcInRyYW5zbGF0ZVlcIl0pLGNvPXQ9PnVvLmhhcyh0KSxobz10PT50PT09THx8dD09PXosbW89KHQsZSk9PnBhcnNlRmxvYXQodC5zcGxpdChcIiwgXCIpW2VdKSxwbz0odCxlKT0+KG4se3RyYW5zZm9ybTpzfSk9PntpZihcIm5vbmVcIj09PXN8fCFzKXJldHVybiAwO2NvbnN0IGk9cy5tYXRjaCgvXm1hdHJpeDNkXFwoKC4rKVxcKSQvKTtpZihpKXJldHVybiBtbyhpWzFdLGUpO3tjb25zdCBlPXMubWF0Y2goL15tYXRyaXhcXCgoLispXFwpJC8pO3JldHVybiBlP21vKGVbMV0sdCk6MH19LGZvPW5ldyBTZXQoW1wieFwiLFwieVwiLFwielwiXSksZ289d3QuZmlsdGVyKCh0PT4hZm8uaGFzKHQpKSkseW89e3dpZHRoOih7eDp0fSx7cGFkZGluZ0xlZnQ6ZT1cIjBcIixwYWRkaW5nUmlnaHQ6bj1cIjBcIn0pPT50Lm1heC10Lm1pbi1wYXJzZUZsb2F0KGUpLXBhcnNlRmxvYXQobiksaGVpZ2h0Oih7eTp0fSx7cGFkZGluZ1RvcDplPVwiMFwiLHBhZGRpbmdCb3R0b206bj1cIjBcIn0pPT50Lm1heC10Lm1pbi1wYXJzZUZsb2F0KGUpLXBhcnNlRmxvYXQobiksdG9wOih0LHt0b3A6ZX0pPT5wYXJzZUZsb2F0KGUpLGxlZnQ6KHQse2xlZnQ6ZX0pPT5wYXJzZUZsb2F0KGUpLGJvdHRvbTooe3k6dH0se3RvcDplfSk9PnBhcnNlRmxvYXQoZSkrKHQubWF4LXQubWluKSxyaWdodDooe3g6dH0se2xlZnQ6ZX0pPT5wYXJzZUZsb2F0KGUpKyh0Lm1heC10Lm1pbikseDpwbyg0LDEzKSx5OnBvKDUsMTQpfTt5by50cmFuc2xhdGVYPXlvLngseW8udHJhbnNsYXRlWT15by55O2Z1bmN0aW9uIHZvKHQsZSxuLHMpe3JldHVybih0PT5PYmplY3Qua2V5cyh0KS5zb21lKGNvKSkoZSk/KCh0LGUsbj17fSxzPXt9KT0+e2U9ey4uLmV9LHM9ey4uLnN9O2NvbnN0IGk9T2JqZWN0LmtleXMoZSkuZmlsdGVyKGNvKTtsZXQgbz1bXSxhPSExO2NvbnN0IGw9W107aWYoaS5mb3JFYWNoKChpPT57Y29uc3QgdT10LmdldFZhbHVlKGkpO2lmKCF0Lmhhc1ZhbHVlKGkpKXJldHVybjtsZXQgaD1uW2ldLGQ9Z3QoaCk7Y29uc3QgbT1lW2ldO2xldCBwO2lmKGMobSkpe2NvbnN0IHQ9bS5sZW5ndGgsZT1udWxsPT09bVswXT8xOjA7aD1tW2VdLGQ9Z3QoaCk7Zm9yKGxldCBuPWU7bjx0JiZudWxsIT09bVtuXTtuKyspcD9yKGd0KG1bbl0pPT09cCxcIkFsbCBrZXlmcmFtZXMgbXVzdCBiZSBvZiB0aGUgc2FtZSB0eXBlXCIpOihwPWd0KG1bbl0pLHIocD09PWR8fGhvKGQpJiZobyhwKSxcIktleWZyYW1lcyBtdXN0IGJlIG9mIHRoZSBzYW1lIGRpbWVuc2lvbiBhcyB0aGUgY3VycmVudCB2YWx1ZVwiKSl9ZWxzZSBwPWd0KG0pO2lmKGQhPT1wKWlmKGhvKGQpJiZobyhwKSl7Y29uc3QgdD11LmdldCgpO1wic3RyaW5nXCI9PXR5cGVvZiB0JiZ1LnNldChwYXJzZUZsb2F0KHQpKSxcInN0cmluZ1wiPT10eXBlb2YgbT9lW2ldPXBhcnNlRmxvYXQobSk6QXJyYXkuaXNBcnJheShtKSYmcD09PXomJihlW2ldPW0ubWFwKHBhcnNlRmxvYXQpKX1lbHNlKG51bGw9PWQ/dm9pZCAwOmQudHJhbnNmb3JtKSYmKG51bGw9PXA/dm9pZCAwOnAudHJhbnNmb3JtKSYmKDA9PT1ofHwwPT09bSk/MD09PWg/dS5zZXQocC50cmFuc2Zvcm0oaCkpOmVbaV09ZC50cmFuc2Zvcm0obSk6KGF8fChvPWZ1bmN0aW9uKHQpe2NvbnN0IGU9W107cmV0dXJuIGdvLmZvckVhY2goKG49Pntjb25zdCBzPXQuZ2V0VmFsdWUobik7dm9pZCAwIT09cyYmKGUucHVzaChbbixzLmdldCgpXSkscy5zZXQobi5zdGFydHNXaXRoKFwic2NhbGVcIik/MTowKSl9KSksZS5sZW5ndGgmJnQucmVuZGVyKCksZX0odCksYT0hMCksbC5wdXNoKGkpLHNbaV09dm9pZCAwIT09c1tpXT9zW2ldOmVbaV0sdS5qdW1wKG0pKX0pKSxsLmxlbmd0aCl7Y29uc3Qgbj1sLmluZGV4T2YoXCJoZWlnaHRcIik+PTA/d2luZG93LnBhZ2VZT2Zmc2V0Om51bGwsaT0oKHQsZSxuKT0+e2NvbnN0IHM9ZS5tZWFzdXJlVmlld3BvcnRCb3goKSxpPWUuY3VycmVudCxvPWdldENvbXB1dGVkU3R5bGUoaSkse2Rpc3BsYXk6cn09byxhPXt9O1wibm9uZVwiPT09ciYmZS5zZXRTdGF0aWNWYWx1ZShcImRpc3BsYXlcIix0LmRpc3BsYXl8fFwiYmxvY2tcIiksbi5mb3JFYWNoKCh0PT57YVt0XT15b1t0XShzLG8pfSkpLGUucmVuZGVyKCk7Y29uc3QgbD1lLm1lYXN1cmVWaWV3cG9ydEJveCgpO3JldHVybiBuLmZvckVhY2goKG49Pntjb25zdCBzPWUuZ2V0VmFsdWUobik7cyYmcy5qdW1wKGFbbl0pLHRbbl09eW9bbl0obCxvKX0pKSx0fSkoZSx0LGwpO3JldHVybiBvLmxlbmd0aCYmby5mb3JFYWNoKCgoW2Usbl0pPT57dC5nZXRWYWx1ZShlKS5zZXQobil9KSksdC5yZW5kZXIoKSxIZSYmbnVsbCE9PW4mJndpbmRvdy5zY3JvbGxUbyh7dG9wOm59KSx7dGFyZ2V0OmksdHJhbnNpdGlvbkVuZDpzfX1yZXR1cm57dGFyZ2V0OmUsdHJhbnNpdGlvbkVuZDpzfX0pKHQsZSxuLHMpOnt0YXJnZXQ6ZSx0cmFuc2l0aW9uRW5kOnN9fWNvbnN0IHhvPXtjdXJyZW50Om51bGx9LFBvPXtjdXJyZW50OiExfSxibz1uZXcgV2Vha01hcCxUbz1PYmplY3Qua2V5cyhvbiksU289VG8ubGVuZ3RoLHdvPVtcIkFuaW1hdGlvblN0YXJ0XCIsXCJBbmltYXRpb25Db21wbGV0ZVwiLFwiVXBkYXRlXCIsXCJCZWZvcmVMYXlvdXRNZWFzdXJlXCIsXCJMYXlvdXRNZWFzdXJlXCIsXCJMYXlvdXRBbmltYXRpb25TdGFydFwiLFwiTGF5b3V0QW5pbWF0aW9uQ29tcGxldGVcIl0sRW89UWUubGVuZ3RoO2NsYXNzIEFvIGV4dGVuZHMgY2xhc3N7Y29uc3RydWN0b3Ioe3BhcmVudDp0LHByb3BzOmUscHJlc2VuY2VDb250ZXh0Om4scmVkdWNlZE1vdGlvbkNvbmZpZzpzLHZpc3VhbFN0YXRlOml9LG89e30pe3RoaXMuY3VycmVudD1udWxsLHRoaXMuY2hpbGRyZW49bmV3IFNldCx0aGlzLmlzVmFyaWFudE5vZGU9ITEsdGhpcy5pc0NvbnRyb2xsaW5nVmFyaWFudHM9ITEsdGhpcy5zaG91bGRSZWR1Y2VNb3Rpb249bnVsbCx0aGlzLnZhbHVlcz1uZXcgTWFwLHRoaXMuZmVhdHVyZXM9e30sdGhpcy52YWx1ZVN1YnNjcmlwdGlvbnM9bmV3IE1hcCx0aGlzLnByZXZNb3Rpb25WYWx1ZXM9e30sdGhpcy5ldmVudHM9e30sdGhpcy5wcm9wRXZlbnRTdWJzY3JpcHRpb25zPXt9LHRoaXMubm90aWZ5VXBkYXRlPSgpPT50aGlzLm5vdGlmeShcIlVwZGF0ZVwiLHRoaXMubGF0ZXN0VmFsdWVzKSx0aGlzLnJlbmRlcj0oKT0+e3RoaXMuY3VycmVudCYmKHRoaXMudHJpZ2dlckJ1aWxkKCksdGhpcy5yZW5kZXJJbnN0YW5jZSh0aGlzLmN1cnJlbnQsdGhpcy5yZW5kZXJTdGF0ZSx0aGlzLnByb3BzLnN0eWxlLHRoaXMucHJvamVjdGlvbikpfSx0aGlzLnNjaGVkdWxlUmVuZGVyPSgpPT55LnJlbmRlcih0aGlzLnJlbmRlciwhMSwhMCk7Y29uc3R7bGF0ZXN0VmFsdWVzOnIscmVuZGVyU3RhdGU6YX09aTt0aGlzLmxhdGVzdFZhbHVlcz1yLHRoaXMuYmFzZVRhcmdldD17Li4ucn0sdGhpcy5pbml0aWFsVmFsdWVzPWUuaW5pdGlhbD97Li4ucn06e30sdGhpcy5yZW5kZXJTdGF0ZT1hLHRoaXMucGFyZW50PXQsdGhpcy5wcm9wcz1lLHRoaXMucHJlc2VuY2VDb250ZXh0PW4sdGhpcy5kZXB0aD10P3QuZGVwdGgrMTowLHRoaXMucmVkdWNlZE1vdGlvbkNvbmZpZz1zLHRoaXMub3B0aW9ucz1vLHRoaXMuaXNDb250cm9sbGluZ1ZhcmlhbnRzPXRuKGUpLHRoaXMuaXNWYXJpYW50Tm9kZT1lbihlKSx0aGlzLmlzVmFyaWFudE5vZGUmJih0aGlzLnZhcmlhbnRDaGlsZHJlbj1uZXcgU2V0KSx0aGlzLm1hbnVhbGx5QW5pbWF0ZU9uTW91bnQ9Qm9vbGVhbih0JiZ0LmN1cnJlbnQpO2NvbnN0e3dpbGxDaGFuZ2U6bCwuLi51fT10aGlzLnNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhlLHt9KTtmb3IoY29uc3QgdCBpbiB1KXtjb25zdCBlPXVbdF07dm9pZCAwIT09clt0XSYmamUoZSkmJihlLnNldChyW3RdLCExKSxCZShsKSYmbC5hZGQodCkpfX1zY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHModCxlKXtyZXR1cm57fX1tb3VudCh0KXt0aGlzLmN1cnJlbnQ9dCxiby5zZXQodCx0aGlzKSx0aGlzLnByb2plY3Rpb24mJiF0aGlzLnByb2plY3Rpb24uaW5zdGFuY2UmJnRoaXMucHJvamVjdGlvbi5tb3VudCh0KSx0aGlzLnBhcmVudCYmdGhpcy5pc1ZhcmlhbnROb2RlJiYhdGhpcy5pc0NvbnRyb2xsaW5nVmFyaWFudHMmJih0aGlzLnJlbW92ZUZyb21WYXJpYW50VHJlZT10aGlzLnBhcmVudC5hZGRWYXJpYW50Q2hpbGQodGhpcykpLHRoaXMudmFsdWVzLmZvckVhY2goKCh0LGUpPT50aGlzLmJpbmRUb01vdGlvblZhbHVlKGUsdCkpKSxQby5jdXJyZW50fHxmdW5jdGlvbigpe2lmKFBvLmN1cnJlbnQ9ITAsSGUpaWYod2luZG93Lm1hdGNoTWVkaWEpe2NvbnN0IHQ9d2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbilcIiksZT0oKT0+eG8uY3VycmVudD10Lm1hdGNoZXM7dC5hZGRMaXN0ZW5lcihlKSxlKCl9ZWxzZSB4by5jdXJyZW50PSExfSgpLHRoaXMuc2hvdWxkUmVkdWNlTW90aW9uPVwibmV2ZXJcIiE9PXRoaXMucmVkdWNlZE1vdGlvbkNvbmZpZyYmKFwiYWx3YXlzXCI9PT10aGlzLnJlZHVjZWRNb3Rpb25Db25maWd8fHhvLmN1cnJlbnQpLHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5jaGlsZHJlbi5hZGQodGhpcyksdGhpcy51cGRhdGUodGhpcy5wcm9wcyx0aGlzLnByZXNlbmNlQ29udGV4dCl9dW5tb3VudCgpe2JvLmRlbGV0ZSh0aGlzLmN1cnJlbnQpLHRoaXMucHJvamVjdGlvbiYmdGhpcy5wcm9qZWN0aW9uLnVubW91bnQoKSx2KHRoaXMubm90aWZ5VXBkYXRlKSx2KHRoaXMucmVuZGVyKSx0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucy5mb3JFYWNoKCh0PT50KCkpKSx0aGlzLnJlbW92ZUZyb21WYXJpYW50VHJlZSYmdGhpcy5yZW1vdmVGcm9tVmFyaWFudFRyZWUoKSx0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuY2hpbGRyZW4uZGVsZXRlKHRoaXMpO2Zvcihjb25zdCB0IGluIHRoaXMuZXZlbnRzKXRoaXMuZXZlbnRzW3RdLmNsZWFyKCk7Zm9yKGNvbnN0IHQgaW4gdGhpcy5mZWF0dXJlcyl0aGlzLmZlYXR1cmVzW3RdLnVubW91bnQoKTt0aGlzLmN1cnJlbnQ9bnVsbH1iaW5kVG9Nb3Rpb25WYWx1ZSh0LGUpe2NvbnN0IG49RXQuaGFzKHQpLHM9ZS5vbihcImNoYW5nZVwiLChlPT57dGhpcy5sYXRlc3RWYWx1ZXNbdF09ZSx0aGlzLnByb3BzLm9uVXBkYXRlJiZ5LnVwZGF0ZSh0aGlzLm5vdGlmeVVwZGF0ZSwhMSwhMCksbiYmdGhpcy5wcm9qZWN0aW9uJiYodGhpcy5wcm9qZWN0aW9uLmlzVHJhbnNmb3JtRGlydHk9ITApfSkpLGk9ZS5vbihcInJlbmRlclJlcXVlc3RcIix0aGlzLnNjaGVkdWxlUmVuZGVyKTt0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucy5zZXQodCwoKCk9PntzKCksaSgpfSkpfXNvcnROb2RlUG9zaXRpb24odCl7cmV0dXJuIHRoaXMuY3VycmVudCYmdGhpcy5zb3J0SW5zdGFuY2VOb2RlUG9zaXRpb24mJnRoaXMudHlwZT09PXQudHlwZT90aGlzLnNvcnRJbnN0YW5jZU5vZGVQb3NpdGlvbih0aGlzLmN1cnJlbnQsdC5jdXJyZW50KTowfWxvYWRGZWF0dXJlcyh7Y2hpbGRyZW46dCwuLi5lfSxuLHMsaSl7bGV0IG8scjtmb3IobGV0IHQ9MDt0PFNvO3QrKyl7Y29uc3Qgbj1Ub1t0XSx7aXNFbmFibGVkOnMsRmVhdHVyZTppLFByb2plY3Rpb25Ob2RlOmEsTWVhc3VyZUxheW91dDpsfT1vbltuXTthJiYobz1hKSxzKGUpJiYoIXRoaXMuZmVhdHVyZXNbbl0mJmkmJih0aGlzLmZlYXR1cmVzW25dPW5ldyBpKHRoaXMpKSxsJiYocj1sKSl9aWYoIXRoaXMucHJvamVjdGlvbiYmbyl7dGhpcy5wcm9qZWN0aW9uPW5ldyBvKHRoaXMubGF0ZXN0VmFsdWVzLHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5wcm9qZWN0aW9uKTtjb25zdHtsYXlvdXRJZDp0LGxheW91dDpuLGRyYWc6cyxkcmFnQ29uc3RyYWludHM6cixsYXlvdXRTY3JvbGw6YSxsYXlvdXRSb290Omx9PWU7dGhpcy5wcm9qZWN0aW9uLnNldE9wdGlvbnMoe2xheW91dElkOnQsbGF5b3V0Om4sYWx3YXlzTWVhc3VyZUxheW91dDpCb29sZWFuKHMpfHxyJiZaZShyKSx2aXN1YWxFbGVtZW50OnRoaXMsc2NoZWR1bGVSZW5kZXI6KCk9PnRoaXMuc2NoZWR1bGVSZW5kZXIoKSxhbmltYXRpb25UeXBlOlwic3RyaW5nXCI9PXR5cGVvZiBuP246XCJib3RoXCIsaW5pdGlhbFByb21vdGlvbkNvbmZpZzppLGxheW91dFNjcm9sbDphLGxheW91dFJvb3Q6bH0pfXJldHVybiByfXVwZGF0ZUZlYXR1cmVzKCl7Zm9yKGNvbnN0IHQgaW4gdGhpcy5mZWF0dXJlcyl7Y29uc3QgZT10aGlzLmZlYXR1cmVzW3RdO2UuaXNNb3VudGVkP2UudXBkYXRlKCk6KGUubW91bnQoKSxlLmlzTW91bnRlZD0hMCl9fXRyaWdnZXJCdWlsZCgpe3RoaXMuYnVpbGQodGhpcy5yZW5kZXJTdGF0ZSx0aGlzLmxhdGVzdFZhbHVlcyx0aGlzLm9wdGlvbnMsdGhpcy5wcm9wcyl9bWVhc3VyZVZpZXdwb3J0Qm94KCl7cmV0dXJuIHRoaXMuY3VycmVudD90aGlzLm1lYXN1cmVJbnN0YW5jZVZpZXdwb3J0Qm94KHRoaXMuY3VycmVudCx0aGlzLnByb3BzKTp7eDp7bWluOjAsbWF4OjB9LHk6e21pbjowLG1heDowfX19Z2V0U3RhdGljVmFsdWUodCl7cmV0dXJuIHRoaXMubGF0ZXN0VmFsdWVzW3RdfXNldFN0YXRpY1ZhbHVlKHQsZSl7dGhpcy5sYXRlc3RWYWx1ZXNbdF09ZX1tYWtlVGFyZ2V0QW5pbWF0YWJsZSh0LGU9ITApe3JldHVybiB0aGlzLm1ha2VUYXJnZXRBbmltYXRhYmxlRnJvbUluc3RhbmNlKHQsdGhpcy5wcm9wcyxlKX11cGRhdGUodCxlKXsodC50cmFuc2Zvcm1UZW1wbGF0ZXx8dGhpcy5wcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSkmJnRoaXMuc2NoZWR1bGVSZW5kZXIoKSx0aGlzLnByZXZQcm9wcz10aGlzLnByb3BzLHRoaXMucHJvcHM9dCx0aGlzLnByZXZQcmVzZW5jZUNvbnRleHQ9dGhpcy5wcmVzZW5jZUNvbnRleHQsdGhpcy5wcmVzZW5jZUNvbnRleHQ9ZTtmb3IobGV0IGU9MDtlPHdvLmxlbmd0aDtlKyspe2NvbnN0IG49d29bZV07dGhpcy5wcm9wRXZlbnRTdWJzY3JpcHRpb25zW25dJiYodGhpcy5wcm9wRXZlbnRTdWJzY3JpcHRpb25zW25dKCksZGVsZXRlIHRoaXMucHJvcEV2ZW50U3Vic2NyaXB0aW9uc1tuXSk7Y29uc3Qgcz10W1wib25cIituXTtzJiYodGhpcy5wcm9wRXZlbnRTdWJzY3JpcHRpb25zW25dPXRoaXMub24obixzKSl9dGhpcy5wcmV2TW90aW9uVmFsdWVzPWZ1bmN0aW9uKHQsZSxuKXtjb25zdHt3aWxsQ2hhbmdlOnN9PWU7Zm9yKGNvbnN0IGkgaW4gZSl7Y29uc3Qgbz1lW2ldLHI9bltpXTtpZihqZShvKSl0LmFkZFZhbHVlKGksbyksQmUocykmJnMuYWRkKGkpO2Vsc2UgaWYoamUocikpdC5hZGRWYWx1ZShpLFMobyx7b3duZXI6dH0pKSxCZShzKSYmcy5yZW1vdmUoaSk7ZWxzZSBpZihyIT09bylpZih0Lmhhc1ZhbHVlKGkpKXtjb25zdCBlPXQuZ2V0VmFsdWUoaSk7IWUuaGFzQW5pbWF0ZWQmJmUuc2V0KG8pfWVsc2V7Y29uc3QgZT10LmdldFN0YXRpY1ZhbHVlKGkpO3QuYWRkVmFsdWUoaSxTKHZvaWQgMCE9PWU/ZTpvLHtvd25lcjp0fSkpfX1mb3IoY29uc3QgcyBpbiBuKXZvaWQgMD09PWVbc10mJnQucmVtb3ZlVmFsdWUocyk7cmV0dXJuIGV9KHRoaXMsdGhpcy5zY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHModCx0aGlzLnByZXZQcm9wcyksdGhpcy5wcmV2TW90aW9uVmFsdWVzKSx0aGlzLmhhbmRsZUNoaWxkTW90aW9uVmFsdWUmJnRoaXMuaGFuZGxlQ2hpbGRNb3Rpb25WYWx1ZSgpfWdldFByb3BzKCl7cmV0dXJuIHRoaXMucHJvcHN9Z2V0VmFyaWFudCh0KXtyZXR1cm4gdGhpcy5wcm9wcy52YXJpYW50cz90aGlzLnByb3BzLnZhcmlhbnRzW3RdOnZvaWQgMH1nZXREZWZhdWx0VHJhbnNpdGlvbigpe3JldHVybiB0aGlzLnByb3BzLnRyYW5zaXRpb259Z2V0VHJhbnNmb3JtUGFnZVBvaW50KCl7cmV0dXJuIHRoaXMucHJvcHMudHJhbnNmb3JtUGFnZVBvaW50fWdldENsb3Nlc3RWYXJpYW50Tm9kZSgpe3JldHVybiB0aGlzLmlzVmFyaWFudE5vZGU/dGhpczp0aGlzLnBhcmVudD90aGlzLnBhcmVudC5nZXRDbG9zZXN0VmFyaWFudE5vZGUoKTp2b2lkIDB9Z2V0VmFyaWFudENvbnRleHQodD0hMSl7aWYodClyZXR1cm4gdGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQuZ2V0VmFyaWFudENvbnRleHQoKTp2b2lkIDA7aWYoIXRoaXMuaXNDb250cm9sbGluZ1ZhcmlhbnRzKXtjb25zdCB0PXRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC5nZXRWYXJpYW50Q29udGV4dCgpfHx7fTtyZXR1cm4gdm9pZCAwIT09dGhpcy5wcm9wcy5pbml0aWFsJiYodC5pbml0aWFsPXRoaXMucHJvcHMuaW5pdGlhbCksdH1jb25zdCBlPXt9O2ZvcihsZXQgdD0wO3Q8RW87dCsrKXtjb25zdCBuPVFlW3RdLHM9dGhpcy5wcm9wc1tuXTsoS2Uocyl8fCExPT09cykmJihlW25dPXMpfXJldHVybiBlfWFkZFZhcmlhbnRDaGlsZCh0KXtjb25zdCBlPXRoaXMuZ2V0Q2xvc2VzdFZhcmlhbnROb2RlKCk7aWYoZSlyZXR1cm4gZS52YXJpYW50Q2hpbGRyZW4mJmUudmFyaWFudENoaWxkcmVuLmFkZCh0KSwoKT0+ZS52YXJpYW50Q2hpbGRyZW4uZGVsZXRlKHQpfWFkZFZhbHVlKHQsZSl7ZSE9PXRoaXMudmFsdWVzLmdldCh0KSYmKHRoaXMucmVtb3ZlVmFsdWUodCksdGhpcy5iaW5kVG9Nb3Rpb25WYWx1ZSh0LGUpKSx0aGlzLnZhbHVlcy5zZXQodCxlKSx0aGlzLmxhdGVzdFZhbHVlc1t0XT1lLmdldCgpfXJlbW92ZVZhbHVlKHQpe3RoaXMudmFsdWVzLmRlbGV0ZSh0KTtjb25zdCBlPXRoaXMudmFsdWVTdWJzY3JpcHRpb25zLmdldCh0KTtlJiYoZSgpLHRoaXMudmFsdWVTdWJzY3JpcHRpb25zLmRlbGV0ZSh0KSksZGVsZXRlIHRoaXMubGF0ZXN0VmFsdWVzW3RdLHRoaXMucmVtb3ZlVmFsdWVGcm9tUmVuZGVyU3RhdGUodCx0aGlzLnJlbmRlclN0YXRlKX1oYXNWYWx1ZSh0KXtyZXR1cm4gdGhpcy52YWx1ZXMuaGFzKHQpfWdldFZhbHVlKHQsZSl7aWYodGhpcy5wcm9wcy52YWx1ZXMmJnRoaXMucHJvcHMudmFsdWVzW3RdKXJldHVybiB0aGlzLnByb3BzLnZhbHVlc1t0XTtsZXQgbj10aGlzLnZhbHVlcy5nZXQodCk7cmV0dXJuIHZvaWQgMD09PW4mJnZvaWQgMCE9PWUmJihuPVMoZSx7b3duZXI6dGhpc30pLHRoaXMuYWRkVmFsdWUodCxuKSksbn1yZWFkVmFsdWUodCl7dmFyIGU7cmV0dXJuIHZvaWQgMD09PXRoaXMubGF0ZXN0VmFsdWVzW3RdJiZ0aGlzLmN1cnJlbnQ/bnVsbCE9PShlPXRoaXMuZ2V0QmFzZVRhcmdldEZyb21Qcm9wcyh0aGlzLnByb3BzLHQpKSYmdm9pZCAwIT09ZT9lOnRoaXMucmVhZFZhbHVlRnJvbUluc3RhbmNlKHRoaXMuY3VycmVudCx0LHRoaXMub3B0aW9ucyk6dGhpcy5sYXRlc3RWYWx1ZXNbdF19c2V0QmFzZVRhcmdldCh0LGUpe3RoaXMuYmFzZVRhcmdldFt0XT1lfWdldEJhc2VUYXJnZXQodCl7dmFyIGU7Y29uc3R7aW5pdGlhbDpufT10aGlzLnByb3BzLHM9XCJzdHJpbmdcIj09dHlwZW9mIG58fFwib2JqZWN0XCI9PXR5cGVvZiBuP251bGw9PT0oZT12dCh0aGlzLnByb3BzLG4pKXx8dm9pZCAwPT09ZT92b2lkIDA6ZVt0XTp2b2lkIDA7aWYobiYmdm9pZCAwIT09cylyZXR1cm4gcztjb25zdCBpPXRoaXMuZ2V0QmFzZVRhcmdldEZyb21Qcm9wcyh0aGlzLnByb3BzLHQpO3JldHVybiB2b2lkIDA9PT1pfHxqZShpKT92b2lkIDAhPT10aGlzLmluaXRpYWxWYWx1ZXNbdF0mJnZvaWQgMD09PXM/dm9pZCAwOnRoaXMuYmFzZVRhcmdldFt0XTppfW9uKHQsZSl7cmV0dXJuIHRoaXMuZXZlbnRzW3RdfHwodGhpcy5ldmVudHNbdF09bmV3IG0pLHRoaXMuZXZlbnRzW3RdLmFkZChlKX1ub3RpZnkodCwuLi5lKXt0aGlzLmV2ZW50c1t0XSYmdGhpcy5ldmVudHNbdF0ubm90aWZ5KC4uLmUpfX17c29ydEluc3RhbmNlTm9kZVBvc2l0aW9uKHQsZSl7cmV0dXJuIDImdC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlKT8xOi0xfWdldEJhc2VUYXJnZXRGcm9tUHJvcHModCxlKXtyZXR1cm4gdC5zdHlsZT90LnN0eWxlW2VdOnZvaWQgMH1yZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZSh0LHt2YXJzOmUsc3R5bGU6bn0pe2RlbGV0ZSBlW3RdLGRlbGV0ZSBuW3RdfW1ha2VUYXJnZXRBbmltYXRhYmxlRnJvbUluc3RhbmNlKHt0cmFuc2l0aW9uOnQsdHJhbnNpdGlvbkVuZDplLC4uLm59LHt0cmFuc2Zvcm1WYWx1ZXM6c30saSl7bGV0IG89ZnVuY3Rpb24odCxlLG4pe2NvbnN0IHM9e307Zm9yKGNvbnN0IGkgaW4gdCl7Y29uc3QgdD1TdChpLGUpO2lmKHZvaWQgMCE9PXQpc1tpXT10O2Vsc2V7Y29uc3QgdD1uLmdldFZhbHVlKGkpO3QmJihzW2ldPXQuZ2V0KCkpfX1yZXR1cm4gc30obix0fHx7fSx0aGlzKTtpZihzJiYoZSYmKGU9cyhlKSksbiYmKG49cyhuKSksbyYmKG89cyhvKSkpLGkpeyFmdW5jdGlvbih0LGUsbil7dmFyIHMsaTtjb25zdCBvPU9iamVjdC5rZXlzKGUpLmZpbHRlcigoZT0+IXQuaGFzVmFsdWUoZSkpKSxyPW8ubGVuZ3RoO3ZhciBhO2lmKHIpZm9yKGxldCBjPTA7YzxyO2MrKyl7Y29uc3Qgcj1vW2NdLGg9ZVtyXTtsZXQgZD1udWxsO0FycmF5LmlzQXJyYXkoaCkmJihkPWhbMF0pLG51bGw9PT1kJiYoZD1udWxsIT09KGk9bnVsbCE9PShzPW5bcl0pJiZ2b2lkIDAhPT1zP3M6dC5yZWFkVmFsdWUocikpJiZ2b2lkIDAhPT1pP2k6ZVtyXSksbnVsbCE9ZCYmKFwic3RyaW5nXCI9PXR5cGVvZiBkJiYobChkKXx8dShkKSk/ZD1wYXJzZUZsb2F0KGQpOihhPWQsIXl0LmZpbmQocHQoYSkpJiZpdC50ZXN0KGgpJiYoZD1tdChyLGgpKSksdC5hZGRWYWx1ZShyLFMoZCx7b3duZXI6dH0pKSx2b2lkIDA9PT1uW3JdJiYobltyXT1kKSxudWxsIT09ZCYmdC5zZXRCYXNlVGFyZ2V0KHIsZCkpfX0odGhpcyxuLG8pO2NvbnN0IHQ9KCh0LGUsbixzKT0+e2NvbnN0IGk9ZnVuY3Rpb24odCx7Li4uZX0sbil7Y29uc3Qgcz10LmN1cnJlbnQ7aWYoIShzIGluc3RhbmNlb2YgRWxlbWVudCkpcmV0dXJue3RhcmdldDplLHRyYW5zaXRpb25FbmQ6bn07biYmKG49ey4uLm59KSx0LnZhbHVlcy5mb3JFYWNoKCh0PT57Y29uc3QgZT10LmdldCgpO2lmKCFBKGUpKXJldHVybjtjb25zdCBuPWxvKGUscyk7biYmdC5zZXQobil9KSk7Zm9yKGNvbnN0IHQgaW4gZSl7Y29uc3QgaT1lW3RdO2lmKCFBKGkpKWNvbnRpbnVlO2NvbnN0IG89bG8oaSxzKTtvJiYoZVt0XT1vLG58fChuPXt9KSx2b2lkIDA9PT1uW3RdJiYoblt0XT1pKSl9cmV0dXJue3RhcmdldDplLHRyYW5zaXRpb25FbmQ6bn19KHQsZSxzKTtyZXR1cm4gdm8odCxlPWkudGFyZ2V0LG4scz1pLnRyYW5zaXRpb25FbmQpfSkodGhpcyxuLG8sZSk7ZT10LnRyYW5zaXRpb25FbmQsbj10LnRhcmdldH1yZXR1cm57dHJhbnNpdGlvbjp0LHRyYW5zaXRpb25FbmQ6ZSwuLi5ufX19Y2xhc3MgVm8gZXh0ZW5kcyBBb3tyZWFkVmFsdWVGcm9tSW5zdGFuY2UodCxlKXtpZihFdC5oYXMoZSkpe2NvbnN0IHQ9ZHQoZSk7cmV0dXJuIHQmJnQuZGVmYXVsdHx8MH17Y29uc3Qgcz0obj10LHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG4pKSxpPShFKGUpP3MuZ2V0UHJvcGVydHlWYWx1ZShlKTpzW2VdKXx8MDtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgaT9pLnRyaW0oKTppfXZhciBufW1lYXN1cmVJbnN0YW5jZVZpZXdwb3J0Qm94KHQse3RyYW5zZm9ybVBhZ2VQb2ludDplfSl7cmV0dXJuIF9zKHQsZSl9YnVpbGQodCxlLG4scyl7eG4odCxlLG4scy50cmFuc2Zvcm1UZW1wbGF0ZSl9c2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHQsZSl7cmV0dXJuIEZuKHQsZSl9aGFuZGxlQ2hpbGRNb3Rpb25WYWx1ZSgpe3RoaXMuY2hpbGRTdWJzY3JpcHRpb24mJih0aGlzLmNoaWxkU3Vic2NyaXB0aW9uKCksZGVsZXRlIHRoaXMuY2hpbGRTdWJzY3JpcHRpb24pO2NvbnN0e2NoaWxkcmVuOnR9PXRoaXMucHJvcHM7amUodCkmJih0aGlzLmNoaWxkU3Vic2NyaXB0aW9uPXQub24oXCJjaGFuZ2VcIiwodD0+e3RoaXMuY3VycmVudCYmKHRoaXMuY3VycmVudC50ZXh0Q29udGVudD1gJHt0fWApfSkpKX1yZW5kZXJJbnN0YW5jZSh0LGUsbixzKXtMbih0LGUsbixzKX19Y2xhc3MgQ28gZXh0ZW5kcyBBb3tjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5pc1NWR1RhZz0hMX1nZXRCYXNlVGFyZ2V0RnJvbVByb3BzKHQsZSl7cmV0dXJuIHRbZV19cmVhZFZhbHVlRnJvbUluc3RhbmNlKHQsZSl7aWYoRXQuaGFzKGUpKXtjb25zdCB0PWR0KGUpO3JldHVybiB0JiZ0LmRlZmF1bHR8fDB9cmV0dXJuIGU9am4uaGFzKGUpP2U6QXQoZSksdC5nZXRBdHRyaWJ1dGUoZSl9bWVhc3VyZUluc3RhbmNlVmlld3BvcnRCb3goKXtyZXR1cm57eDp7bWluOjAsbWF4OjB9LHk6e21pbjowLG1heDowfX19c2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHQsZSl7cmV0dXJuIE9uKHQsZSl9YnVpbGQodCxlLG4scyl7TW4odCxlLG4sdGhpcy5pc1NWR1RhZyxzLnRyYW5zZm9ybVRlbXBsYXRlKX1yZW5kZXJJbnN0YW5jZSh0LGUsbixzKXtCbih0LGUsMCxzKX1tb3VudCh0KXt0aGlzLmlzU1ZHVGFnPURuKHQudGFnTmFtZSksc3VwZXIubW91bnQodCl9fWNvbnN0IE1vPSh0LGUpPT5tbih0KT9uZXcgQ28oZSx7ZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246ITF9KTpuZXcgVm8oZSx7ZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246ITB9KSxEbz17Li4ubXMsLi4uYXMsLi4ucm8sbGF5b3V0OntQcm9qZWN0aW9uTm9kZTpvbyxNZWFzdXJlTGF5b3V0OmFpfX0sa289aG4oKCh0LGUpPT5mdW5jdGlvbih0LHtmb3J3YXJkTW90aW9uUHJvcHM6ZT0hMX0sbixzKXtyZXR1cm57Li4ubW4odCk/JG46V24scHJlbG9hZGVkRmVhdHVyZXM6bix1c2VSZW5kZXI6Um4oZSksY3JlYXRlVmlzdWFsRWxlbWVudDpzLENvbXBvbmVudDp0fX0odCxlLERvLE1vKSkpLFJvPVswLDEsMiwzLDQsNSw2LDcsOCw5LDAsMSwyLDMsNCw1LDYsNyw4LDksMCwxLDIsMyw0LDUsNiw3LDgsOV0sTG89KHtjbGFzc05hbWU6bixhbmltYXRlVG9OdW1iZXI6cyxmb250U3R5bGU6aSx0cmFuc2l0aW9uczpvLGluY2x1ZGVDb21tYTpyLGxvY2FsZTpsfSk9Pntjb25zdCB1PWUoKS51c2VSZWYobnVsbCksYz1mdW5jdGlvbihlLHtyb290Om4sbWFyZ2luOnMsYW1vdW50Omksb25jZTpvPSExfT17fSl7Y29uc3RbcixsXT0oMCx0LnVzZVN0YXRlKSghMSk7cmV0dXJuKDAsdC51c2VFZmZlY3QpKCgoKT0+e2lmKCFlLmN1cnJlbnR8fG8mJnIpcmV0dXJuO2NvbnN0IHQ9e3Jvb3Q6biYmbi5jdXJyZW50fHx2b2lkIDAsbWFyZ2luOnMsYW1vdW50Oml9O3JldHVybiBmdW5jdGlvbih0LGUse3Jvb3Q6bixtYXJnaW46cyxhbW91bnQ6aT1cInNvbWVcIn09e30pe2NvbnN0IG89ZnVuY3Rpb24odCxlLG4pe2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXt0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodCl9ZWxzZSB0IGluc3RhbmNlb2YgRWxlbWVudCYmKHQ9W3RdKTtyZXR1cm4gQXJyYXkuZnJvbSh0fHxbXSl9KHQpLHI9bmV3IFdlYWtNYXAsbD1uZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKHQ9Pnt0LmZvckVhY2goKHQ9Pntjb25zdCBuPXIuZ2V0KHQudGFyZ2V0KTtpZih0LmlzSW50ZXJzZWN0aW5nIT09Qm9vbGVhbihuKSlpZih0LmlzSW50ZXJzZWN0aW5nKXtjb25zdCBuPWUodCk7XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9yLnNldCh0LnRhcmdldCxuKTpsLnVub2JzZXJ2ZSh0LnRhcmdldCl9ZWxzZSBuJiYobih0KSxyLmRlbGV0ZSh0LnRhcmdldCkpfSkpfSkse3Jvb3Q6bixyb290TWFyZ2luOnMsdGhyZXNob2xkOlwibnVtYmVyXCI9PXR5cGVvZiBpP2k6YVtpXX0pO3JldHVybiBvLmZvckVhY2goKHQ9Pmwub2JzZXJ2ZSh0KSkpLCgpPT5sLmRpc2Nvbm5lY3QoKX0oZS5jdXJyZW50LCgoKT0+KGwoITApLG8/dm9pZCAwOigpPT5sKCExKSkpLHQpfSksW24sZSxzLG9dKSxyfSh1LHtvbmNlOiEwfSksaD1mdW5jdGlvbigpe2NvbnN0IHQ9V2UoJGUpO3JldHVybiB6ZSh0Lm1vdW50LFtdKSx0fSgpLGQ9ZSgpLnVzZVJlZigwKSxtPXI/TWF0aC5hYnMocykudG9Mb2NhbGVTdHJpbmcobHx8XCJlbi1VU1wiKTpTdHJpbmcoTWF0aC5hYnMocykpLHA9QXJyYXkuZnJvbShtLE51bWJlcikubWFwKCgodCxlKT0+aXNOYU4odCk/bVtlXTp0KSksW2YsZ109ZSgpLnVzZVN0YXRlKDApLHk9ZSgpLnVzZVJlZihudWxsKTtyZXR1cm4gZSgpLnVzZUVmZmVjdCgoKCk9Pnt2YXIgdCxlO2NvbnN0IG49bnVsbD09PSh0PXkuY3VycmVudC5nZXRDbGllbnRSZWN0cygpKXx8dm9pZCAwPT09dHx8bnVsbD09PShlPXRbMF0pfHx2b2lkIDA9PT1lP3ZvaWQgMDplLmhlaWdodDtuJiZnKG4pfSksW3MsaV0pLGUoKS51c2VFZmZlY3QoKCgpPT57YyYmaC5zdGFydChcInZpc2libGVcIil9KSxbYyxzXSksZSgpLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIse3JlZjp1fSwwIT09ZiYmZSgpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7c3R5bGU6e2Rpc3BsYXk6XCJmbGV4XCIsZmxleERpcmVjdGlvbjpcInJvd1wiLG92ZXJmbG93OlwiaGlkZGVuXCJ9LGNsYXNzTmFtZTpufSxwLm1hcCgoKHQsbik9Plwic3RyaW5nXCI9PXR5cGVvZiB0P2UoKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse2tleTpuLHN0eWxlOnsuLi5pLGZvbnRWYXJpYW50TnVtZXJpYzpcInRhYnVsYXItbnVtc1wifX0sdCk6ZSgpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7a2V5Om4sc3R5bGU6e2hlaWdodDpmfX0sUm8ubWFwKCh0PT5lKCkuY3JlYXRlRWxlbWVudChrby5kaXYse3N0eWxlOnsuLi5pLGZvbnRWYXJpYW50TnVtZXJpYzpcInRhYnVsYXItbnVtc1wifSxrZXk6XCJcIitkLmN1cnJlbnQrKyxpbml0aWFsOlwiaGlkZGVuXCIsdmFyaWFudHM6e2hpZGRlbjp7eTowfSx2aXNpYmxlOnt5OmYqcFtuXSotMS0yMCpmfX0sYW5pbWF0ZTpoLHRyYW5zaXRpb246bnVsbD09bz92b2lkIDA6byhuKX0sdCkpKSkpKSksZSgpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7cmVmOnksc3R5bGU6e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix0b3A6LTk5OTksLi4uaX19LDApKX0sam89ZSgpLm1lbW8oTG8sKCh0LGUpPT50LmFuaW1hdGVUb051bWJlcj09PWUuYW5pbWF0ZVRvTnVtYmVyJiZ0LmZvbnRTdHlsZT09PWUuZm9udFN0eWxlJiZ0LmluY2x1ZGVDb21tYT09PWUuaW5jbHVkZUNvbW1hKSl9KSgpLGl9KSgpfSkpOyJdLCJuYW1lcyI6WyJ0IiwiZSIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwibiIsInJlYWN0IiwicyIsInNlbGYiLCJpIiwibyIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiZCIsImEiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJyIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsImpvIiwic29tZSIsImFsbCIsImwiLCJ0ZXN0IiwidSIsImMiLCJBcnJheSIsImlzQXJyYXkiLCJoIiwiaW5kZXhPZiIsInB1c2giLCJzcGxpY2UiLCJtIiwiY29uc3RydWN0b3IiLCJzdWJzY3JpcHRpb25zIiwiYWRkIiwibm90aWZ5IiwibGVuZ3RoIiwiZ2V0U2l6ZSIsImNsZWFyIiwicCIsImYiLCJvcmRlciIsInNjaGVkdWxlZCIsIlNldCIsImhhcyIsInJlbW92ZSIsImRlbGV0ZSIsImciLCJzY2hlZHVsZSIsInkiLCJjYW5jZWwiLCJ2Iiwic3RhdGUiLCJ4Iiwic3RlcHMiLCJQIiwiZGVsdGEiLCJ0aW1lc3RhbXAiLCJpc1Byb2Nlc3NpbmciLCJyZWR1Y2UiLCJXZWFrU2V0IiwicHJvY2VzcyIsInBlcmZvcm1hbmNlIiwibm93IiwiTWF0aCIsIm1heCIsIm1pbiIsImZvckVhY2giLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJiIiwiY3VycmVudCIsIlQiLCJ2ZXJzaW9uIiwidGltZURlbHRhIiwibGFzdFVwZGF0ZWQiLCJjYW5UcmFja1ZlbG9jaXR5IiwiZXZlbnRzIiwidXBkYXRlQW5kTm90aWZ5IiwicHJldiIsInBvc3RSZW5kZXIiLCJzY2hlZHVsZVZlbG9jaXR5Q2hlY2siLCJjaGFuZ2UiLCJ2ZWxvY2l0eUNoYW5nZSIsImdldFZlbG9jaXR5IiwicmVuZGVyUmVxdWVzdCIsInZlbG9jaXR5Q2hlY2siLCJoYXNBbmltYXRlZCIsImlzTmFOIiwicGFyc2VGbG9hdCIsIm93bmVyIiwib25DaGFuZ2UiLCJvbiIsInJlYWQiLCJzdG9wIiwiY2xlYXJMaXN0ZW5lcnMiLCJhdHRhY2giLCJwYXNzaXZlRWZmZWN0Iiwic3RvcFBhc3NpdmVFZmZlY3QiLCJzZXQiLCJzZXRXaXRoVmVsb2NpdHkiLCJqdW1wIiwiZ2V0UHJldmlvdXMiLCJzdGFydCIsIlByb21pc2UiLCJhbmltYXRpb24iLCJhbmltYXRpb25TdGFydCIsInRoZW4iLCJhbmltYXRpb25Db21wbGV0ZSIsImNsZWFyQW5pbWF0aW9uIiwiYW5pbWF0aW9uQ2FuY2VsIiwiaXNBbmltYXRpbmciLCJkZXN0cm95IiwiUyIsInciLCJzdGFydHNXaXRoIiwiRSIsIkEiLCJWIiwicm91bmQiLCJDIiwiTSIsIkQiLCJrIiwiUiIsIkwiLCJwYXJzZSIsInRyYW5zZm9ybSIsImoiLCJCIiwiRiIsIkJvb2xlYW4iLCJPIiwibWF0Y2giLCJhbHBoYSIsIkkiLCJVIiwicmVkIiwiZ3JlZW4iLCJibHVlIiwiTiIsInN1YnN0cmluZyIsInBhcnNlSW50IiwiJCIsImVuZHNXaXRoIiwic3BsaXQiLCJXIiwiSCIsInoiLCJZIiwiWCIsIkciLCJxIiwiaHVlIiwic2F0dXJhdGlvbiIsImxpZ2h0bmVzcyIsIloiLCJLIiwicmVnZXgiLCJjb3VudEtleSIsInRva2VuIiwiXyIsIkoiLCJRIiwidG9rZW5pc2VkIiwicmVwbGFjZSIsInZhbHVlcyIsIm1hcCIsInR0IiwidG9TdHJpbmciLCJudW1WYXJzIiwibnVtQ29sb3JzIiwibnVtTnVtYmVycyIsImluY2x1ZGVzIiwiZXQiLCJudCIsInN0IiwiaXQiLCJjcmVhdGVUcmFuc2Zvcm1lciIsImdldEFuaW1hdGFibGVOb25lIiwib3QiLCJydCIsInNsaWNlIiwiYXQiLCJsdCIsImpvaW4iLCJ1dCIsImN0IiwiYm9yZGVyV2lkdGgiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlclJpZ2h0V2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJhZGl1cyIsInJhZGl1cyIsImJvcmRlclRvcExlZnRSYWRpdXMiLCJib3JkZXJUb3BSaWdodFJhZGl1cyIsImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzIiwiYm9yZGVyQm90dG9tTGVmdFJhZGl1cyIsIndpZHRoIiwibWF4V2lkdGgiLCJoZWlnaHQiLCJtYXhIZWlnaHQiLCJzaXplIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwicGFkZGluZyIsInBhZGRpbmdUb3AiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nQm90dG9tIiwicGFkZGluZ0xlZnQiLCJtYXJnaW4iLCJtYXJnaW5Ub3AiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkJvdHRvbSIsIm1hcmdpbkxlZnQiLCJyb3RhdGUiLCJyb3RhdGVYIiwicm90YXRlWSIsInJvdGF0ZVoiLCJzY2FsZSIsInNjYWxlWCIsInNjYWxlWSIsInNjYWxlWiIsInNrZXciLCJza2V3WCIsInNrZXdZIiwiZGlzdGFuY2UiLCJ0cmFuc2xhdGVYIiwidHJhbnNsYXRlWSIsInRyYW5zbGF0ZVoiLCJwZXJzcGVjdGl2ZSIsInRyYW5zZm9ybVBlcnNwZWN0aXZlIiwib3BhY2l0eSIsIm9yaWdpblgiLCJvcmlnaW5ZIiwib3JpZ2luWiIsInpJbmRleCIsImZpbGxPcGFjaXR5Iiwic3Ryb2tlT3BhY2l0eSIsIm51bU9jdGF2ZXMiLCJodCIsImNvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwib3V0bGluZUNvbG9yIiwiZmlsbCIsInN0cm9rZSIsImJvcmRlckNvbG9yIiwiYm9yZGVyVG9wQ29sb3IiLCJib3JkZXJSaWdodENvbG9yIiwiYm9yZGVyQm90dG9tQ29sb3IiLCJib3JkZXJMZWZ0Q29sb3IiLCJmaWx0ZXIiLCJXZWJraXRGaWx0ZXIiLCJkdCIsIm10IiwicHQiLCJmdCIsImd0IiwiZmluZCIsInl0IiwidnQiLCJjdXN0b20iLCJ2YXJpYW50cyIsInh0IiwiZ2V0UHJvcHMiLCJQdCIsImhhc1ZhbHVlIiwiZ2V0VmFsdWUiLCJhZGRWYWx1ZSIsImJ0IiwidHJhbnNpdGlvbkVuZCIsInRyYW5zaXRpb24iLCJtYWtlVGFyZ2V0QW5pbWF0YWJsZSIsIlR0IiwicmV2ZXJzZSIsImdldFZhcmlhbnQiLCJ2YXJpYW50Q2hpbGRyZW4iLCJTdCIsImZyb20iLCJ3dCIsIkV0IiwiQXQiLCJ0b0xvd2VyQ2FzZSIsIlZ0IiwiQ3QiLCJNdCIsIkR0Iiwia3QiLCJMdCIsImV2ZXJ5IiwiUnQiLCJsaW5lYXIiLCJlYXNlIiwiZWFzZUluIiwiZWFzZU91dCIsImVhc2VJbk91dCIsImNpcmNJbiIsImNpcmNPdXQiLCJiYWNrSW4iLCJiYWNrT3V0IiwianQiLCJCdCIsIkZ0IiwiYWJzIiwiT3QiLCJJdCIsIlV0IiwiTnQiLCIkdCIsIld0Iiwic2luIiwiYWNvcyIsIkh0IiwienQiLCJZdCIsIlh0IiwiR3QiLCJxdCIsImNpcmNJbk91dCIsImJhY2tJbk91dCIsImFudGljaXBhdGUiLCJwb3ciLCJadCIsIkt0IiwiX3QiLCJKdCIsInNxcnQiLCJRdCIsInRlIiwiZWUiLCJuZSIsInNlIiwiaWUiLCJvZSIsImxlIiwicmUiLCJhZSIsInVlIiwiY2UiLCJoZSIsImNsYW1wIiwibWl4ZXIiLCJkZSIsImR1cmF0aW9uIiwia2V5ZnJhbWVzIiwidGltZXMiLCJkb25lIiwiY2FsY3VsYXRlZER1cmF0aW9uIiwibmV4dCIsIm1lIiwicGUiLCJmZSIsImdlIiwieWUiLCJ2ZSIsInJlc3REZWx0YSIsInJlc3RTcGVlZCIsInN0aWZmbmVzcyIsImRhbXBpbmciLCJtYXNzIiwidmVsb2NpdHkiLCJpc1Jlc29sdmVkRnJvbUR1cmF0aW9uIiwiYm91bmNlIiwiZXhwIiwiY29zIiwic2luaCIsImNvc2giLCJ4ZSIsInBvd2VyIiwidGltZUNvbnN0YW50IiwiYm91bmNlRGFtcGluZyIsImJvdW5jZVN0aWZmbmVzcyIsIm1vZGlmeVRhcmdldCIsIlBlIiwidXBkYXRlIiwiYmUiLCJUZSIsImRlY2F5IiwiaW5lcnRpYSIsInR3ZWVuIiwic3ByaW5nIiwiU2UiLCJhdXRvcGxheSIsImRlbGF5IiwiZHJpdmVyIiwidHlwZSIsInJlcGVhdCIsInJlcGVhdERlbGF5IiwicmVwZWF0VHlwZSIsIm9uUGxheSIsIm9uU3RvcCIsIm9uQ29tcGxldGUiLCJvblVwZGF0ZSIsImZsb29yIiwidGltZSIsInNwZWVkIiwicGxheSIsInBhdXNlIiwiY29tcGxldGUiLCJzYW1wbGUiLCJ3ZSIsIkVsZW1lbnQiLCJFZSIsIkFlIiwiVmUiLCJDZSIsIk1lIiwiRGUiLCJrZSIsIlJlIiwiTGUiLCJlbGFwc2VkIiwid2hlbiIsImRlbGF5Q2hpbGRyZW4iLCJzdGFnZ2VyQ2hpbGRyZW4iLCJzdGFnZ2VyRGlyZWN0aW9uIiwia2V5cyIsInJlc29sdmUiLCJIVE1MRWxlbWVudCIsIm9mZnNldCIsImVhc2luZyIsImFuaW1hdGUiLCJpdGVyYXRpb25zIiwiZGlyZWN0aW9uIiwic3luY1N0YXJ0Iiwic3RhcnRUaW1lIiwiZG9jdW1lbnQiLCJ0aW1lbGluZSIsImN1cnJlbnRUaW1lIiwib25maW5pc2giLCJhdHRhY2hUaW1lbGluZSIsInBsYXliYWNrUmF0ZSIsInBsYXlTdGF0ZSIsImZpbmlzaCIsImplIiwiQmUiLCJGZSIsInByb3RlY3RlZEtleXMiLCJuZWVkc0FuaW1hdGluZyIsIk9lIiwidHJhbnNpdGlvbk92ZXJyaWRlIiwiZ2V0RGVmYXVsdFRyYW5zaXRpb24iLCJhbmltYXRpb25TdGF0ZSIsImdldFN0YXRlIiwid2luZG93IiwiSGFuZG9mZkFwcGVhckFuaW1hdGlvbnMiLCJzaG91bGRSZWR1Y2VNb3Rpb24iLCJJZSIsInNvcnQiLCJVZSIsInNvcnROb2RlUG9zaXRpb24iLCJOZSIsIiRlIiwic3Vic2NyaWJlIiwibW91bnQiLCJXZSIsInVzZVJlZiIsIkhlIiwiemUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJZZSIsImNyZWF0ZUNvbnRleHQiLCJ0cmFuc2Zvcm1QYWdlUG9pbnQiLCJpc1N0YXRpYyIsInJlZHVjZWRNb3Rpb24iLCJYZSIsIkdlIiwicWUiLCJzdHJpY3QiLCJaZSIsIktlIiwiX2UiLCJKZSIsIlFlIiwidG4iLCJlbiIsIm5uIiwic24iLCJleGl0IiwiZHJhZyIsImZvY3VzIiwiaG92ZXIiLCJ0YXAiLCJwYW4iLCJpblZpZXciLCJsYXlvdXQiLCJpc0VuYWJsZWQiLCJybiIsImFuIiwibG4iLCJmb3IiLCJ1biIsInByZWxvYWRlZEZlYXR1cmVzIiwiY3JlYXRlVmlzdWFsRWxlbWVudCIsInVzZVJlbmRlciIsInVzZVZpc3VhbFN0YXRlIiwiQ29tcG9uZW50IiwiZm9yd2FyZFJlZiIsInVzZUNvbnRleHQiLCJsYXlvdXRJZCIsImNuIiwiaW5pdGlhbCIsImluaGVyaXQiLCJ1c2VNZW1vIiwidmlzdWFsRWxlbWVudCIsInJlbmRlcmVyIiwidmlzdWFsU3RhdGUiLCJwYXJlbnQiLCJwcm9wcyIsInByZXNlbmNlQ29udGV4dCIsImJsb2NrSW5pdGlhbEFuaW1hdGlvbiIsInJlZHVjZWRNb3Rpb25Db25maWciLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJyZW5kZXIiLCJhbmltYXRlQ2hhbmdlcyIsInVwZGF0ZUZlYXR1cmVzIiwibG9hZEZlYXR1cmVzIiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwidXNlQ2FsbGJhY2siLCJ1bm1vdW50IiwiaWQiLCJobiIsIlByb3h5IiwiTWFwIiwiZG4iLCJtbiIsInBuIiwiZm4iLCJnbiIsInluIiwidm4iLCJ4biIsInN0eWxlIiwidmFycyIsInRyYW5zZm9ybU9yaWdpbiIsImVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uIiwiYWxsb3dUcmFuc2Zvcm1Ob25lIiwidHJpbSIsIlBuIiwiYm4iLCJhc3NpZ24iLCJ0cmFuc2Zvcm1UZW1wbGF0ZSIsInRyYW5zZm9ybVZhbHVlcyIsImRyYWdMaXN0ZW5lciIsImRyYWdnYWJsZSIsInVzZXJTZWxlY3QiLCJXZWJraXRVc2VyU2VsZWN0IiwiV2Via2l0VG91Y2hDYWxsb3V0IiwidG91Y2hBY3Rpb24iLCJ0YWJJbmRleCIsIm9uVGFwIiwib25UYXBTdGFydCIsIndoaWxlVGFwIiwiVG4iLCJTbiIsInduIiwiRW4iLCJBbiIsIlZuIiwiYXJyYXkiLCJDbiIsIk1uIiwiYXR0clgiLCJhdHRyWSIsImF0dHJTY2FsZSIsInBhdGhMZW5ndGgiLCJwYXRoU3BhY2luZyIsInBhdGhPZmZzZXQiLCJ2aWV3Qm94IiwiYXR0cnMiLCJkaW1lbnNpb25zIiwiRG4iLCJrbiIsIlJuIiwibGF0ZXN0VmFsdWVzIiwicmVmIiwiY2hpbGRyZW4iLCJMbiIsImdldFByb2plY3Rpb25TdHlsZXMiLCJzZXRQcm9wZXJ0eSIsImpuIiwiQm4iLCJzZXRBdHRyaWJ1dGUiLCJGbiIsIk9uIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJJbiIsIm1peCIsInRvVmFsdWUiLCJVbiIsInNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyIsImNyZWF0ZVJlbmRlclN0YXRlIiwib25Nb3VudCIsIk5uIiwicmVuZGVyU3RhdGUiLCIkbiIsImdldEJCb3giLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0YWdOYW1lIiwiV24iLCJIbiIsInBhc3NpdmUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInpuIiwicG9pbnRlclR5cGUiLCJidXR0b24iLCJpc1ByaW1hcnkiLCJZbiIsInBvaW50IiwiWG4iLCJHbiIsInFuIiwiWm4iLCJLbiIsIl9uIiwiSm4iLCJpc01vdW50ZWQiLCJub2RlIiwiUW4iLCJ3aGlsZUhvdmVyIiwic2V0QWN0aXZlIiwidHMiLCJwYXJlbnRFbGVtZW50IiwiZXMiLCJQb2ludGVyRXZlbnQiLCJucyIsIldlYWtNYXAiLCJzcyIsImlzIiwidGFyZ2V0Iiwib3MiLCJycyIsImFzIiwiRmVhdHVyZSIsImFyZ3VtZW50cyIsImhhc0VudGVyZWRWaWV3IiwiaXNJblZpZXciLCJzdGFydE9ic2VydmVyIiwidmlld3BvcnQiLCJyb290IiwiYW1vdW50Iiwib25jZSIsInJvb3RNYXJnaW4iLCJ0aHJlc2hvbGQiLCJKU09OIiwic3RyaW5naWZ5IiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwidW5vYnNlcnZlIiwiaXNJbnRlcnNlY3RpbmciLCJvblZpZXdwb3J0RW50ZXIiLCJvblZpZXdwb3J0TGVhdmUiLCJwcmV2UHJvcHMiLCJyZW1vdmVTdGFydExpc3RlbmVycyIsInJlbW92ZUVuZExpc3RlbmVycyIsInJlbW92ZUFjY2Vzc2libGVMaXN0ZW5lcnMiLCJzdGFydFBvaW50ZXJQcmVzcyIsImlzUHJlc3NpbmciLCJjaGVja1ByZXNzRW5kIiwib25UYXBDYW5jZWwiLCJvblBvaW50ZXJVcCIsImNhbmNlbFByZXNzIiwib25Qb2ludGVyQ2FuY2VsIiwic3RhcnRQcmVzcyIsInN0YXJ0QWNjZXNzaWJsZVByZXNzIiwia2V5Iiwib25Qb2ludGVyU3RhcnQiLCJpc0FjdGl2ZSIsIm9uRm9jdXMiLCJtYXRjaGVzIiwib25CbHVyIiwibHMiLCJ1cyIsImNzIiwiaHMiLCJwcmV2UmVzb2x2ZWRWYWx1ZXMiLCJkcyIsIm1zIiwib3B0aW9ucyIsIndoaWxlSW5WaWV3Iiwid2hpbGVEcmFnIiwid2hpbGVGb2N1cyIsImdldFZhcmlhbnRDb250ZXh0IiwibWFudWFsbHlBbmltYXRlT25Nb3VudCIsInByZXZQcm9wIiwiZ2V0QmFzZVRhcmdldCIsInNldEFuaW1hdGVGdW5jdGlvbiIsInVwZGF0ZUFuaW1hdGlvbkNvbnRyb2xzU3Vic2NyaXB0aW9uIiwiaXNQcmVzZW50Iiwib25FeGl0Q29tcGxldGUiLCJwcmV2UHJlc2VuY2VDb250ZXh0IiwicmVnaXN0ZXIiLCJwcyIsImZzIiwic3RhcnRFdmVudCIsImxhc3RNb3ZlRXZlbnQiLCJsYXN0TW92ZUV2ZW50SW5mbyIsImhhbmRsZXJzIiwidXBkYXRlUG9pbnQiLCJ2cyIsImhpc3RvcnkiLCJvblN0YXJ0Iiwib25Nb3ZlIiwiaGFuZGxlUG9pbnRlck1vdmUiLCJncyIsImhhbmRsZVBvaW50ZXJVcCIsImVuZCIsIm9uRW5kIiwib25TZXNzaW9uRW5kIiwib25TZXNzaW9uU3RhcnQiLCJyZW1vdmVMaXN0ZW5lcnMiLCJ1cGRhdGVIYW5kbGVycyIsInlzIiwiUHMiLCJ4cyIsImJzIiwiVHMiLCJTcyIsIndzIiwib3JpZ2luIiwib3JpZ2luUG9pbnQiLCJ0cmFuc2xhdGUiLCJFcyIsIkFzIiwiVnMiLCJDcyIsIk1zIiwiRHMiLCJrcyIsIlJzIiwiTHMiLCJqcyIsIkJzIiwiRnMiLCJPcyIsIklzIiwiVXMiLCJOcyIsIiRzIiwiV3MiLCJIcyIsInpzIiwiWXMiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJYcyIsIkdzIiwicXMiLCJacyIsIktzIiwiX3MiLCJKcyIsIlFzIiwib3Blbkdsb2JhbExvY2siLCJpc0RyYWdnaW5nIiwiY3VycmVudERpcmVjdGlvbiIsImNvbnN0cmFpbnRzIiwiaGFzTXV0YXRlZENvbnN0cmFpbnRzIiwiZWxhc3RpYyIsInNuYXBUb0N1cnNvciIsInBhblNlc3Npb24iLCJzdG9wQW5pbWF0aW9uIiwiZHJhZ1Byb3BhZ2F0aW9uIiwib25EcmFnU3RhcnQiLCJyZXNvbHZlQ29uc3RyYWludHMiLCJwcm9qZWN0aW9uIiwiaXNBbmltYXRpb25CbG9ja2VkIiwiZ2V0QXhpc01vdGlvblZhbHVlIiwibGF5b3V0Qm94IiwiZHJhZ0RpcmVjdGlvbkxvY2siLCJvbkRpcmVjdGlvbkxvY2siLCJvbkRyYWciLCJ1cGRhdGVBeGlzIiwiZ2V0VHJhbnNmb3JtUGFnZVBvaW50Iiwic3RhcnRBbmltYXRpb24iLCJvbkRyYWdFbmQiLCJ0aSIsImRyYWdDb25zdHJhaW50cyIsImRyYWdFbGFzdGljIiwicmVzb2x2ZVJlZkNvbnN0cmFpbnRzIiwib25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzIiwic2Nyb2xsIiwiZHJhZ01vbWVudHVtIiwiZHJhZ1RyYW5zaXRpb24iLCJkcmFnU25hcFRvT3JpZ2luIiwib25EcmFnVHJhbnNpdGlvbkVuZCIsInN0YXJ0QXhpc1ZhbHVlQW5pbWF0aW9uIiwic2NhbGVQb3NpdGlvbldpdGhpbkNvbnN0cmFpbnRzIiwidXBkYXRlU2Nyb2xsIiwidXBkYXRlTGF5b3V0IiwiYWRkTGlzdGVuZXJzIiwiaGFzTGF5b3V0Q2hhbmdlZCIsImVpIiwibmkiLCJoYXNBbmltYXRlZFNpbmNlUmVzaXplIiwiaGFzRXZlclVwZGF0ZWQiLCJzaSIsImlpIiwiY29ycmVjdCIsIm9pIiwidHJlZVNjYWxlIiwicHJvamVjdGlvbkRlbHRhIiwicmkiLCJjb21wb25lbnREaWRNb3VudCIsImxheW91dEdyb3VwIiwic3dpdGNoTGF5b3V0R3JvdXAiLCJsaSIsImdyb3VwIiwiZGlkVXBkYXRlIiwic2FmZVRvUmVtb3ZlIiwic2V0T3B0aW9ucyIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwibGF5b3V0RGVwZW5kZW5jeSIsIndpbGxVcGRhdGUiLCJwcm9tb3RlIiwicmVsZWdhdGUiLCJnZXRTdGFjayIsIm1lbWJlcnMiLCJjb21wb25lbnREaWRVcGRhdGUiLCJxdWV1ZU1pY3JvdGFzayIsImN1cnJlbnRBbmltYXRpb24iLCJpc0xlYWQiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInNjaGVkdWxlQ2hlY2tBZnRlclVubW91bnQiLCJkZXJlZ2lzdGVyIiwiYWkiLCJ1c2VJZCIsImFwcGx5VG8iLCJib3hTaGFkb3ciLCJ1aSIsImNpIiwiaGkiLCJkaSIsIm1pIiwicGkiLCJnaSIsImZpIiwieWkiLCJ2aSIsInhpIiwiUGkiLCJiaSIsIlRpIiwiU2kiLCJ3aSIsIkVpIiwiQWkiLCJWaSIsIkNpIiwic2NoZWR1bGVSZW5kZXIiLCJwcmV2TGVhZCIsImxlYWQiLCJmaW5kSW5kZXgiLCJzaG93IiwiaW5zdGFuY2UiLCJyZXN1bWVGcm9tIiwicHJlc2VydmVPcGFjaXR5Iiwic25hcHNob3QiLCJhbmltYXRpb25WYWx1ZXMiLCJpc1VwZGF0aW5nIiwiaXNMYXlvdXREaXJ0eSIsImNyb3NzZmFkZSIsImhpZGUiLCJleGl0QW5pbWF0aW9uQ29tcGxldGUiLCJyZXN1bWluZ0Zyb20iLCJyZW1vdmVMZWFkU25hcHNob3QiLCJNaSIsIkRpIiwiZGVwdGgiLCJraSIsImlzRGlydHkiLCJSaSIsIkxpIiwiamkiLCJ0b3RhbE5vZGVzIiwicmVzb2x2ZWRUYXJnZXREZWx0YXMiLCJyZWNhbGN1bGF0ZWRQcm9qZWN0aW9uIiwiQmkiLCJhdHRhY2hSZXNpemVMaXN0ZW5lciIsImRlZmF1bHRQYXJlbnQiLCJtZWFzdXJlU2Nyb2xsIiwiY2hlY2tJc1Njcm9sbFJvb3QiLCJyZXNldFRyYW5zZm9ybSIsImFuaW1hdGlvbklkIiwiaXNUcmVlQW5pbWF0aW5nIiwiaXNQcm9qZWN0aW9uRGlydHkiLCJpc1NoYXJlZFByb2plY3Rpb25EaXJ0eSIsImlzVHJhbnNmb3JtRGlydHkiLCJ1cGRhdGVNYW51YWxseUJsb2NrZWQiLCJ1cGRhdGVCbG9ja2VkQnlSZXNpemUiLCJpc1NWRyIsIm5lZWRzUmVzZXQiLCJzaG91bGRSZXNldFRyYW5zZm9ybSIsImV2ZW50SGFuZGxlcnMiLCJoYXNUcmVlQW5pbWF0ZWQiLCJ1cGRhdGVTY2hlZHVsZWQiLCJjaGVja1VwZGF0ZUZhaWxlZCIsImNsZWFyQWxsU25hcHNob3RzIiwidXBkYXRlUHJvamVjdGlvbiIsIm5vZGVzIiwiSWkiLCJZaSIsIlhpIiwiVWkiLCJNb3Rpb25EZWJ1ZyIsInJlY29yZCIsImhhc1Byb2plY3RlZCIsImlzVmlzaWJsZSIsImFuaW1hdGlvblByb2dyZXNzIiwic2hhcmVkTm9kZXMiLCJwYXRoIiwibm90aWZ5TGlzdGVuZXJzIiwiaGFzTGlzdGVuZXJzIiwiU1ZHRWxlbWVudCIsInppIiwicmVnaXN0ZXJTaGFyZWROb2RlIiwiaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkIiwiaXNUcmVlQW5pbWF0aW9uQmxvY2tlZCIsInJlbGF0aXZlVGFyZ2V0IiwiSmkiLCJvbkxheW91dEFuaW1hdGlvblN0YXJ0Iiwib25MYXlvdXRBbmltYXRpb25Db21wbGV0ZSIsInRhcmdldExheW91dCIsImxheW91dFJvb3QiLCJzZXRBbmltYXRpb25PcmlnaW4iLCJibG9ja1VwZGF0ZSIsInVuYmxvY2tVcGRhdGUiLCJpc1VwZGF0ZUJsb2NrZWQiLCJzdGFydFVwZGF0ZSIsIkdpIiwiZ2V0VHJhbnNmb3JtVGVtcGxhdGUiLCJwcmV2VHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSIsInVwZGF0ZVNuYXBzaG90IiwiJGkiLCJXaSIsIkhpIiwiRmkiLCJPaSIsInByZVJlbmRlciIsIk5pIiwicWkiLCJzY2hlZHVsZVVwZGF0ZVByb2plY3Rpb24iLCJtZWFzdXJlIiwiYWx3YXlzTWVhc3VyZUxheW91dCIsImxheW91dENvcnJlY3RlZCIsImxheW91dFNjcm9sbCIsInBoYXNlIiwiaXNSb290IiwibWVhc3VyZVBhZ2VCb3giLCJyZW1vdmVFbGVtZW50U2Nyb2xsIiwicmVtb3ZlVHJhbnNmb3JtIiwiZW8iLCJtZWFzdXJlZEJveCIsInNvdXJjZSIsIm1lYXN1cmVWaWV3cG9ydEJveCIsImFwcGx5VHJhbnNmb3JtIiwic2V0VGFyZ2V0RGVsdGEiLCJ0YXJnZXREZWx0YSIsImNsZWFyTWVhc3VyZW1lbnRzIiwiZm9yY2VSZWxhdGl2ZVBhcmVudFRvUmVzb2x2ZVRhcmdldCIsInJlbGF0aXZlUGFyZW50IiwicmVzb2x2ZWRSZWxhdGl2ZVRhcmdldEF0IiwicmVzb2x2ZVRhcmdldERlbHRhIiwiZ2V0TGVhZCIsImF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldCIsImdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50IiwicmVsYXRpdmVUYXJnZXRPcmlnaW4iLCJ0YXJnZXRXaXRoVHJhbnNmb3JtcyIsImlzUHJvamVjdGluZyIsImNhbGNQcm9qZWN0aW9uIiwicGVuZGluZ0FuaW1hdGlvbiIsImRpc3BsYXkiLCJwcm9qZWN0aW9uVHJhbnNmb3JtIiwicHJvamVjdGlvbkRlbHRhV2l0aFRyYW5zZm9ybSIsIl9pIiwibWl4VGFyZ2V0RGVsdGEiLCJaaSIsIktpIiwib3BhY2l0eUV4aXQiLCJjb21wbGV0ZUFuaW1hdGlvbiIsImZpbmlzaEFuaW1hdGlvbiIsImFwcGx5VHJhbnNmb3Jtc1RvVGFyZ2V0Iiwibm8iLCJhbmltYXRpb25UeXBlIiwiaW5pdGlhbFByb21vdGlvbkNvbmZpZyIsInByZXNlcnZlRm9sbG93T3BhY2l0eSIsInNob3VsZFByZXNlcnZlRm9sbG93T3BhY2l0eSIsImdldFByZXZMZWFkIiwicmVzZXRSb3RhdGlvbiIsInNldFN0YXRpY1ZhbHVlIiwidmlzaWJpbGl0eSIsInBvaW50ZXJFdmVudHMiLCJjbGVhclNuYXBzaG90IiwicmVzZXRUcmVlIiwibGF5b3V0RGVsdGEiLCJvbkJlZm9yZUxheW91dE1lYXN1cmUiLCJRaSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInRvIiwic28iLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGxMZWZ0IiwiYm9keSIsInNjcm9sbFRvcCIsImlvIiwib28iLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJybyIsInJlbW92ZVBvaW50ZXJEb3duTGlzdGVuZXIiLCJvblBvaW50ZXJEb3duIiwic2Vzc2lvbiIsImNyZWF0ZVBhbkhhbmRsZXJzIiwib25QYW5TZXNzaW9uU3RhcnQiLCJvblBhblN0YXJ0Iiwib25QYW4iLCJvblBhbkVuZCIsInJlbW92ZUdyb3VwQ29udHJvbHMiLCJjb250cm9scyIsImRyYWdDb250cm9scyIsIlByb2plY3Rpb25Ob2RlIiwiTWVhc3VyZUxheW91dCIsImFvIiwibG8iLCJleGVjIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInVvIiwiY28iLCJobyIsIm1vIiwicG8iLCJmbyIsImdvIiwieW8iLCJ2byIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG8iLCJ4byIsIlBvIiwiYm8iLCJUbyIsIlNvIiwid28iLCJFbyIsIkFvIiwiaXNWYXJpYW50Tm9kZSIsImlzQ29udHJvbGxpbmdWYXJpYW50cyIsImZlYXR1cmVzIiwidmFsdWVTdWJzY3JpcHRpb25zIiwicHJldk1vdGlvblZhbHVlcyIsInByb3BFdmVudFN1YnNjcmlwdGlvbnMiLCJub3RpZnlVcGRhdGUiLCJ0cmlnZ2VyQnVpbGQiLCJyZW5kZXJJbnN0YW5jZSIsImJhc2VUYXJnZXQiLCJpbml0aWFsVmFsdWVzIiwid2lsbENoYW5nZSIsInJlbW92ZUZyb21WYXJpYW50VHJlZSIsImFkZFZhcmlhbnRDaGlsZCIsImJpbmRUb01vdGlvblZhbHVlIiwibWF0Y2hNZWRpYSIsImFkZExpc3RlbmVyIiwic29ydEluc3RhbmNlTm9kZVBvc2l0aW9uIiwiYnVpbGQiLCJtZWFzdXJlSW5zdGFuY2VWaWV3cG9ydEJveCIsImdldFN0YXRpY1ZhbHVlIiwibWFrZVRhcmdldEFuaW1hdGFibGVGcm9tSW5zdGFuY2UiLCJyZW1vdmVWYWx1ZSIsImhhbmRsZUNoaWxkTW90aW9uVmFsdWUiLCJnZXRDbG9zZXN0VmFyaWFudE5vZGUiLCJyZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZSIsInJlYWRWYWx1ZSIsImdldEJhc2VUYXJnZXRGcm9tUHJvcHMiLCJyZWFkVmFsdWVGcm9tSW5zdGFuY2UiLCJzZXRCYXNlVGFyZ2V0IiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJWbyIsImNoaWxkU3Vic2NyaXB0aW9uIiwidGV4dENvbnRlbnQiLCJDbyIsImlzU1ZHVGFnIiwiZ2V0QXR0cmlidXRlIiwiTW8iLCJEbyIsImtvIiwiZm9yd2FyZE1vdGlvblByb3BzIiwiUm8iLCJMbyIsImNsYXNzTmFtZSIsImFuaW1hdGVUb051bWJlciIsImZvbnRTdHlsZSIsInRyYW5zaXRpb25zIiwiaW5jbHVkZUNvbW1hIiwibG9jYWxlIiwidXNlU3RhdGUiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZGlzY29ubmVjdCIsInRvTG9jYWxlU3RyaW5nIiwiU3RyaW5nIiwiZ2V0Q2xpZW50UmVjdHMiLCJmbGV4RGlyZWN0aW9uIiwib3ZlcmZsb3ciLCJmb250VmFyaWFudE51bWVyaWMiLCJkaXYiLCJoaWRkZW4iLCJ2aXNpYmxlIiwibWVtbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-animated-numbers/dist/index.js\n");

/***/ })

};
;